<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>連結 on takatomo&#39;s blog</title>
    <link>https://chaingng.github.io/tags/%E9%80%A3%E7%B5%90/</link>
    <description>Recent content in 連結 on takatomo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 16 Mar 2015 19:15:00 +0000</lastBuildDate>
    
	<atom:link href="https://chaingng.github.io/tags/%E9%80%A3%E7%B5%90/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SRM 645 DIV2 Middle - ConnectingCars (○)</title>
      <link>https://chaingng.github.io/post/srm-645-div2-middle---connectingcars-/</link>
      <pubDate>Mon, 16 Mar 2015 19:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-645-div2-middle---connectingcars-/</guid>
      <description>問題 
・一列の道路に車が複数あり、その車の先頭位置とその長さが与えられる。
・全ての車を連結したいとき、必要となる最小の移動距離を求める。
解き方 
・車を連結させるとき、そのうち一つの車の位置は固定となることがわかれば解ける。
・あとは実装の問題。
ある車を固定した時の移動距離を、左側にあるものの計算と右側にあるものの計算を分けて、
近い順に行っていけばシンプルに実装できる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ConnectingCars {
public: long long minimizeCost(vector&amp;lt;int&amp;gt; positions, vector&amp;lt;int&amp;gt; lengths) {
int n=positions.size();
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
FORE(i,0,n)p.push_back(make_pair(positions[i],lengths[i]));
sort(all(p));
long long ret=1e+18;
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 646 DIV1 Easy - TheConsecutiveIntegersDivOne x○</title>
      <link>https://chaingng.github.io/post/srm-646-div1-easy---theconsecutiveintegersdivone-x/</link>
      <pubDate>Sun, 15 Mar 2015 11:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-646-div1-easy---theconsecutiveintegersdivone-x/</guid>
      <description>問題 
・複数の数字が与えられる。
・ｋ個の数字が連続して並ぶようにしたい。
・数字を１つ動かすのにコストが１かかるとき、最小のコストを求める。
解き方 
・数字を連結させるための最小コストを求めるとき、
少なくともひとつの数字の場所は固定されていることがわかれば解ける。
・あとはｋ個の連続する数字の範囲全てについて、そのうち全ての数字を固定した場合の
最小コストを求めればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheConsecutiveIntegersDivOne {
public: int find(vector&amp;lt;int&amp;gt; numbers, int k) {
int n=numbers.size();
sort(all(numbers));
int ret=1e+9;
for(int i=0;i+k-1&amp;lt;n;i++){
for(int j=i;j&amp;lt;=i+k-1;j++){
int cost=0;</description>
    </item>
    
  </channel>
</rss>