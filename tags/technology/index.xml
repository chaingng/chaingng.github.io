<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on takatomo&#39;s blog</title>
    <link>https://chaingng.github.io/tags/technology/</link>
    <description>Recent content in Technology on takatomo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 31 Oct 2014 22:24:00 +0000</lastBuildDate>
    
	<atom:link href="https://chaingng.github.io/tags/technology/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Windowsのプロキシ</title>
      <link>https://chaingng.github.io/post/windows%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/</link>
      <pubDate>Fri, 31 Oct 2014 22:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/windows%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/</guid>
      <description>Windowsのプロキシには２種類存在する。
１つめはInternetExplorerのプロキシサーバー設定、もう一つは主にWindows Updateに使用されるWinhttpのプロキシ設定。
InternetExplorerはIEのインターネットオプションから設定できるが、
Winhttpはnetshコマンドにて設定する。
設定方法としては、直接設定するものとIEの設定をコピーする方法の２つ。
直接設定する方法
netsh winhttp set proxy proxy-server=&#34;myProxyServer:8080&#34; bypass-list=&#34;&amp;lt;local&amp;gt;;*.microsoft.com;*.foo.ne&#34;
IEの設定をコピーする方法
netsh winhttp import proxy source=ie
現在の設定は、以下のコマンドで確認できる。
netsh winhttp show proxy
また、以下のコマンドで設定をリセット（プロキシなしに）できる。
netsh winhttp reset proxy
WindowsUpdateは手動での更新時はIEの設定が利用されるが、
自動更新時はWinhttpのプロキシ設定が適用されるため、プロキシ環境下で自動更新を行いたいときは必要な設定となる。
（参考）公式ページ
http://support.microsoft.com/kb/2894304/ja
 </description>
    </item>
    
    <item>
      <title>makeの種類</title>
      <link>https://chaingng.github.io/post/make%E3%81%AE%E7%A8%AE%E9%A1%9E/</link>
      <pubDate>Fri, 31 Oct 2014 19:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/make%E3%81%AE%E7%A8%AE%E9%A1%9E/</guid>
      <description>makeにはいくつかの種類がある。
・GNU make
&amp;nbsp;gmakeとかいわれる。
&amp;nbsp;UNIX系で標準的に使われるもので、Windows系ではcygwinとかでも使われている。
・Microsoft Program Maintenance Utility
&amp;nbsp;nmakeともいわれる。
&amp;nbsp;Visual Studio C++などを使うときはこちらでmakeする必要あり。
・BSD make
&amp;nbsp;pmakeとも言われる。
&amp;nbsp;BSD系のUnixではこちらを使う必要がある。
そのため、利用する環境に応じてmakeする必要があるので注意。
 </description>
    </item>
    
    <item>
      <title>サービスの自動起動</title>
      <link>https://chaingng.github.io/post/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E8%87%AA%E5%8B%95%E8%B5%B7%E5%8B%95/</link>
      <pubDate>Thu, 30 Oct 2014 12:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E8%87%AA%E5%8B%95%E8%B5%B7%E5%8B%95/</guid>
      <description>chkconfigを使う。
ランレベル２～５での自動起動
chkconfig httpd on
起動レベルを指定（ランレベル３，５で起動）
chkconfig httpd on --level 35
自動起動しているサービス一覧の表示
chkconfig --list
ランレベルとはOSが起動するときのシステムの状態。
現在どのランレベルで起動しているか、以下のコマンドで知ることができる。
/sbin/runlevel
 </description>
    </item>
    
    <item>
      <title>linuxで複数のファイルを結合</title>
      <link>https://chaingng.github.io/post/linux%E3%81%A7%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88/</link>
      <pubDate>Wed, 29 Oct 2014 18:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%A7%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88/</guid>
      <description>catコマンドを使う。
下記のコマンドで指定したディレクトリ以下の全てのファイルを結合し、
newfilename.txtにその結果を保存できる。
cat targetdir/* &amp;gt; newfilename.txt&amp;nbsp;
ちなみにmanコマンドは以下の通り。
Concatenate　filesなのでcatコマンド。
CAT(1) &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; User Commands &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CAT(1)
NAME
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;cat - concatenate files and print on the standard output
SYNOPSIS
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;cat [OPTION]... [FILE]...
DESCRIPTION
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Concatenate FILE(s), or standard input, to standard output.</description>
    </item>
    
    <item>
      <title>RISCとCISC</title>
      <link>https://chaingng.github.io/post/risc%E3%81%A8cisc/</link>
      <pubDate>Fri, 17 Oct 2014 23:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/risc%E3%81%A8cisc/</guid>
      <description>プロセッサを支える技術から、RISCとCISCについて整理。
RISC（Reduced Instruction Set Computer）は固定長の単純な命令を実行する方式のコンピュータ。
CISC(Complex Instruction Set Computer)は可変長で命令体型が複雑なコンピュータ。
RISCの命令は４バイト固定長。
メモリアクセスはロード命令、ストア命令という専用の命令を使う。
演算命令のオペランドはレジスタに限る。
CISCはレジスタでもメモリでもオペランドとして使用できる。
複雑な命令の処理はパイプライン処理は難しく、高機能の命令はコンパイラで有効に利用できない、等の問題点から固定長の命令を高速で実行できるプロセッサの方が高性能。
ARM等のプロセッサはRISC方式の命令アーキテクチャを使用している。
Intel、AMDのx86プロセッサはCISC命令をRISCのような内部命令に変換してパイプライン実行を行っている。 </description>
    </item>
    
    <item>
      <title>wgetをプロキシ経由で利用</title>
      <link>https://chaingng.github.io/post/wget%E3%82%92%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</link>
      <pubDate>Thu, 16 Oct 2014 20:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/wget%E3%82%92%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</guid>
      <description>/etc/wgetrcに、以下の設定を追加してあげればよい。
use_proxy = on
proxy_user = user
proxy_password = passwordhttps_proxy = http://proxy.yoyodyne.com:18023/http_proxy = http://proxy.yoyodyne.com:18023/ftp_proxy = http://proxy.yoyodyne.com:18023/
ちなみに、ユーザ名とパスワードの設定はwgetrc中に書いていないが、
&#34;info wget&#34;で以下のように書いてある。
&amp;nbsp; &amp;nbsp;You may specify your username and password either through the proxy
URL or through the command-line options. &amp;nbsp;Assuming that the company&#39;s
proxy is located at &#39;proxy.company.com&#39; at port 8001, a proxy URL
location containing authorization data might look like this:
&amp;nbsp; &amp;nbsp; &amp;nbsp;http://hniksic:mypassword@proxy.company.com:8001/
&amp;nbsp; &amp;nbsp;Alternatively, you may use the &#39;proxy-user&#39; and &#39;proxy-password&#39;</description>
    </item>
    
    <item>
      <title>cygwin&#43;mintty&#43;apt-cygのインストール</title>
      <link>https://chaingng.github.io/post/cygwinminttyapt-cyg%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Wed, 15 Oct 2014 22:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/cygwinminttyapt-cyg%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>windowsでlinuxコマンド等を使うためのcygwin+minttyのインストールメモ。
Cygwinのインストールまで
Cygwinのインストールのために以下からsetup.exeをダウンロードして実行。
https://www.cygwin.com/
ダウンロードサイトは「ftp://～.jp」のサイトを指定しないとものすごくインストールが遅くなるので
注意。
必要なパッケージとして、後述するapt-cygのインストールのために以下は追加しておく。
Search欄でパッケージ名を入力してチェックすればOK。
・wget
・bzip2
・git
・gawk
・tar
Cygwin+minttyのセットアップ
インストールが終わったらc\://binの下にmintty.exeが存在するので
Cygwinの起動は今後こちらから行う。
ショートカットを作成して、右クリック＞プロパティから以下の設定を行う。
・管理者で実行するにチェック
これを行わないと、bin以下のファイルのwrite権限がないなど困ってしまう。
・ショートカットのリンク先に以下を追加
これでPATHが通ったりhomeが/usr/binではなくwindowsのhomeとなる。
-i /Cygwin-Terminal.ico -
・minttyを起動し、Option&amp;gt;TransparencyをHighにすると見やすい
・minttyを起動し、Option&amp;gt;TextからLocaleja_JP、文字コードをUTF-8に設定
apt-cygのインストール
Cygwinで追加でパッケージをインストールしたい場合には、
インストール時に使ったsetup.exeを使うことになる。
これをlinuxのyumのようにCLIでパッケージの追加を行うことができるのがapt-cyg。
以下のコマンドを実行することでインスール完了。
$ wget&amp;nbsp;https://raw.githubusercontent.com/kou1okada/apt-cyg/master/apt-cyg
$ chmod +x apt-cyg
$ mv apt-cyg /usr/bin/$ apt-cyg -X install gnupg
毎回の更新確認を不要にするために、以下のエイリアスを設定すると使いやすくなる。
$ alias apt-cyg=&#39;apt-cyg -u &#39;
ちなみに、apt-cygはwgetを利用しているので
プロキシ設定されたネットワークでの利用するときはwgetのプロキシ設定が必要なことに注意。
 </description>
    </item>
    
    <item>
      <title>androidのコードリーディング</title>
      <link>https://chaingng.github.io/post/android%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/</link>
      <pubDate>Tue, 14 Oct 2014 21:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/</guid>
      <description>業務でandroidのソースコードを読まなければならなかったときに学んだ、
効率的なソースコードの読み方のメモ。
動的な解析と静的な解析
ソースコードの解析には、動的な解析と静的な解析がある。
動的な解析とはデバッガなどでプログラムを実行させながら流れを解析する方法で、
静的な解析とは実際のソースコードを読んでいく方法。
最初は動的な解析からはじめると効率的に読むことができる。
androidではlogcatと呼ばれるログ出力関数が用意されていて、
プログラムを実行するとソースコードに埋め込まれたログが出力される。
また、開発環境ではなく実際の端末で実行されたログであれば、
以下のadbコマンドでlogcatを取得することができる。
$adb logcat -v time &amp;gt; logcat.txt
ただこのlogcatには読みたいプログラム以外にも端末で動いているものの全ての
ログが出力されるので、grepなどで必要な箇所だけ切り出してあげると見やすくなる。
まとめると
まずはプログラムを動かしてみて、出力されるlogcatからそのログが出力されている
コードの箇所を探していって、流れを組み立てるとよい。
その後、組み立てられたクラスの流れができるので、そこから静的解析として
クラスごとにソースを読んでいけば大まかに内容をつかむことができる。 </description>
    </item>
    
    <item>
      <title>androidにおけるaction／Activity／レイアウト</title>
      <link>https://chaingng.github.io/post/android%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Bactionactivity%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88/</link>
      <pubDate>Sun, 12 Oct 2014 21:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Bactionactivity%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88/</guid>
      <description>ドットインストールで学んだ、androidアプリの基礎を整理。
http://dotinstall.com/lessons/basic_android
AndroidManifest.xml
app&amp;gt;src&amp;gt;mainの下にあるファイル。
activityタグにあるaction.MAINがアプリケーションが起動したときの最初のアクションとなる。
そして、action.MAINに紐づけられたアクティビティ「MyActivity」が起動する。
&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&amp;gt;
&amp;lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
&amp;nbsp; &amp;nbsp; package=&#34;com.example.takatomo.myapp01&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;lt;application
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:allowBackup=&#34;true&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:icon=&#34;@drawable/ic_launcher&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:label=&#34;@string/app_name&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:theme=&#34;@style/AppTheme&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;activity
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:name=&#34;.MyActivity&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:label=&#34;@string/app_name&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;intent-filter&amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;action android:name=&#34;</description>
    </item>
    
    <item>
      <title>短縮URLの仕組み</title>
      <link>https://chaingng.github.io/post/%E7%9F%AD%E7%B8%AEurl%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/</link>
      <pubDate>Fri, 10 Oct 2014 22:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E7%9F%AD%E7%B8%AEurl%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/</guid>
      <description>整理用にメモ。
短縮URLでアクセスできる仕組みは、要はリダイレクトを利用しているだけ。
サンプルとして、こちらのページで短縮URLを作成してみる。
https://goo.gl/
まずhttp://www.yahoo.co.jp/を入力すると、
http://goo.gl/0wXWlPという短縮URLが作成される。
この短縮URLにアクセスすると、
つまりhttp://goo.gl/にある0wXWlPという名前のファイルにアクセスすることになる。
そして、このファイルにアクセスした場合は
http://www.yahoo.co.jp/にリダイレクトするという命令を以下のように.htaccessファイルに書いてあげればリダイレクトにより短縮URLによるアクセスが実現できる。
Redirect /0wXWP http://www.yahoo.co.jp/&amp;nbsp; </description>
    </item>
    
    <item>
      <title>地上デジタル放送を録画したメディアと再生方法</title>
      <link>https://chaingng.github.io/post/%E5%9C%B0%E4%B8%8A%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E6%94%BE%E9%80%81%E3%82%92%E9%8C%B2%E7%94%BB%E3%81%97%E3%81%9F%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E3%81%A8%E5%86%8D%E7%94%9F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 09 Oct 2014 18:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E5%9C%B0%E4%B8%8A%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E6%94%BE%E9%80%81%E3%82%92%E9%8C%B2%E7%94%BB%E3%81%97%E3%81%9F%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E3%81%A8%E5%86%8D%E7%94%9F%E6%96%B9%E6%B3%95/</guid>
      <description>DVD-VR
地上デジタル放送を家庭のDVDレコーダーで録画した時は「VRモード」となる。
これはDVD-VR(Video Recording Format)と呼ばれるDVDフォーラムが策定した
日本の家電メーカー独自のフォーマットとなる。
地上デジタル放送はコピー制御情報が付加されて放送されており、
コピー制御情報が付加された放送を録画するためには
CPRM(Content Protection for Recordable Media)に対応している必要がある。
録画するためにはCPRMに対応した録画モードが必要であり、DVDではDVD-VRモードしか
CPRMに対応していないためにこのフォーマットが使用される。
再生方法
DVD-VRモードで録画されたDVDをPCのレコーダーで視聴するには
CPRMに対応したレコーダーソフトウェアが必要だが、解除ライセンス料がかかるため
フリーソフトでは現在存在しない模様。
（win-dvdの試用期間であれば使えるかもしれないが）
ただ、CPRMがかかっていない放送であればvroファイルを直接メディアプレイヤーで
指定することで再生可能。

そうでない場合は、家庭にあるDVDレコーダーで再生が必要。 </description>
    </item>
    
    <item>
      <title>android studioのプロキシ設定</title>
      <link>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Wed, 08 Oct 2014 20:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E8%A8%AD%E5%AE%9A/</guid>
      <description>android studioのプロキシ設定のメモ。
HTTP Proxy
File&amp;gt;Setting&amp;gt;HTTP Proxyから
Manual Proxy Settingを選んで設定。
設定後、「Check Connection」ボタンで正しく設定されているか確認できる。
Gradle
Gradleを使用するとき、proxy設定が必要な場合は以下のエラーが出る。
Failed to refresh Gradle project &#39;dummy Application&#39;
Could not GET &#39;http://repo1.maven.org/maven2/com/android/tools/build/gradle/&#39;.
Received status code 407 from server:
Proxy Authentication Required ( Forefront TMG requires authorization to fulfill the request. Access to the Web Proxy filter is denied. )
Enable Gradle &#39;offline mode&#39; and sync project
この際、File&amp;gt;Setting&amp;gt;Gradleから
Global Gradle Settingsのオプションにて以下の設定が必要。
（dummyHost, dummyPort, dummyUser, dummyPasswordにそれぞれ必要な設定を入れる）
-Dhttp.proxyHost=dummyHost -Dhttp.proxyPort=dummyPort -Dhttp.proxyUser=dummyUser -Dhttp.proxyPassword=dummyPassword </description>
    </item>
    
    <item>
      <title>GigabitEthernet規格の簡単なまとめ</title>
      <link>https://chaingng.github.io/post/gigabitethernet%E8%A6%8F%E6%A0%BC%E3%81%AE%E7%B0%A1%E5%8D%98%E3%81%AA%E3%81%BE%E3%81%A8%E3%82%81/</link>
      <pubDate>Tue, 07 Oct 2014 21:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/gigabitethernet%E8%A6%8F%E6%A0%BC%E3%81%AE%E7%B0%A1%E5%8D%98%E3%81%AA%E3%81%BE%E3%81%A8%E3%82%81/</guid>
      <description>GigabitEthernet規格の簡単なまとめ。
GigabitEthernet系の規格
GigabitEthernet系の規格はIEEE802.3abとIEEE802.3zの２つがある。
IEEE802.3ab
IEEE802.3abはUTPケーブルに関するもので、
1000BASE-Tと1000BASE-TXがある。
1000BASE-Tは4対8線のケーブルのうち各対250Mbps×4=1Gbpsを実現する。
ハイブリッド回路によるエコーキャンセル処理を行うことで、１つの対で送受信の全二重通信を実現。
1000BASE-TXは4対8線のケーブルのうち2対を送信用、2対を受信用に利用。
各対500Mbps×2=1Gbpsを実現。
IEEE802.3z
IEEE802.3zは光ファイバーケーブルに関するもので、
1000BASE-SX、1000BASE-LX、1000BASE-CXがある。
1000BASE-SXはマルチモード光ファイバーを使用するので
波長850nm、最大伝送距離は550mとなる。
1000BASE-LXはマルチモード光ファイバーに加えてシングルモード光ファイバーも使用可能。
シングルモード光ファイバーの場合、波長1300nm、最大伝送距離は5kmとなる。

1000BASE-CXは同軸ケーブル（STP）を使用する。
 </description>
    </item>
    
    <item>
      <title>android studioのインストール</title>
      <link>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Mon, 06 Oct 2014 19:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>android studioのインストールメモ。
まずはここから本体をダウンロード。
https://developer.android.com/sdk/installing/studio.html
後はこちらのページの内容に沿ってインストール。
https://developer.android.com/sdk/installing/index.html?pkg=studio
まずはandroid studioの起動にあたってはJDKとJAVA_HOMEのPATH設定が必要なのであらかじめ済ませておく。
インストール後、必要なsdkをインストールする。
Configure＞sdk managerと移動すればインストール可能。
このとき、管理者権限でandroid studioを起動していなければsdkのインストール時に
「Nothing was installed」とエラーが出てしまう。
そのときはandroid studioのアイコンを右クリック＞プロパティから
管理者権限で実行するをチェックする。
これで次回からは常に管理者権限で実行され、sdkのインストール時にもエラーは出なくなる。
必要なsdkパッケージは以下の通り。
＜メインパッケージ＞
・sdk tools
・sdk platform tools
・sdk build tools
＜androidのバージョンごと＞
・sdk platform
・intel系のsystem image（インテルのエミュレータを用いる場合）
＜extra＞
・android support repository
・android support library
・google usb driver
・intel x86 emulator（インテルのエミュレータを用いる場合） </description>
    </item>
    
    <item>
      <title>yumをローカルで使う場合のレポジトリ設定</title>
      <link>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88%E3%81%AE%E3%83%AC%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Sun, 05 Oct 2014 22:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88%E3%81%AE%E3%83%AC%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E8%A8%AD%E5%AE%9A/</guid>
      <description>最初にCDをマウントして、ローカルにデータをコピー。
mkdir -p /mnt/cdrom
mount /dev/cdrom /mnt/cdrom
mkdir /opt/redhat
cp -rp /mnt/cdrom/* /opt/redhat/
umount /mnt/cdrom
次に、必要なrpmパッケージをインストール。
rpm -ivh /opt/redhat/Packages/*.rpm
レポジトリを作成するディレクトリを指定。
createrepo /opt/redhat/
yum clean all
最後に、適当な名前（ここではfile.repo）でレポジトリを作成すれば完了。
vi /etc/yum.repos.d/file.repo
[rhel-redhat]
name = Red Hat Enterprise Linux $releasever - $basearch
baseurl=file:///opt/redhat
enabled=1
gpgcheck=0 </description>
    </item>
    
    <item>
      <title>JDKのインストール</title>
      <link>https://chaingng.github.io/post/jdk%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Sat, 04 Oct 2014 20:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/jdk%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>こちらのページから対応するOSのJDKをインストール。
http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html
あとは、JAVAHOMEのパスを設定するだけ。
 </description>
    </item>
    
    <item>
      <title>gitのインストール</title>
      <link>https://chaingng.github.io/post/git%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Fri, 03 Oct 2014 21:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/git%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>gitのインストールメモ。
GIT EXTENTIONがCUIもGUIも同時にインストールできるのでスグレモノ。
以下のURLのDownloadからmsiをダウンロード。
https://code.google.com/p/gitextensions/
・同梱ツールはMsysGITとKdiff3の両方ともインストール。
・Kdiff3は「GIT bash here」「GIT gui here」の両方を選択。
これでCUIライクな操作もGUI操作も可能になる。
・PATH環境変数は「Run Git from the Windows Command Prompt」を選択。
これでコマンドプロンプトからも操作可能になる。
・改行コードは「Checkout Windows-style, commit Unix-style endings」を選択。
これで通常はwindowsの改行コードに沿って、コミット時のみunixスタイルに変換してくれる。
・インストール後、デスクトップを右クリックしてGit Extentions&amp;gt;Settingsを選択。
グローバル設定を選択し、ユーザ名とメールアドレスを登録。
・lsの文字化けを防ぐにはデスクトップを右クリックして「GIT bash here」を選択し、
ホームディレクトリから「.bashrc」という名前のファイルを作成、以下のエイリアスを追加する。
alias ls=&#39;ls --show-control-chars&#39;
alias dir=&#39;ls --show-control-chars&#39;
・合わせてホームディレクトリから以下のコマンドを設定すれば完了。
git config --global core.quotepath off </description>
    </item>
    
    <item>
      <title>yumをローカルで使用する場合のエイリアス</title>
      <link>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AE%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9/</link>
      <pubDate>Thu, 02 Oct 2014 18:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AE%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9/</guid>
      <description>yumをインターネット経由ではなくローカルで使用したい場合のエイリアス設定。
/etc/bashrcもしくは~/.bashrcについて、以下を設定してあげればよい。
(rhel-redhatはrepoの名前)
alias yum=&#39;yum --disablerepo=\* --enablerepo=rhel-redhat&#39;
 </description>
    </item>
    
    <item>
      <title>adbをWi-Fi経由で利用</title>
      <link>https://chaingng.github.io/post/adb%E3%82%92wi-fi%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</link>
      <pubDate>Wed, 01 Oct 2014 19:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/adb%E3%82%92wi-fi%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</guid>
      <description>端末が増えてくるとそれぞれusb接続してadbコマンドを打つと大変になった。
そこで、usbに接続しなくとも無線LAN経由にてadbを利用する方法があったので整理しておく。
１．下準備として、端末にusb接続してtcpポートを解放。
$adb tcpip 5555
２．usbを外して、adb connectにて端末のIPアドレス(ここでは仮に10.10.10.10)にアクセス。
このとき、操作元の端末と操作したい端末は同じWi-Fiネットワーク下にあること。
$adb kill-server
$adb connect 10.10.10.10:5555
これだけで無線LAN経由でadbコマンドを打つことが可能になる。
ちなみに、公式ページを下の方にも解説がある。
http://developer.android.com/tools/help/adb.html </description>
    </item>
    
    <item>
      <title>LinuxでCPUやメモリ使用状況のログを取る方法</title>
      <link>https://chaingng.github.io/post/linux%E3%81%A7cpu%E3%82%84%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%B3%81%E3%81%AE%E3%83%AD%E3%82%B0%E3%82%92%E5%8F%96%E3%82%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 12 Mar 2014 19:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%A7cpu%E3%82%84%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%B3%81%E3%81%AE%E3%83%AD%E3%82%B0%E3%82%92%E5%8F%96%E3%82%8B%E6%96%B9%E6%B3%95/</guid>
      <description>Linux(使っているのはRedhat Enterprise Linux 6.3)でCPU負荷とメモリ使用状況のログを取る必要があったので使い方をメモ。
①CPU使用率とメモリ使用状況の表示
vmstatを使うことでCPU・メモリ使用率のログが取ることができる。
5秒間隔で３回ログを取りたいときは、以下のように引数を指定する。
$vmstat 5 3
②時刻情報の表示
使用率の分析にはいつ出力されたかが知りたいと思うので、時刻と紐づけたいことが多いと思う。これはpipとawkを使うことで実現する。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 }&#39;
awkで時刻情報を出力させた後、現在の行(vmstat)を出力させている。
これで１秒間隔で、年／月／日　hh:mm:sssの時刻情報と紐づけて出力することができる。
③ログへの出力
実は上記のコマンドの標準出力をログに出そうとしても出力されない。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 }&#39;　&amp;gt;&amp;gt; sample.log
これは、pipの後ろの処理が終了してからバッファに保存してある情報をファイルに書き込みむため。
そのため、system()関数を用いてバッファをリフレッシュする。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 } {system(&#34;&#34;)}&#39;　&amp;gt;&amp;gt; sample.log
こちらに詳細な解説が。
http://www.kt.rim.or.jp/~kbk/gawk-30/gawk_13.html
これでやっと、途中でコマンドを終了させてもログに書き込まれているようになる。
 </description>
    </item>
    
    <item>
      <title>ブートローダー</title>
      <link>https://chaingng.github.io/post/%E3%83%96%E3%83%BC%E3%83%88%E3%83%AD%E3%83%BC%E3%83%80%E3%83%BC/</link>
      <pubDate>Sun, 09 Feb 2014 18:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%83%96%E3%83%BC%E3%83%88%E3%83%AD%E3%83%BC%E3%83%80%E3%83%BC/</guid>
      <description>最近Androidのrootを取るのにbootloaderのアンロックを行ったのでメモ。
BootLoaderとは
起動直後のコンピュータはハードディスクからＯＳを読み込むことができない。
そのため、ＯＳを起動させるためにＢＩＯＳが読み込む小さなプログラムがブートローダーになる。
ただ、ブートローダーは通常はハードディスク等の先頭部分に５１２バイト分しか存在しないため、ＯＳを呼び出すことができない。
そこで、ブートローダーは各パーティションの先頭にあるブートマネージャー（２次ブートローダー）を起動させる。
ブートマネージャーは設定された内容に従って、指定されたパーティションにあるＯＳを起動する。
ここでブートマネージャーの設定ファイルに複数のＯＳ情報を記載することによって、
複数のＯＳの起動を選択することができる。
Bootloaderのアンロック
ブートローダーにはシステムのアップデート機能もあり、特定の場所にイメージを置いておくとアップデートすることができる。
ただし、電子署名された特定のイメージしかアップデートできないようにメーカーが設定している場合もある。
このとき独自のイメージを焼きたいときに、ブートローダーのアンロックが必要になる。
リカバリーにBootloaderのアンロックが必要
Androidにはboot,system,recoveryの３つのパーティションがある。
通常はsystemが起動するが、アップデートの際は起動できないのでrecoveryを起動してアップデートする必要がある。また、boot領域はシステムが壊れても最低限の起動をするのに必要なもの。
Bootloaderのアンロックをすることで、recovery領域のアップデート（カスタムリカバリー）も可能になる。

 </description>
    </item>
    
    <item>
      <title>BeautifulSoupの第一歩</title>
      <link>https://chaingng.github.io/post/beautifulsoup%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AD%A9/</link>
      <pubDate>Fri, 31 Jan 2014 23:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/beautifulsoup%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AD%A9/</guid>
      <description>クローラーで取ってきたHTMLを解析するのにBeautifulSoupが使いやすそうだったので使ってみました。以下は簡単な使い方のメモ。
バージョン
BeautifulSoupは３と４がありますが
現在はBeautiful Soup３は終了していてBeautiful Soup４が主流とのこと。
Webをみていると３の使い方が多いので注意。
そしてPython3はBS3が使えないです。
インポート
まずはインポート。
BeautifulSoup4は以下の書き方になります。
from bs4 import BeautifulSoup
まずは全文抽出
まずは、以下のように書くことでhtmlの全文が保存されます。
datas = BeautifulSoup(datas)

findで指定のタグを抽出
次にfind文で指定のタグを抽出できます。
今回はfindAll文を使うことで、html中の指定のタグを抽出しました。
以下ではdivタグのresult classを抽出。
datas2 = datas.findAll(&#34;div&#34;, attrs={&#34;class&#34;: &#34;result&#34;})

さらに下層の情報取得とテキスト抽出
ここで抽出された情報は配列となっているので、
さらにそこから抽出したい情報があれば配列番号でアクセス。
result_name=datas2[1].find(&#34;h5&#34;).get_text().replace(&#39; &#39;,&#39;&#39;)
score=datas2[2].find(&#34;h5&#34;).get_text()
ここでは1番目と2番目にあるh5タグを抽出しています。
これまでだとタグと本文を含めてまとめて抽出されるので、
本文だけを取りだしたい場合はget_text()を利用。
また、タグ内の属性情報を取り出したいときはget(&#39;href&#39;)など指定することで可能です。
タグ名を取りだしたいときは .nameで取れます。
 </description>
    </item>
    
    <item>
      <title>Linuxのクロック</title>
      <link>https://chaingng.github.io/post/linux%E3%81%AE%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF/</link>
      <pubDate>Sun, 26 Jan 2014 19:37:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%AE%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF/</guid>
      <description>ハードウェアクロックとシステムクロック
Linuxには「ハードウェアクロック」と「システムクロックの」２つが存在します。
「システムクロック」がＯＳで使われている通常の時計であり、ＰＣを立ち上がっているときのみ有効です。メモリ上で管理するためＰＣをシャットダウンすると消えてしまいます。
上記のシステムクロックの仕組みですと、ＰＣを起動するたびに毎回時刻を設定しなければいけません。
初期のＰＣは毎回時刻を設定していました。
ただ現在では、電源が落ちていても内部バッテリーで動くハードウェアクロックが存在します。
ＰＣを立ち上げると、ハードウェアクロックを１度だけ参照してシステムクロックが設定される仕組みになっています。
コマンドでの時刻合わせ
ハードウェアクロックは内部バッテリーで動いているためバッテリーがなくなれば止まってしまい、また時刻のズレも発生してしまいます。時刻合わせにはＮＴＰの設定など色々と方法はありますが、以前手動で設定する必要があったためその方法をメモしておきます。

手動での設定時の注意ですが、
システムクロックはハードウェアクロックを参照して設定されるため、システムクロックだけ直しても再起動すると無効になってしまいます。
そのため、ハードウェアクロックの書き換えが必要になります。

最初に、システムクロックを変更# date --set=&#34;2014/1/26 19:32&#34;
次に、システムクロックをハードウェアクロックに書き込み
# clock -w
これで、ＰＣを再起動しても変更後の時刻が有効になります。
 </description>
    </item>
    
    <item>
      <title>Pythonでモジュールインポート時の注意</title>
      <link>https://chaingng.github.io/post/python%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E6%99%82%E3%81%AE%E6%B3%A8%E6%84%8F/</link>
      <pubDate>Sun, 26 Jan 2014 16:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/python%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E6%99%82%E3%81%AE%E6%B3%A8%E6%84%8F/</guid>
      <description>クローラーを作るのにPythonが使いやすかったので利用したのですが、
そのときにimportでひっかかってしまったのでメモ。
importの書き方
importには２通りの書き方があります。
１つ目は、importにパッケージ名.モジュール名と書く方法。
import urllib.request
こちらの場合はモジュールを使うのにフルパスを書かなければいけないです。
html = urllib.request.urlopen(x)
２つ目は、from　パッケージ名　import モジュール名と書く方法。
from bs4 import BeautifulSoup
こちらはモジュール名だけ書くだけで使用できるので、こちらの方がすっきりします。
datas2 = BeautifulSoup(datas).findAll(&#34;td&#34;, attrs={&#34;class&#34;: &#34;tdSearchResultListKanji&#34;})
import時の注意点
モジュールを利用するには、その上階層にある全てのパッケージ、サブパッケージ名を指定しなければいけないということ。
＃エラー
import urllib
＃正しい
import urllib.request
Ｃに慣れていたので、この書き方にひっかかってしまいました。
どうやら、サブパッケージを設けることでお互いがお互いの使用モジュールについて気にしなくてもよいからこの書き方をしているとのことです。
http://docs.python.jp/2.5/tut/node8.html
 </description>
    </item>
    
  </channel>
</rss>