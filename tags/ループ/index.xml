<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ループ on takatomo&#39;s blog</title>
    <link>https://chaingng.github.io/tags/%E3%83%AB%E3%83%BC%E3%83%97/</link>
    <description>Recent content in ループ on takatomo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 12 Apr 2015 11:59:00 +0000</lastBuildDate>
    
	<atom:link href="https://chaingng.github.io/tags/%E3%83%AB%E3%83%BC%E3%83%97/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SRM 652 DIV1 Easy - ThePermutationGame </title>
      <link>https://chaingng.github.io/post/srm-652-div1-easy---thepermutationgame/</link>
      <pubDate>Sun, 12 Apr 2015 11:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-652-div1-easy---thepermutationgame/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13229&amp;amp;rd=16316
・１～Nの数それぞれからなる、数字の列が与えられる。
（例）N=2、｛１，２｝　N=3、｛１，２，３｝
・この数はランダムの回数シャッフルされる。
・また、関数ｆが与えられる。
・シャッフルされたあとの数列をpとすると、 f(1)=p[1]、f(m)=p[f(m-1)]となる。
このとき、どのようにシャッフルされてもf(x)=1となるような最小のｘを求める。
解き方 
SRM441と似ている。周期をまず求める。
シャッフルされた数列の最初の数を考えると、
この数は１～Nの場合が考えられ、それぞれ１～N回の周期でf(x)が１となる。
つまり、１～Nの全ての周期で割り切れる1～Nの最小公倍数が答えになる。
最小公倍数を求めるとき、途中でMODで剰余をとってしまうと最小公倍数が計算できないので
工夫が必要。
ある数列の最小公倍数を求めるとき、存在する素数それぞれについて、
N以下でその素数が存在する最大数をかけていけば答えを求めることができる。
コード 
int MOD=1000000007;
class ThePermutationGame {
public:
int findMin(int N) {
int ret=1;
for(int i=2;i&amp;lt;=N;i++){
bool prime=true;
for(int j=2;j*j&amp;lt;=i;j++){
if(i%j==0){
prime=false;
break;
}
}
if(prime){
int add=i;
while(add&amp;lt;=N/i)add*=i;
ret=(ret*1LL*add)%MOD;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 616 DIV1 Easy - WakingUp (○)</title>
      <link>https://chaingng.github.io/post/srm-616-div1-easy---wakingup-/</link>
      <pubDate>Thu, 13 Nov 2014 19:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-616-div1-easy---wakingup-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13124&amp;amp;rd=15849
・Alexは深く眠っており、どれだけ眠りが深いかはわかっていない。
・ただし、1秒ごとにDずつ眠りが深くなっていく。
・目覚まし時計が複数あり、最初にどの時刻でなり、１回鳴るごとにへる眠りの深さの値と、何秒周期で鳴るかの情報がわかっている。
・このとき、Alexがいつか起きるときの最大の眠りの深さの値を求める。
・ただし、どれだけ眠りが深くてもいつかは目覚めるときは-1を返す。
解き方 
・目覚まし時計の数は最大50、間隔は最大10なので全探索で解けそう。
・各時間において増減する眠さの値を記憶しておけば、いつが最小化がわかり、つまり眠りの最大の深さがわかる。
・ただし、これだけではいつか目覚めるかどうかはわからない。
・なので周期を見つけ、次の周期に必ず値が小さくなるなら-1、そうでなければ答えがあることがわかる。
・周期としては各periodの最小公倍数＋最初に鳴る最大の時刻をとればよさそう。
→System Passed
・周期は最小公倍数を計算したが、単に1*2*3...*10=2520と固定してもよさそうだった。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class WakingUp {
public:
int gcd(int x,int y){
return y ? gcd(y,x%y) : x;</description>
    </item>
    
    <item>
      <title>SRM 172 DIV1 Easy - BadClock （復習○）</title>
      <link>https://chaingng.github.io/post/srm-172-div1-easy---badclock-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 08:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-172-div1-easy---badclock-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1969&amp;amp;rd=4665
正確な時計と、１時間あたり必ずｘ分ズレる時計がある。
各時計は１～１２時までの表示になる。
正確な時計とズレる時計の現在時刻が与えられた時、
時計の時刻が一緒になるまでに必要な時間を求める。
解き方 
現在時刻のズレＤとｘ分のずれの正負が異なれば答えはＤ／ｘになる。
一方で、正負が一緒であれば一周する必要があるので、（４３２００－Ｄ）／ｘとなる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BadClock {
public:
int calc(string str){
int h=(str[0]-&#39;0&#39;)*10+(str[1]-&#39;0&#39;);
int m=(str[3]-&#39;0&#39;)*10+(str[4]-&#39;0&#39;);
int s=(str[6]-&#39;0&#39;)*10+(str[7]-&#39;0&#39;);
return h*3600+m*60+s;
}
double nextAgreement(string trueTime, string skewTime, int hourlyGain) {</description>
    </item>
    
    <item>
      <title>SRM 181 DIV1 Easy - CombinationLock (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-181-div1-easy---combinationlock-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 20:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-181-div1-easy---combinationlock-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1945&amp;amp;rd=4725
数字を合わせてロックを空ける回転式の鍵がある。
合わせるのに必要な数字の一覧が順に与えられ、数字の数も与えられる。
ロックを解除する操作は以下の通り。
１．回す方向を決める
２．合わせるのに必要な一覧の、残りの数だけ１回転させる
３．現在合わせる数字まで回転させる
４．次の回転は逆回り
最初にセットしてある数字が与えられるとき、ロックの解除までに必要な回転角度を求める。
解き方 
問題文の理解に時間がかかったが、サンプルを例に試してみることで理解できた。
問題文の理解ができれば、あとはシミュレーション問題なので実装するだけ。
時計回りと反時計回りのときに数字を合わせるまでに動かす数だけ正確に実装できればあとは簡単。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CombinationLock {
public: double degreesTurned(vector&amp;lt;int&amp;gt; combo, int size, int start) {
double ret=0.0;
int n=combo.size();</description>
    </item>
    
    <item>
      <title>SRM 247 DIV1 Easy - Musical (復習○)</title>
      <link>https://chaingng.github.io/post/srm-247-div1-easy---musical-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 22:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-247-div1-easy---musical-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4495&amp;amp;rd=7222
椅子取りゲームを行う。
プレイヤーはｎ人、椅子はn-1個で等間隔でサークル上に置かれる。
プレイヤーはＡが椅子の横、Ｂがその次に続き、Ｃがその次に・・・とサークル上に等間隔で位置している。
プレイヤーは椅子のサークルをtime秒だけ周回し、止まったときにある椅子に最も近いプレイヤーがその椅子に座る。
ただし、10秒でちょうど一周することになる。
このとき、負けるプレイヤーが誰になるかを求める。
解き方 
問題条件をいかにシミュレーションできるか、簡単にコーディングできるかになる。
まず、１周の長さを１とすると、各プレイヤーは周る方向とは逆の順にＢ，Ｃ、と並ぶ。
各プレイヤーの間隔は1/n、各椅子は同様にして、1/(n-1)離れている。
最後に、最も椅子から離れているプレイヤーが負けるプレイヤーになる。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Musical {
public: string loser(int n, double time) {
time=fmod(time,10.0)/10.0;
vector&amp;lt;double&amp;gt; x,c;
FORE(i,0,n)x.push_back(fmod((double)i/n+1.0-time,1.0));
FORE(i,0,n-1)c.push_back((double)i/(n-1));
double worst=0.0;
int ret=-1;
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 441 DIV1 Easy - PerfectPermutation (復習○)</title>
      <link>https://chaingng.github.io/post/srm-441-div1-easy---perfectpermutation-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 14:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-441-div1-easy---perfectpermutation-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10463&amp;amp;rd=13749
ある０～n-1の数がランダムに並べられた、長さｎの配列が与えられる。
このとき、childpermutation Bは、
B[0]=0, B[i]=B[A[B[i-1]]で現した時
もとの配列と同様に0~n-1の数が存在するものと定義する。
最初に与えられた数列がchildpermutationを含む時は０を、
配列の数字の入れ替えが発生する場合は元の数列と異なる要素数のうち
最小の差のものを求める。
解き方 
すべてpermutationしていては要素数が５０のため間に合わない。
ここで、全ての数が現れる場合というのはＢがループしている場合ということがわかる。
ループが１つの場合はそのまま答えになるが、
ループが複数存在する場合はお互いの数字を入れ替えることで一つのループにすることができる。
よって、ループの数を計算し１つであれば０、複数存在するのであればループ数を返す。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PerfectPermutation {
public: int reorder(vector&amp;lt;int&amp;gt; P) {
int n=P.size();
int ans=0;
int used[n];
memset(used,0,sizeof(used));
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 572 DIV1 Easy - NewArenaPassword （復習○）</title>
      <link>https://chaingng.github.io/post/srm-572-div1-easy---newarenapassword-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 20 Aug 2013 08:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-572-div1-easy---newarenapassword-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12386&amp;amp;rd=15492
古いパスワードから新しいパスワードを作りたいが、できるだけ変更したくない。
また、パスワードの最初のＫ文字と最後のＫ文字は一致していないといけない。
古いパスワードが与えられた時、最小の変更文字数を求める。
解き方 
正確にシミュレーションしてあげれば解ける問題。
i文字目について、Ｎ-K文字を足した場所とリンクしていることがわかると、
最初からN-Kずつ足していった値に対して、最小のリンク関数を求めてあげればよい。
また、最初からＫもしくはＮ－Ｋまでの操作でよいことがわかる。
コード 
class NewArenaPassword {
public: int minChange(string oldPassword, int K) {
int cost=0,n=oldPassword.size();
for(int i=0;i&amp;lt;n&amp;amp;&amp;amp;i&amp;lt;n-K;i++){
int count[26]={},num=0;
for(int j=i;j&amp;lt;n;j+=n-K){
count[oldPassword[j]-&#39;a&#39;]++;
num++;
}
cost+=num-*max_element(count,count+26);
}
return cost;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 583 DIV1 Easy - TravelOnMars （復習x）</title>
      <link>https://chaingng.github.io/post/srm-583-div1-easy---travelonmars-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sun, 18 Aug 2013 08:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-583-div1-easy---travelonmars-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
都市が円状につながっている。
各都市には、そこから１ターンでいける都市数が保存されている。
始点と終点が与えられた時、移動するための最小ターン数を求める。
解き方 
グラフの最短距離を求める問題なので、ワーシャルフロイド法が使えないか考える。
グラフを作成し、隣り合う都市は１、そこから１ターンで行ける都市は１とし、
最後にワーシャルフロイドを走らせる。
Challenge
一方向だけではなく、順と逆を組み合わせてもよいことに注意。
コード 
class TravelOnMars {
public: int minTimes(vector&amp;lt;int&amp;gt; range, int startCity, int endCity) {
int n=range.size(),INF=100000000;
int dp[n][n];
FORE(i,0,n)FORE(j,0,n)dp[i][j]=INF;
FORE(i,0,n){
FORE(j,0,n){
int l=(i-j+n)%n;
int r=(j-i+n)%n;
if(min(l,r)&amp;lt;=range[i])dp[i][j]=1;
}
}
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
return dp[startCity][endCity];
}
}; </description>
    </item>
    
    <item>
      <title>SRM566 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm566-div2--level2/</link>
      <pubDate>Sat, 29 Jun 2013 12:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm566-div2--level2/</guid>
      <description>＜問題＞
①青が好きなペンギンと、赤が好きなペンギンが輪になって並ぶ。
②同じ色が好きなペンギン同士は線を結んでペアを作る。
③ただし、線は交差してはいけない。
④それぞれ好きな色を持つペンギンの集合が与えられた時、
ペアの最大数を返す。
＜解き方＞
隣同士のペンギンで線を結んでも交差に影響することはないので、
まずは隣同士で同じ色のペアを作って集合から削除していく。
このとき、輪になっていることから最初と最後の判定を先に行い、
その後「赤・赤」「青・青」のペアとなっているところを判定していく。
そのあとは赤と青が交互になった順列ができるので、
残りのペア数は残った集合の半分－１となる。
＜関数＞
stringに対しての処理なので、うまくsubstrとeraseを使ってあげることで
集合から削除すれば処理が簡単になる。
＜コード＞
class PenguinPals {
public:
int findMaximumMatching(string colors) {
int ans=0,flag=1;
while(flag){
flag=0;
if(colors.size()&amp;lt;2)break;
if(colors[0]==colors[colors.size()-1]){
ans++;
colors=colors.substr(1,colors.size()-2);
flag=1;
}
else if(colors.find(&#34;RR&#34;)!=-1){
ans++;
colors.erase(colors.find(&#34;RR&#34;),2);
flag=1;
}
else if(colors.find(&#34;BB&#34;)!=-1){
ans++;
colors.erase(colors.find(&#34;BB&#34;),2);
flag=1;
}
}
if(colors.size()&amp;gt;2)ans+=(colors.size()/2-1);
return ans;
}
}; </description>
    </item>
    
  </channel>
</rss>