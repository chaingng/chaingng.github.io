<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>シミュレーション on takatomo&#39;s blog</title>
    <link>https://chaingng.github.io/tags/%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/</link>
    <description>Recent content in シミュレーション on takatomo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 09 Feb 2014 17:52:00 +0000</lastBuildDate>
    
	<atom:link href="https://chaingng.github.io/tags/%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SRM 182 DIV1 Easy - SlayingDeer （復習○）</title>
      <link>https://chaingng.github.io/post/srm-182-div1-easy---slayingdeer-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 17:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-182-div1-easy---slayingdeer-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2308&amp;amp;rd=4730
鹿を追いかけて捕まえたい。
プレイヤーは速度Ａ，鹿は速度Ｂ，距離はＣで与えられる。
ただし、鹿は３０分走ったあと１５分休憩する。
このとき、何分後に鹿を捕まえられるかを求める。
ただし、決して捕まえられない場合はー１を返す。
解き方 
シミュレーションで間に合わない場合はお互い走って休んでを１周とすると
何周目に捕まえられるかの計算が必要になるが、
時間Ｃの最大が10^5なので単純なシミュレーションで間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SlayingDeer {
public: int getTime(int A, int B, int C) {
int rest=C,ret=0;
while(1){
if((A-B)*30&amp;lt;rest){
ret+=30;
rest-=(A-B)*30;
}</description>
    </item>
    
    <item>
      <title>SRM 310 DIV1 Easy - PyramidOfCubes (復習○)</title>
      <link>https://chaingng.github.io/post/srm-310-div1-easy---pyramidofcubes-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 18:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-310-div1-easy---pyramidofcubes-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6577&amp;amp;rd=9990
・１＊１のキューブが任意の数与えられる。
・キューブを３＊３、２＊２、１＊１のようにピラミッド状に積み重ねていく。
下より作っていき、足りなければそこで積み重ねを終える。
このとき、積み重ねたキューブの表面積を求める。
解き方 
シミュレーション問題なので、いかに簡単にコーディングするかがポイント。
表面積の計算は、以下が独立であることが分かる。
①上下部分
②左右部分の手前奥部分
③左右部分の横部分
①については、一番下のキューブの数によって計算可能。
②については、残りのキューブの数とそのときの１辺の長さにて計算可能。
③については、さらに残ったキューブの数により計算可能。
最後にコーディングの順番を整理する。
まずはキューブの数と最大となる１辺の長さから①を計算。
次に②、③について計算。
土台を作ることができれば②，③は現在の１辺の長さ＊４。
作ることができなければ、
②は残りのキューブの数と現在の１辺の長さの小さい方。
③は１辺の長さを作ることができる数＋余り分となる。
コード 
class PyramidOfCubes {
public: double surface(int K) {
double ret=0.0;
int maxlen;
long long tmp=0LL;
for(int i=1;;i++){
tmp+=i*i;
if(tmp&amp;gt;=K){
maxlen=i;
break;
}
}
if(K&amp;gt;=maxlen*maxlen)ret+=maxlen*maxlen*2;
else ret+=K*2;
for(int len=maxlen;len&amp;gt;=1;len--){
if(K&amp;lt;=0)break;
if(K&amp;gt;=len*len){
ret+=len*4;
K-=len*len;
continue;
}
if(K&amp;gt;=len)ret+=len*2;
else ret+=K*2;
while(K&amp;gt;0){
ret+=2;
K-=len;
}
}
return ret;</description>
    </item>
    
    <item>
      <title>SRM 532 DIV1 Easy - DengklekMakingChains (復習××)</title>
      <link>https://chaingng.github.io/post/srm-532-div1-easy---dengklekmakingchains-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 17:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-532-div1-easy---dengklekmakingchains-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11754&amp;amp;rd=14725
長さ３からなる鎖がある。
鎖はビーズか数字のパーツからなる。
複数の鎖が与えられ、鎖をつなげたときに連続した数字が美しさの値になる。
このとき、最大となる美しさの値を求める。
解き方 
シミュレーションの問題なので、いかにＣｈａｌｌｅｎｇｅケースを網羅するか、間違いのないように実装するか。
１）真ん中のみに数字がある場合は、その最大値と連結した鎖と比較する必要がある
２）左と右にある鎖について、左とも右とも取れるものを考慮する。
さらに２つではなく１つだけの場合もあるため、その場合も考慮する。
文字列１つ１つでif文を書いてもよいが、for文をうまく使うことで間違いが少なく簡略化することができる。
コード 
class DengklekMakingChains {
public:
int maxBeauty(vector&amp;lt;string&amp;gt; c) {
int n=c.size();
int ans=0,single=0,a[60]={},b[60]={},added=0;
FORE(i,0,n){
if(c[i][0]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][1]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][2]!=&#39;.&#39;)FORE(j,0,3)ans+=c[i][j]-&#39;0&#39;;
else {
if(c[i][0]==&#39;.&#39;&amp;amp;&amp;amp;c[i][1]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][2]==&#39;.&#39;)single=max(single,c[i][1]-&#39;0&#39;);
for(int j=0;j&amp;lt;3&amp;amp;&amp;amp;c[i][j]!=&#39;.&#39;;j++)a[i]+=c[i][j]-&#39;0&#39;;
for(int j=2;j&amp;gt;=0&amp;amp;&amp;amp;c[i][j]!=&#39;.&#39;;j--)b[i]+=c[i][j]-&#39;0&#39;;
}
}
FORE(i,0,n){
added=max(added,max(a[i],b[i]));
FORE(j,0,n)if(i!=j)added=max(added,a[i]+b[j]);
}
ans+=added;
return single&amp;gt;ans ? single : ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 577 DIV1 -Level1</title>
      <link>https://chaingng.github.io/post/srm-577-div1--level1/</link>
      <pubDate>Sun, 18 Aug 2013 17:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-577-div1--level1/</guid>
      <description>問題 
プログラミングコンテストを実施するにあたり、プレイヤーを部屋に割り当てる。
部屋は２０人単位。プレイヤーはレートをもっている。
部屋の割り当てはレートの高い順に最初の部屋数分を、ランダムにそれぞれの部屋に割り当てる。部屋数で割り切れない場合は、部屋にいる人数は必ずしも一緒にならない。
配列の最初のプレイヤーが自分であるとき、
自分が割り当てられた部屋の平均レートを求める。
解き方 
シミュレーション問題であるが、自分のレートによって色々な場合が存在するので全て洗い出す。また、コーディングをいかに単純にするかもポイント。
コーディングを単純にするには、
まずは計算しやすい各割り当てグループごとにメンバーの平均値を求める。
そのグループに自分が入っている場合は、自分の値＝平均値となる。
最後のグループも同じように計算する。
次にとりうる全てのケースを考える。
１）メンバーが部屋の数で割り切れるとき
すべてのメンバーの平均値／部屋のメンバー数が答え。
２）メンバーが部屋の数で割り切れないとき
２－１）自分が最後の割り当てメンバーのとき
メンバー数が全メンバー／部屋数に１を足したものになるので、
全てのメンバーの平均値／上記のメンバー数が答え。
２－２）自分が最後の割り当てメンバーではないとき
自分がメンバーの多い部屋になるときとならないときの確率を求めて
その２つの和が答えとなる。
Challenge
int／intはint型の結果が代入される。
一方でdouble/int もしくはint/doubleはdoubleに変換されて計算される。
いずれにしても計算の場合は型を一致させてから行うのが基本。
コード 
class EllysRoomAssignmentsDiv1 {
public: double getAverage(vector&amp;lt;string&amp;gt; ratings) {
string tmp=&#34;&#34;;
vector&amp;lt;int&amp;gt; v;
vector&amp;lt;double&amp;gt; ave;
ave.clear(),v.clear();
FORE(i,0,ratings.size())tmp+=ratings[i];
stringstream str(tmp);
while(1){
int out=-1;
str&amp;gt;&amp;gt;out;
if(out==-1)break;
v.push_back(out);
}
int N=v.size();
int R=(N+19)/20;
int myrate=v[0],my=0;
int member=N/R;
sort(v.rbegin(),v.rend());
FORE(i,0,v.size())if(v[i]==myrate)my=i;
for(int i=0;i&amp;lt;N;i+=R){
int j=min(i+R,N);</description>
    </item>
    
    <item>
      <title>SRM 557 DIV1 Easy - MergersDivOne (復習×)</title>
      <link>https://chaingng.github.io/post/srm-557-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 10:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-557-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12195
山登りをし、スタートの高さとゴールの高さ、ステップ数が与えられる。
１ステップごとに、１段上がるか下がるかすることができる。
また、登山の部分列が与えられる。
このとき、登山にその部分列が存在するときは”ＹＥＳ”、存在しないときは”ＮＯ”を返す。
解き方 
まずはその部分列の操作をしたとき、ゴールにたどり着けるかを判定。
残りのステップ数がゴールへの距離も多い時はＮＯ。
残りのステップ数を２で割ったときの余りと、ゴールへの距離を２で割ったときの余りが一致しない場合もＮＯ．
次に、その部分列の操作をしたときに高さが０未満にならないかを判定。
まず、残りのステップ数からゴールまでのステップ数を引き、その半分は余裕がある。
また部分列の操作をしたあとに上る操作ならば最初に登っておいてもよいため、
ゴールまでのステップ数の分も余裕がある。
Challenge
登山のため、高さが０未満になることはないことに注意。
コード 
class FoxAndMountainEasy {
public: string possible(int n, int h0, int hn, string history) {
int x=h0,m=history.size();
FORE(i,0,history.size()){
if(history[i]==&#39;U&#39;)x++;
else x--;
}
int d=hn-x;
if(d&amp;lt;0)d=-d;
if(n-m&amp;lt;d)return &#34;NO&#34;;
if((n-m)%2!=d%2)return &#34;NO&#34;;
int up=(n-m-d)/2;
if(x&amp;lt;hn)up+=hn-x;
x=h0+up;
FORE(i,0,history.size()){
if(history[i]==&#39;U&#39;)x++;
else x--;
if(x&amp;lt;0)return &#34;NO&#34;;
}
return &#34;YES&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM541 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm541-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 13:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm541-div2--level2/</guid>
      <description>問題 
①複数の座標が与えられる。
それぞれの座標にたいして、ＮＷＳＥの方向が与えられる。
②それぞれの座標には蟻がいて指定された方向に進む。
③蟻は他の蟻とぶつかったときにフィールドから消える。
フィールドの大きさに制限はない。
④このとき、最後に残る蟻の数を返す。
解き方 
単純にシミュレーションすることで解くことができる。
Ｃｈａｌｌｅｎｇｅ
このとき、１マスずつシミュレーションすると、
蟻の距離の差が１マスで方向が互い違いの時すれちがってしまいシステムエラーとなる。
１マスごとの処理で良いか、「選んだ単位の処理でミスがないか」チェックが必要。
コード 
class AntsMeet {
public: int countAnts(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, string direction) {
int n=x.size(),ans=0;
vector&amp;lt;int&amp;gt; check(n,0);
double cx[n],cy[n];
FORE(i,0,n){
cx[i]=x[i];
cy[i]=y[i];
}
FORE(i,0,5000){
FORE(j,0,n){
if(check[j]==1)continue;
if(direction[j]==&#39;N&#39;)cy[j]+=0.5;
if(direction[j]==&#39;W&#39;)cx[j]-=0.5;
if(direction[j]==&#39;E&#39;)cx[j]+=0.5;
if(direction[j]==&#39;S&#39;)cy[j]-=0.5;
}
FORE(j,0,n){
int used=0;
if(check[j]==1)continue;
FORE(k,j+1,n){
if(check[k]==1)continue;
if(cx[j]==cx[k] &amp;amp;&amp;amp; cy[j]==cy[k]){
check[k]=1;
used=1;
}
}
if(used==1)check[j]=1;
}
}
FORE(i,0,n)if(check[i]==0)ans++;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM570 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm570-div2--level2/</link>
      <pubDate>Wed, 12 Jun 2013 23:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm570-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①数字の順列が与えられる。
②各数字に対して、ロボットはその数字の分前に進む。進んだ後は右に９０度回転する。
③最後の数字まで進む処理をＴ回繰り返す。
④このとき、最初と最後の位置のマンハッタン距離を返す。
＜解き方＞
数字の数は最大５０個、Ｔは最大１００回なので最大の場合でもＯ（５０００）。
計算量が余裕で間に合うので純粋にシミュレーションを実装する。
＜コード＞
class RobotHerbDiv2 {
public: int getdist(int T, vector&amp;lt;int&amp;gt; a) {
int x=0,y=0,dir=0;
FORE(h,0,T){
FORE(i,0,a.size()){
if(dir%4==0)y+=a[i];
if(dir%4==1)x+=a[i];
if(dir%4==2)y-=a[i];
if(dir%4==3)x-=a[i];
dir+=(a[i]%4);
}
}
return abs(x)+abs(y);
}
}; </description>
    </item>
    
  </channel>
</rss>