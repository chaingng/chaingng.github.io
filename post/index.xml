<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on takatomo&#39;s blog</title>
    <link>https://chaingng.github.io/post/</link>
    <description>Recent content in Posts on takatomo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 09 Jul 2017 09:22:00 +0900</lastBuildDate>
    
	<atom:link href="https://chaingng.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>shebangから理解するUNIXの仕組み</title>
      <link>https://chaingng.github.io/post/shebang_init/</link>
      <pubDate>Sun, 09 Jul 2017 09:22:00 +0900</pubDate>
      
      <guid>https://chaingng.github.io/post/shebang_init/</guid>
      <description>unixでシェルスクリプトを書くとき、冒頭に#!/bin/shと書くことは当たり前なのだけど、 時々コマンドなんだっけ、と忘れることがあった。 その当たり前をマジックとして理解せずに置いておいていけはいけないなと思い、 仕組みについて調べて理解してみた。
Fork-Exec まずはFork-Execについて知っている必要がある。
fork -wikipediaによると以下の通り。
Fork-Execは、UNIXで一般的に使われる手法であり、新たなプログラムをプロセスとして実行する。 fork()は親プロセスを2つの同一内容のプロセスに（フォークの先のように）分岐させるシステムコールである。 fork()によって子プロセスが親プロセスのコピーとして生成され、子プロセスがexec()システムコールを呼び出すことで（子プロセス）自身の内容を置き換える。  要は、UNIXでコマンドを実行されると実行したいコマンドはforkにより 子プロセスが生成され、その子プロセスにてexec()にて実行される。
exec() exec() -wikipediaによると execveをシステムコールとするとのこと。
現代のたいていのUnixにおける実装では、最も汎用的なexecveをシステムコールとし（すなわちexecve(2)）、 他はそれを呼ぶライブラリ関数（たとえばexec(3)）としている。  なので、execve()を調べてみる。
evecve() EXECVEによると、 指定されたプログラムはバイナリ形式、または以下の形式の行で始まるスクリプトでなければならないとある。
execve() は、filename によって指定されたプログラムを実行する。 filename は、バイナリ実行形式か、 以下の形式の行で始まるスクリプトでなければならない。 #! interpreter [optional-arg]  つまり、execve()にてファイルを実行するための形式として、ファイルの先頭にシェバンを指定しなければならないことがわかった。
まとめ シェバンと呼ばれ、スクリプトの最初で指定している#!/bin/shは
 UNIXでコマンドが実行される仕組みはFork-Execであり Fork-Execではコマンドはexec()で実行される exec()はシステムコールでexecve()を呼び出す execve()で実行できるfileはバイナリ形式またはファイルの先頭に#! interpreter [optional-arg] を指定しなければならない  ということが理解できた。仕組み理解するの大事。</description>
    </item>
    
    <item>
      <title>hugo first post</title>
      <link>https://chaingng.github.io/post/hoge/</link>
      <pubDate>Wed, 05 Jul 2017 10:21:23 +0900</pubDate>
      
      <guid>https://chaingng.github.io/post/hoge/</guid>
      <description>ようこそ， Hugo の世界へ！</description>
    </item>
    
    <item>
      <title>防御的プログラミング</title>
      <link>https://chaingng.github.io/post/%E9%98%B2%E5%BE%A1%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/</link>
      <pubDate>Sun, 25 Jun 2017 12:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E9%98%B2%E5%BE%A1%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/</guid>
      <description>CodeComplete 第8章防御的プログラミングのまとめ。
防御的プログラミングとは、「そうなるはずだ」と決めつけないこと、
防御運転にヒントを得たものである。
無効な入力への防御「ゴミ入れ、ゴミ出し」を行うコードは書かない。
代わりに、「ゴミ入れ、なにも出さない」、「ゴミ入れ、エラーメッセージをだす」、「ゴミ入れ禁止」を採用する。
ゴミ入れに対処する方法
外部ソースからのデータをすべて確認するルーチン（外部ソースではない）のすべての入力値を確認する不正な入力を処理する方法を検討する　8.3エラー処理テクニックの１０のうちのいずれかの方法を採用アサーションアサーションは、大きくて複雑なプログラムや特に高い信頼性が求められるプログラムでは特に効果的。
アサーションのガイドライン
予想される状況にはエラーコードを用い、予想されない状況にはアサーションを用いるアサーションに実行コードを埋め込まないなぜなら、デバッグモードをオフにした時にコンパイルされないことがある事前条件と事後条件の文書化に使うルーチンの最初にアサーションを定義する堅牢性の高いコードはアサーションしてから処理するエラー処理テクニックエラー処理テクニックのガイドライン。
当たり障りのない値を返す次に有効なデータで代替する前回と同じ値を返す有効な値のうち、もっとも近いもので代用するファイルに警告メッセージを記録するエラーコードを返すエラー処理ルーチンを呼び出す発生した場所でエラーメッセージを出すローカルでもっともうまくいく方法でエラーを処理する処理を中止する
堅牢性と正当性のどちらを担保するか最初に設計する。
そして上位レベルのエラー処理を設計する。
堅牢性とは、ソフトウェアの実行を継続するように手をつくすこと。
正当性とは、不正確な結果を決して返さないこと。
例外例外が正常な処理としてあつかわれているプログラムは可読性や保守性の問題から逃れられない。
例外の利点を理解し、問題を避けるためのアドバイス。
本当に例外的状況のみエラーをスローする例外を責任逃れて使用しないローカルでキャッチできない例外をスローしてはいけないコンストラクタとデストラクタで例外をスローしないオブジェクトが完全に生成されていないとデストラクタできずメモリリークを発生させる正しい抽象化レベルで例外をスローするそのクラスで発生する例外に具体化する例外メッセージに原因となるすべてのメッセージを盛り込む空のcatchブロックをかかないライブラリコードがスローする例外を知る例外レポート用ルーチンでの集中管理を検討するプロジェクトで例外の使用方法を標準化する例外に変わる手段を検討する最後に、プログラムに本当に例外処理が必要かを検討することバリケードによるエラーの被害の囲い込み検証クラスによるバリケードを設けることで、正しいものが渡されていないかもしれない信頼できないクラスから、正しいものが渡されているとする信頼できるクラスへ渡す。
手術室に例えると、外のものを消毒して内部に持ち込むこと。
入力データは入力されたらすぐに正しい型に変換する。
なぜなら、誰かがデータを変換してプログラムをクラッシュさせる危険が高まるため
バリケードの外側は何かを想定するのは危険なので、エラー処理を行う。　内側は安全なはずなので、アサーションを行う。
デバッグエイドデバッグエイドとはデバッグを補助するツールで、エラーをすばやく検出するための心強い味方になる。
製品バージョンと開発バージョンは求めるパフォーマンスやリソースが異なるので、製品の制約を開発に当てはめない。
デバッグエイドの導入は早ければ早い方が良い。
攻撃的プログラミングを使う。
開発中に例外状況を明確にし、コードの実行中に回復できるようにする。
通常は、動かないプログラムのほうが欠陥のないプログラムよりもずっと問題は少ない。
攻撃的プログラミングのガイドライン。
アサーションを使ってプログラムを中断するメモリ割当のエラーを検出できるようにするファイルフォーマットのエラーをすべて検出できるようにする条件分岐のelse defaultを激しく失敗させるオブジェクトを削除するまえにジャンクデータを設定するエラーログファイルが自分あてにメールされるようにする
デバッグエイドの削除計画を立てる。以下の方法が有効。
　製品版ではデバッグコードをとりのぞく　プリプロセッサで簡単に切り替える　デバッグ用のスタブを使用する製品コードに防御的プログラミングをどれくらい残すか開発段階ではエラーを見逃さないように醜悪に目立たせるようにしたい。
しかし製品段階ではエラーを目立たないようにしてプログラムを回復させるか上品に終わらせたい、という矛盾に応える
どれを製品コードに残すかのガイドライン。
重要なエラーを検査するコードは残すささいなエラーを検知するコードは削除する処理を中断するコードは削除する致命的なエラーを検出するデバッグコードが含まれるとき、プログラムを上品にクラッシュさせるコードがあれば残すテクニカルサポート編集者のためのエラーを記録するわかりやすいエラーメッセージは残す防御的プログラミングに対する防御複雑性が増え、そして防御的コードにもまたエラーの可能性を含むため
あまりにもチェックが多いとコードは肥大化する。
そのため、優先順位を設定する </description>
    </item>
    
    <item>
      <title>投資信託の見直しまとめ</title>
      <link>https://chaingng.github.io/post/%E6%8A%95%E8%B3%87%E4%BF%A1%E8%A8%97%E3%81%AE%E8%A6%8B%E7%9B%B4%E3%81%97%E3%81%BE%E3%81%A8%E3%82%81/</link>
      <pubDate>Mon, 13 Jun 2016 18:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%8A%95%E8%B3%87%E4%BF%A1%E8%A8%97%E3%81%AE%E8%A6%8B%E7%9B%B4%E3%81%97%E3%81%BE%E3%81%A8%E3%82%81/</guid>
      <description>目的 
いまの投資信託をよりリターン得られるように最適化する。
1.購入時手数料
投資信託の購入時にかかる手数料。
一般に対面である銀行はこれが高い。
ネット証券のNISAだとノーロードと呼ばれる、購入時手数料がかからないサービスがある。
結論:
この金額は意外と大きいので、ノーロードを活用する。
2.信託留保財産額
投資信託の売却時にかかる手数料。
投資信託に組み込まれている株式を売るときに手数料がかかるが、これを公平に負担するために、売却時に手数料を設けている。
結論:
上記より大きくならないが、選べるのであれば他のファクターが変わらないなら、こちらが安いものを選ぶ。
3.信託報酬
投資信託を運用するためにかかる手数料。
日々引かれるもの。要は、表示価格やグラフはこの金額が引かれた後のものになる。
上記よりこの手数料が運用に一番大きく左右されるため、信託報酬が安いものを選ぶのが一番の方針。
4.アクティブ型vsパッシブ型
アクティブ型投資信託はファンドマネージャーが日々売買を繰り返し運用するためこの金額が高い。
一方、パッシブ型は指数連動するもので手間がかからないのでこの金額が安い。
結論:
パッシブ型の方が統計的に成績がよく、かつ信託報酬も安い2つの理由からパッシブ型を選択する。
5.毎月分配型ｖｓ配当型ｖｓ再投資型
再投資型:
配当金が再投資されるもの。複利効果が見込める。
配当型:
配当金が再投資されず分配されるもの。
単利効果が見込める。
毎月分配型
毎月決まった金額が分配されるもの。
配当金が足りない場合は元本が切り崩されるため、単利効果が薄くなる。
参考
こちらのページ、グラフが参考になりました。
さらにこの線の下に毎月分配型があるイメージ。
http://www.morningstar.co.jp/nisa/product/fund09.html
結論:
再投資型を選ぶ。
6.現状:グローバルアロケーションファンド
1.購入手数料3.78％2.信託財産額なし3.信託報酬1.9424%4.毎月分配型
参考おすすめされていない。http://tohshi.blog61.fc2.com/blog-entry-1959.html
成績3年のスパンで-30%ほど。この間の毎月分配金を足して、プラマイゼロになっているかどうか、、
http://www.shinkotoushin.co.jp/fund/chart/118508/index.html#pnav
7.候補:MAXIS 海外株式（MSCIコクサイ）上場投信MSCIコクサイに連動した投資信託。sbi証券だと以下の通り。1.購入手数料なし(ノーロード)2.信託財産額0.1%3.信託報酬0.15%4.再投資型成績3年で約1.4倍、5年で約2倍http://www.am.mufg.jp/fund/181550.html </description>
    </item>
    
    <item>
      <title>SRM 668 DIV1 Easy - PaintTheRoom ○</title>
      <link>https://chaingng.github.io/post/srm-668-div1-easy---painttheroom-/</link>
      <pubDate>Wed, 06 Jan 2016 20:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-668-div1-easy---painttheroom-/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13846&amp;amp;rd=16548
解き方 
K=1の場合はどのようなR,Cでも達成できる。
その他の場合は、全ての道を通って元のセルに戻ってこれればOKとなる。
Rが偶数の場合もしくはCが偶数のときは元のセルに戻ってこれるが、
双方とも奇数のときは戻ってこれない。
よって、RかつCがどちらも奇数かつKが２以上の時のみCannot Paintとなる。
コード 
class PaintTheRoom {
public: string canPaintEvenly(int R, int C, int K) {
if(R%2 &amp;amp;&amp;amp; C%2 &amp;amp;&amp;amp; K&amp;gt;1)return &#34;Cannot paint&#34;;
return &#34;Paint&#34;;
}
};

 </description>
    </item>
    
    <item>
      <title>SRM 670 DIV1 Easy - DoubleOrOneEasy x</title>
      <link>https://chaingng.github.io/post/srm-670-div1-easy---doubleoroneeasy-x/</link>
      <pubDate>Wed, 06 Jan 2016 20:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-670-div1-easy---doubleoroneeasy-x/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14059&amp;amp;rd=16550
解き方 
文字列長がnのとき、条件を満たすLCSは必ずn-1となる。
そのようなサブ文字列を全て求めて条件を満たすか確かめれば良い。
サブ文字列の作り方でミスをしてしまった。。
コード 
class Bracket107 {
public:
int yetanother(string s) {
int n=s.size();
set&amp;lt;string&amp;gt; ans;
FORE(i,0,n){
string str=s.substr(0,i)+s.substr(i+1,n);
FORE(j,0,n){
string cur=str.substr(0,j)+s[i]+ str.substr(j);
if(s==cur)continue;
int valid=1;
int cnt=0;
FORE(k,0,n){
if(cur[k]==&#39;(&#39;)cnt++;
else cnt--;
if(cnt&amp;lt;0)valid=0;
}
if(valid)ans.insert(cur);
}
}
return ans.size();
}
}; </description>
    </item>
    
    <item>
      <title>SRM 677 DIV1 Easy - DoubleOrOneEasy x</title>
      <link>https://chaingng.github.io/post/srm-677-div1-easy---doubleoroneeasy-x/</link>
      <pubDate>Mon, 04 Jan 2016 21:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-677-div1-easy---doubleoroneeasy-x/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14101&amp;amp;rd=16627
解き方 
２倍と１足す動作を単純に全通り試そうとするとオーバーフローしてしまう。
ここでnewA,newBからa,bを作ることを考えてみる。
すると、２で割る動作を先にしたほうが最小の答えを得られることがわかる。
よって、割れるときは２で割る、割れない時は１を引く動作をして
そのとき、newA-a == newB-bであれば答えにたどりつけるのでこの判定ができるか
繰り返す。
１つ、片方が２で割れなく片方が割れるときは１引く動作を続けてしまい計算量がオーバーするのでbreakする必要がある。
このときの終了判定で、breakする前に答えを判定する必要があるのにミスしてしまった。。
コード 
class DoubleOrOneEasy {
public: int minimalSteps(int a, int b, int newA, int newB) {
int ret=1e+9;
int count=0;
while(a&amp;lt;=newA &amp;amp;&amp;amp; b&amp;lt;=newB){
if(newA-a==newB-b){
ret=min(ret,count+newA-a);
}else if(newA%2==0 &amp;amp;&amp;amp; newB%2==1){
break;
}
if(newA%2==0 &amp;amp;&amp;amp; newB%2==0){
newA/=2;
newB/=2;
}else{
newA--;
newB--;
}
count++;
}
return ret==1e+9 ? -1 : ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 669 DIV1 Easy - SubdividedSlimes x</title>
      <link>https://chaingng.github.io/post/srm-669-div1-easy---subdividedslimes-x/</link>
      <pubDate>Tue, 22 Dec 2015 12:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-669-div1-easy---subdividedslimes-x/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13946&amp;amp;rd=16549
解き方 
すべての場合の数を考えるとはまってしまう。
逆に制約条件を考えると、Sが与えられた時、最大まで分割した時は１がS個並ぶ、
つまり最大でS-1回分割することができる。
次に、N回分割するとき、その数の最大は均等に分割すると得られる。
よって、分割数を２〜S-1まで試していき、最大がMを超えたものが答えになる。
コード 
class SubdividedSlimes {
public: int needCut(int S, int M) {
for(int i=2;i&amp;lt;=S;i++){
vector&amp;lt;long long&amp;gt; num;
FORE(j,0,i)num.push_back(S/i);
FORE(j,0,S%i)num[j]++;
long long total=0;
FORE(j,0,i)total+=num[j];
long long sum=0;
FORE(j,0,i)sum+=num[j]*(total-num[j]);
if(sum/2&amp;gt;=M)return i-1;
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 671 DIV1 Easy - BearCries x</title>
      <link>https://chaingng.github.io/post/srm-671-div1-easy---bearcries-x/</link>
      <pubDate>Sun, 29 Nov 2015 11:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-671-div1-easy---bearcries-x/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14010&amp;amp;rd=16551
解き方 
固定できる条件はなさそう。
ある値でソーティングして貪欲にも解けなさそうなのでｄｐを考える。
dp[現在の位置][;があって_がない絵文字][;があって_がある絵文字]=現在の位置の一つ前までの状態数と考えると、200*200*200=8*10^6で間に合う。
dp[n][0][0]が最終的な答えになる。
コード 
long long dp[202][202][202];
class BearCries {
public: int count(string message) {
int n=message.size();
int MOD=1000000007;
memset(dp,0,sizeof(dp));
dp[0][0][0]=1;
FORE(i,0,n){
FORE(j,0,201)FORE(k,0,201){
if(message[i]==&#39;_&#39;){
if(j)dp[i+1][j-1][k+1]=(dp[i+1][j-1][k+1]+dp[i][j][k]*j)%MOD;
dp[i+1][j][k]=(dp[i+1][j][k]+dp[i][j][k]*k)%MOD;
}else{
if(k)dp[i+1][j][k-1]=(dp[i+1][j][k-1]+dp[i][j][k]*k)%MOD;
dp[i+1][j+1][k]=(dp[i+1][j+1][k]+dp[i][j][k])%MOD;
}
}
}
return dp[n][0][0];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 673 DIV1 Easy - BearCavalry x</title>
      <link>https://chaingng.github.io/post/srm-673-div1-easy---bearcavalry-x/</link>
      <pubDate>Sat, 28 Nov 2015 15:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-673-div1-easy---bearcavalry-x/</guid>
      <description>問題 
https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14081&amp;amp;rd=16616
解き方 
w[0]について各組み合わせを決めることで、最大にならければならないスコアが決まる。
あとは残りについて、その数を超えないように全ての組み合わせ数を求める。
ここで各兵士について、乗ることができる馬の数を考える。
この数でソートすることで、i番目の兵士は、「乗ることのできる馬の数-(i-1)」が選ぶことのできる数であり、よって組み合わせていく順番が一意に決まる。
ある値（最大スコア）を固定することで、残りを貪欲法で選ぶことができないか、選ぶことのできる観点（各兵士について乗ることのできる馬の数）がないか考える。
コード 
class BearCavalry {
public:
int countAssignments(vector&amp;lt;int&amp;gt; warriors, vector&amp;lt;int&amp;gt; horses) {
long long ret=0;
int n=warriors.size();
int MOD=1000000007;
FORE(i,0,n){
int value=warriors[0]*horses[i];
int cur[n-1];
memset(cur,0,sizeof(cur));
FORE(j,0,n-1)FORE(k,0,n)if(k!=i &amp;amp;&amp;amp; warriors[j+1]*horses[k]&amp;lt;value)cur[j]++;
sort(cur,cur+n-1);
long long tmp=1;
FORE(j,0,n-1)tmp=(tmp*max(0,cur[j]-j))%MOD;
ret+=tmp;
}
return ret%MOD;
}
};

 </description>
    </item>
    
    <item>
      <title>SRM 672 DIV1 Easy - Procrastination x</title>
      <link>https://chaingng.github.io/post/srm-672-div1-easy---procrastination-x/</link>
      <pubDate>Fri, 23 Oct 2015 13:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-672-div1-easy---procrastination-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14072&amp;amp;rd=16552
解き方 
素数を考えると、素数自身は交換対象とならない。
よって、何度交換が発生しても、ｎはｎより小さい素数とｎより大きい素数の
間に収まる。
素数の間隔は６００以内におさまるので、その間の全ての数の約数を調べて
シミュレーションし、最終的なｎの収束点が答えになる。
コード 
class Procrastination {
public: long long findFinalAssignee(long long n) {
long long L=max(2LL,n-600),R=n+600;
set&amp;lt;long long&amp;gt; s;
for(long long i=L;i&amp;lt;=R;i++){
for(long long j=2;j*j&amp;lt;=i;j++){
if(i%j==0){
s.insert(j);
s.insert(i/j);
}
}
}
vector&amp;lt;long long&amp;gt; vx;
for(set&amp;lt;long long&amp;gt;::iterator it=s.begin();it!=s.end();it++){
vx.push_back(*it);
}
sort(all(vx));
FORE(i,0,vx.size()){
if((n-1)%vx[i]==0 &amp;amp;&amp;amp; n-1&amp;gt;vx[i])n--;
else if(n%vx[i]==0 &amp;amp;&amp;amp; n&amp;gt;vx[i])n++;
}
return n;
}
};

 </description>
    </item>
    
    <item>
      <title>SRM 371 DIV1 Easy - SpiralRoute ○</title>
      <link>https://chaingng.github.io/post/srm-371-div1-easy---spiralroute-/</link>
      <pubDate>Tue, 11 Aug 2015 06:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-371-div1-easy---spiralroute-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8262&amp;amp;rd=10787
解き方 
最大ケースの時は5000*5000なのでメモリが足りない。
そのため、なにかしら工夫する必要がある。
今回width,lengthともに3以上のときはwidth-2,lengh-2かつスタート位置(r,c)を(r+1,c+1)に
したものと等しくなる。
最後にwidth&amp;lt;=2もしくはlength&amp;lt;=2となるのでこれは簡単な場合分けで解ける。
コード 
class SpiralRoute {
public: vector&amp;lt;int&amp;gt; thronePosition(int width, int length) {
int r=0,c=0;
while(width&amp;gt;=3 &amp;amp;&amp;amp; length&amp;gt;=3){
width-=2,length-=2;
r++,c++;
}
if(length==1)r+=width-1;
else if(length==2)c++;
else if(width==1)c+=length-1;
else c++;
vector&amp;lt;int&amp;gt; ans(2);
ans[0]=r,ans[1]=c;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 372 DIV1 Easy - RoadConstruction ○</title>
      <link>https://chaingng.github.io/post/srm-372-div1-easy---roadconstruction-/</link>
      <pubDate>Mon, 10 Aug 2015 09:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-372-div1-easy---roadconstruction-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8223&amp;amp;rd=10789
解き方 
解くだけ。１度一周して確かめるなど、うまく条件を整理するのがポイント。
コード 
class RoadConstruction {
public: int getExitTime(vector&amp;lt;string&amp;gt; lanes) {
int n=lanes.size();
int ret=0;
int flag[n];
memset(flag,0,sizeof(flag));
int at=0,prev=-1;
while(1){
while(at&amp;lt;n &amp;amp;&amp;amp; lanes[at].empty())at++;
if(at&amp;lt;n &amp;amp;&amp;amp; flag[at]==0){
prev=at;
flag[at]=1;
at++;
}else{
if(at&amp;gt;=n)at=prev;
if(lanes[at][0]==&#39;D&#39;)return ret;
ret++;
lanes[at]=lanes[at].substr(1);
flag[at]=0;
at=0,prev=-1;
}
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 373 DIV1 Easy - StringFragmentation ○</title>
      <link>https://chaingng.github.io/post/srm-373-div1-easy---stringfragmentation-/</link>
      <pubDate>Sun, 09 Aug 2015 20:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-373-div1-easy---stringfragmentation-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8087&amp;amp;rd=10791
解き方 
全探索可能なので解くだけ。
コード 
class StringFragmentation {
public: int largestFontSize(string text, int width, int height) {
vector&amp;lt;int&amp;gt; vx;
stringstream out(text);
for(string str;out&amp;gt;&amp;gt;str;){
vx.push_back(str.size());
}
int n=vx.size();
for(int i=5000;i&amp;gt;=8;i--){
int at=0,lines=0;
while(at&amp;lt;n){
int cur=0;
if(vx[at]*(i+2)&amp;lt;=width){
cur+=vx[at]*(i+2);
}else break;
while(at+1&amp;lt;n &amp;amp;&amp;amp; cur+(vx[at+1]+1)*(i+2)&amp;lt;=width){
cur+=(vx[at+1]+1)*(i+2);
at++;
}
lines++;
at++;
}
if(at&amp;gt;=n &amp;amp;&amp;amp; lines*2*i&amp;lt;=height)return i;
}
return -1;
}
} </description>
    </item>
    
    <item>
      <title>SRM 374 DIV1 Easy - SyllableSorting x</title>
      <link>https://chaingng.github.io/post/srm-374-div1-easy---syllablesorting-x/</link>
      <pubDate>Sat, 08 Aug 2015 06:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-374-div1-easy---syllablesorting-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8374&amp;amp;rd=10793
解き方 
文字列操作の問題。
問題文の最後の比較条件を見落としてしまった。。
コード 
class SyllableSorting {
public:
bool ispossible(char cur){
char ch[]={&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;};
FORE(i,0,5)if(cur==ch[i])return false;
return true;
}
vector&amp;lt;string&amp;gt; calc(string w){
int n=w.size();
vector&amp;lt;string&amp;gt; ans;
int at=0;
while(at&amp;lt;n){
string str=&#34;&#34;;
int flag=0;
while(at&amp;lt;n){
if(ispossible(w[at])){
if(flag==0)str+=w[at++];
else break;
}else{
str+=w[at++];
flag=1;
}
}
ans.push_back(str);
}
return ans;
}
vector&amp;lt;string&amp;gt; sortWords(vector&amp;lt;string&amp;gt; words) {
int n=words.size();
vector&amp;lt;pair&amp;lt;pair&amp;lt;vector&amp;lt;string&amp;gt;,vector&amp;lt;string&amp;gt; &amp;gt;,string&amp;gt; &amp;gt; p;
FORE(i,0,n){
vector&amp;lt;string&amp;gt; cur=calc(words[i]);
vector&amp;lt;string&amp;gt; cur2=cur;
sort(all(cur));
p.push_back(make_pair(make_pair(cur,cur2),words[i]));
}</description>
    </item>
    
    <item>
      <title>SRM 375 DIV1 Easy - DivisibleByDigits ○</title>
      <link>https://chaingng.github.io/post/srm-375-div1-easy---divisiblebydigits-/</link>
      <pubDate>Fri, 07 Aug 2015 13:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-375-div1-easy---divisiblebydigits-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8318&amp;amp;rd=10794
解き方 
2~9すべての最大公約数は2520なので
答えは最大でもn+5桁程度であり、全探索が可能。
コード 
class DivisibleByDigits {
public:
bool ispossible(long long x,vector&amp;lt;int&amp;gt; vx){
FORE(i,0,vx.size())if(x%vx[i]!=0)return false;
return true;
}
long long getContinuation(int n) {
set&amp;lt;int&amp;gt; s;
int x=n;
while(x&amp;gt;0){
s.insert(x%10);
x/=10;
}
vector&amp;lt;int&amp;gt; vx;
FORE(i,1,10)if(s.find(i)!=s.end())vx.push_back(i);
string str;
stringstream out;
out &amp;lt;&amp;lt; n;
out &amp;gt;&amp;gt; str;
queue&amp;lt;string&amp;gt; q;
q.push(str);
while(!q.empty()){
string cur=q.front();
q.pop();
stringstream out2(cur);
long long p;
out2 &amp;gt;&amp;gt; p;
if(ispossible(p,vx))return p;
for(char ch=&#39;0&#39;;ch&amp;lt;=&#39;9&#39;;ch++){
q.push(cur+ch);
}</description>
    </item>
    
    <item>
      <title>SRM 381 DIV1 Easy - TheDiceGame x</title>
      <link>https://chaingng.github.io/post/srm-381-div1-easy---thedicegame-x/</link>
      <pubDate>Wed, 05 Aug 2015 10:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-381-div1-easy---thedicegame-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8414&amp;amp;rd=10804
解き方 
dpで解く。
前の状態から現在の状態までに行ける全ての場合について和をとっていく。
前の状態から＋１回かつサイコロなので1/6を掛けたものになる。
コード 
class TheDiceGame {

public: double expectedThrows(int candies) {memset(dp,0,sizeof(dp));for(int i=1;i&amp;lt;=candies;i++){for(int j=1;j&amp;lt;=6;j++){int prev=max(0,i-j);dp[i]+=(dp[prev]+1.0)/6.0;}}
return dp[candies];}
}; </description>
    </item>
    
    <item>
      <title>SRM 663 DIV1 Easy - ABBADiv1 ○</title>
      <link>https://chaingng.github.io/post/srm-663-div1-easy---abbadiv1-/</link>
      <pubDate>Wed, 05 Aug 2015 09:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-663-div1-easy---abbadiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13922&amp;amp;rd=16512
解き方 
initialからtargetを生成するよう順に解いていき、部分列が存在しないようなら
打ち切ることで、候補数は限られるので時間内に解くことができる。
targetからinitialに戻せるか試しても良い。
コード 
class ABBADiv1 {
public:
string rev(string str){
string ret=&#34;&#34;;
for(int i=str.size()-1;i&amp;gt;=0;i--)ret+=str[i];
return ret;
}
bool dfs(string cur,string target){
if(cur.size()&amp;gt;target.size())return false;
if(cur.size()==target.size()){
return cur==target;
}
bool valid=false;
string s1=cur+&#39;A&#39;;
if(target.find(s1)!=string::npos || target.find(rev(s1))!=string::npos){
valid|=dfs(s1,target);
}
string s2=cur+&#39;B&#39;;
if(target.find(s2)!=string::npos || target.find(rev(s2))!=string::npos){
valid|=dfs(rev(s2),target);
}
return valid;
}
string canObtain(string initial, string target) {
return dfs(initial,target) ? &#34;Possible&#34; : &#34;Impossible&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 664 DIV1 Easy - BearPlays x</title>
      <link>https://chaingng.github.io/post/srm-664-div1-easy---bearplays-x/</link>
      <pubDate>Wed, 05 Aug 2015 09:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-664-div1-easy---bearplays-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13916&amp;amp;rd=16513
解き方 
数学的に解くことができるのに気がつけるか。
A+B=Sとすると、
A&amp;lt;Bのとき、A=2*A=2A%S
A&amp;gt;Bのとき、A=A-B=A+(A-(A+B))=A+(A-S)=2A-S=2A%S
よって常にA*2%Sとなる。
K回かけるので、かけた後はA*2^k%Sとなり、この値とSからこの値を引いたもののうち
最小のものが答えになる。
Kは大きいので繰り返し２乗法を用いる。
コード 
class BearPlays {
public:
long long modpow(long long a,long long k,long long m){
if(k==0)return 1;
if(k%2==0)return modpow((a*a)%m,k/2,m);
return (a*modpow(a,k-1,m))%m;
}
int pileSize(int A, int B, int K) {
long long a=(A*modpow(2,K,A+B))%(A+B);
return min(a,A+B-a);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 380 DIV1 Easy - LameKnight ○</title>
      <link>https://chaingng.github.io/post/srm-380-div1-easy---lameknight-/</link>
      <pubDate>Tue, 04 Aug 2015 06:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-380-div1-easy---lameknight-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8183&amp;amp;rd=10802
解き方 
条件より、すべての４方向にいける場合とそれ以外を場合分けする。
次に高さの値によって場合分けできることがわかる。
高さが３以上ある場合は上に２、右に１行き、次に下に２、右に１行くのが
最適になる。
高さ２のときは上に１、右に２，下に１，右に２しかいけなく、
高さ１のときは動くことができない。
コード 
class LameKnight {
public: int maxCells(int height, int width) {
if(height&amp;gt;=3 &amp;amp;&amp;amp; width&amp;gt;=7)return width-2;
if(height&amp;gt;=3)return min(4,width);
if(height==2)return min(4,(width+1)/2);
return 1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 379 DIV1 Easy - SellingProducts ○</title>
      <link>https://chaingng.github.io/post/srm-379-div1-easy---sellingproducts-/</link>
      <pubDate>Tue, 04 Aug 2015 06:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-379-div1-easy---sellingproducts-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8440&amp;amp;rd=10800
解き方 
一見すべての価格について調べる必要があり、10^6なのでそれでも解けそう。
ただし少し考えると各顧客の最大購入価格が一番利益を得ることができる選び方なので
すべての最大購入価格のうち、最も利益の出るものが答えになる。
コード 
class SellingProducts {
public: int optimalPrice(vector&amp;lt;int&amp;gt; price, vector&amp;lt;int&amp;gt; cost) {
int n=price.size();
int profit=0,idx=0;
FORE(i,0,n){
int cur=0;
FORE(j,0,n)if(price[i]&amp;lt;=price[j] &amp;amp;&amp;amp; price[i]&amp;gt;cost[j]){
cur+=price[i]-cost[j];
}
if(cur&amp;gt;=0 &amp;amp;&amp;amp; (profit&amp;lt;cur || (profit==cur &amp;amp;&amp;amp; price[idx]&amp;gt;price[i]) )){
profit=cur;
idx=i;
}
}
return profit==0 ? 0 : price[idx];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 378 DIV1 Easy - TrueStatements ○</title>
      <link>https://chaingng.github.io/post/srm-378-div1-easy---truestatements-/</link>
      <pubDate>Tue, 04 Aug 2015 06:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-378-div1-easy---truestatements-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8390&amp;amp;rd=10798
解き方 
正しいことを言っている人数を０〜５０までのすべてについて調べ、
矛盾しないもののうち最大の人数が答えになる。
コード 
class TrueStatements {
public: int numberTrue(vector&amp;lt;int&amp;gt; statements) {
int n=statements.size();
int ret=-1;
for(int i=0;i&amp;lt;=50;i++){
int cnt=0;
FORE(j,0,n)if(i==statements[j])cnt++;
if(i==cnt)ret=i;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 376 DIV1 Easy - Trainyard x</title>
      <link>https://chaingng.github.io/post/srm-376-div1-easy---trainyard-x/</link>
      <pubDate>Tue, 04 Aug 2015 06:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-376-div1-easy---trainyard-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6555&amp;amp;rd=10796
解き方 
実装問題。システムテストで落ちやすい問題なので、すべて条件文をもれなく書かないといけない。
コード 
class Trainyard {
public: int reachableSquares(vector&amp;lt;string&amp;gt; layout, int fuel) {
int h=layout.size(),w=layout[0].size();
int dr[]={1,0,-1,0},dc[]={0,1,0,-1};
int dp[4][10][10];
FORE(i,0,4)FORE(j,0,10)FORE(k,0,10)dp[i][j][k]=-1;
queue&amp;lt;pair&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt; &amp;gt; q;
FORE(i,0,h)FORE(j,0,w)if(layout[i][j]==&#39;S&#39;){
FORE(k,0,4){
dp[k][i][j]=fuel;
q.push(make_pair(k,make_pair(i,j)));
}
}
while(!q.empty()){
int r=q.front().second.first;
int c=q.front().second.second;
int d=q.front().first;
int cost=dp[d][r][c];
q.pop();
FORE(i,0,4){
if(layout[r][c]==&#39;|&#39; &amp;amp;&amp;amp; (i==1 || i==3))continue;
if(layout[r][c]==&#39;-&#39; &amp;amp;&amp;amp; (i==0 || i==2))continue;
int nr=r+dr[i],nc=c+dc[i];
if(0&amp;lt;=nr &amp;amp;&amp;amp; nr&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=nc &amp;amp;&amp;amp; nc&amp;lt;w &amp;amp;&amp;amp; layout[nr][nc]!=&#39;.&#39;){
if(layout[nr][nc]!=&#39;+&#39;){
if((abs(d-i)%2)!=0 &amp;amp;&amp;amp; abs(d-i)==2)continue;</description>
    </item>
    
    <item>
      <title>SRM 383 DIV1 Easy - Planks ○</title>
      <link>https://chaingng.github.io/post/srm-383-div1-easy---planks-/</link>
      <pubDate>Thu, 30 Jul 2015 10:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-383-div1-easy---planks-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8396&amp;amp;rd=10806
解き方 
１つの木の長さを１〜１００００のそれぞれに固定して考える。
あとは、与えられた木がその長さで割った時、値がプラスなら足していき
最大のものを求めれば良い。
コード 
class Planks {
public: int makeSimilar(vector&amp;lt;int&amp;gt; lengths, int costPerCut, int woodValue) {
int n=lengths.size();
int ret=0;
for(int len=1;len&amp;lt;=10000;len++){
int cur=0;
FORE(i,0,n)if(len&amp;lt;=lengths[i]){
int num=lengths[i]/len;
int cuts=num-((lengths[i]%len)==0);
int value=num*woodValue*len-cuts*costPerCut;
if(value&amp;gt;0)cur+=value;
}
ret=max(ret,cur);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 384 DIV1 Easy - Library ○</title>
      <link>https://chaingng.github.io/post/srm-384-div1-easy---library-/</link>
      <pubDate>Tue, 28 Jul 2015 04:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-384-div1-easy---library-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7659&amp;amp;rd=10808
解き方 
解くだけ。
setを使えば重複の考慮も不要で、条件を満たしているかも簡単に判断できる。
コード 
class Library {
public: int documentAccess(vector&amp;lt;string&amp;gt; records, vector&amp;lt;string&amp;gt; userGroups, vector&amp;lt;string&amp;gt; roomRights) {
set&amp;lt;string&amp;gt; user,room;
FORE(i,0,userGroups.size())user.insert(userGroups[i]);
FORE(i,0,roomRights.size())room.insert(roomRights[i]);
set&amp;lt;string&amp;gt; ans;
FORE(i,0,records.size()){
stringstream out(records[i]);
string doc,u,r;
out &amp;gt;&amp;gt; doc &amp;gt;&amp;gt; r &amp;gt;&amp;gt; u;
if(room.find(r)!=room.end() &amp;amp;&amp;amp; user.find(u)!=user.end()){
ans.insert(doc);
}
}
return ans.size();
}
}; </description>
    </item>
    
    <item>
      <title>SRM 385 DIV1 Easy - UnderscoreJustification ○</title>
      <link>https://chaingng.github.io/post/srm-385-div1-easy---underscorejustification-/</link>
      <pubDate>Mon, 27 Jul 2015 20:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-385-div1-easy---underscorejustification-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8482&amp;amp;rd=10810
解き方 
各スペースに挿入するアンダースコアの数の差は最大１なので、
スペースの数と挿入できるアンダースコアの数がわかれば
答えは一意に定まる。
コード 
class UnderscoreJustification {
public:
string justifyLine(vector&amp;lt;string&amp;gt; words, int width) {
int n=words.size();
int len=0;
FORE(i,0,n)len+=words[i].size();
int s=width-len;
int num2=s%(n-1);
int num1=(n-1)-num2;
s/=(n-1);
string ret=words[0];
FORE(i,1,n){
if((num1&amp;gt;0 &amp;amp;&amp;amp; num2==0) || (words[i][0]&amp;lt;=&#39;Z&#39; &amp;amp;&amp;amp; num1&amp;gt;0)){
FORE(j,0,s)ret+=&#39;_&#39;;
num1--;
}else{
FORE(j,0,s+1)ret+=&#39;_&#39;;
num2--;
}
ret+=words[i];
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>2015 TCO Round 2C Easy - YetAnotherCardGame x</title>
      <link>https://chaingng.github.io/post/2015-tco-round-2c-easy---yetanothercardgame-x/</link>
      <pubDate>Sun, 26 Jul 2015 05:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2015-tco-round-2c-easy---yetanothercardgame-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13912&amp;amp;rd=16523
解き方 
dpの問題。
１．どのような順序で処理されるか
→petr、snukeが順番に１つずつ出していく
２．前の状態としてどのような状態があればよいか
→前に出されたカードと、それまでに重ねられたカードの数
dp[一番上のカードの数字]＝ 重ねられたカードの数の最大値とし、
毎ターンできるだけ小さな数字でカードを重ねていけば良い。
問題文中の取ることが出きる動作のうち、１枚カードを食べるというのは
要はパスしてもよいというのがわかれば上記に帰着できそうだった。
コード 
class YetAnotherCardGame {
public: int maxCards(vector&amp;lt;int&amp;gt; petr, vector&amp;lt;int&amp;gt; snuke) {
int n=petr.size();
int dp[101];
memset(dp,0,sizeof(dp));
sort(all(petr));
sort(all(snuke));
FORE(i,0,n){
for(int x=100;x&amp;gt;=0;x--){
FORE(j,0,n)if(petr[j]&amp;gt;x){
dp[petr[j]]=max(dp[petr[j]],dp[x]+1);
break;
}
}
for(int x=100;x&amp;gt;=0;x--){
FORE(j,0,n)if(snuke[j]&amp;gt;x){
dp[snuke[j]]=max(dp[snuke[j]],dp[x]+1);
break;
}
}
}
return *max_element(dp,dp+101);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 386 DIV1 Easy - CandidateKeys △</title>
      <link>https://chaingng.github.io/post/srm-386-div1-easy---candidatekeys-/</link>
      <pubDate>Sun, 26 Jul 2015 04:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-386-div1-easy---candidatekeys-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8444&amp;amp;rd=11120
解き方 
ビット列ですべての組み合わせについて調べれば良い。
ただし、その部分集合で満たすものがあれば偽になるので
これまで調べたビット列で真のものを保存して、含まれないか判定する。
ビット列は順番に調べていけばそれまでの値は必ず含まれるので問題ない。
コード 
class CandidateKeys {
public: vector&amp;lt;int&amp;gt; getKeys(vector&amp;lt;string&amp;gt; table) {
int n=table.size(),m=table[0].size();
int valid=0;
vector&amp;lt;int&amp;gt; ans(2);
ans[0]=1e+9,ans[1]=0;
vector&amp;lt;int&amp;gt; vx;
for(int mask=1;mask&amp;lt;(1&amp;lt;&amp;lt;m);mask++){
set&amp;lt;string&amp;gt; s;
FORE(i,0,n){
string str=&#34;&#34;;
FORE(j,0,m)if(mask&amp;amp;(1&amp;lt;&amp;lt;j))str+=table[i][j];
s.insert(str);
}
if(s.size()==n){
valid=1;
int can=1;
FORE(i,0,vx.size())if((vx[i]&amp;amp;mask)==vx[i])can=0;
if(can){
ans[0]=min(ans[0],__builtin_popcount(mask));
ans[1]=max(ans[1],__builtin_popcount(mask));
vx.push_back(mask);
}
}
}
return valid ? ans : vector&amp;lt;int&amp;gt;();
}
}; </description>
    </item>
    
    <item>
      <title>SRM 387 DIV1 Easy - FoxesOfTheRoundTable △</title>
      <link>https://chaingng.github.io/post/srm-387-div1-easy---foxesoftheroundtable-/</link>
      <pubDate>Sat, 25 Jul 2015 06:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-387-div1-easy---foxesoftheroundtable-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8527&amp;amp;rd=11121
解き方 
全てのjoker boxの選び方について全探索する。
joker box以外の箱について２色以上入っている箱は必ず動かさなければいけない。
そのため１色しか入っていない箱のみ調べ、
使っていない色であればその色を割り当てていけばよい。
コード 
class MarblesRegroupingEasy {
public:
int minMoves(vector&amp;lt;string&amp;gt; boxes) {
int n=boxes.size(),m=boxes[0].size();
int used[m];
int ret=1e+9;
FORE(i,0,n){
int cost=0;
memset(used,0,sizeof(used));
FORE(j,0,n)if(i!=j){
int cnt=0,color=-1;
FORE(k,0,m)if(boxes[j][k]!=&#39;0&#39;)cnt++,color=k;
if(cnt==0)continue;
if(cnt==1 &amp;amp;&amp;amp; used[color]==0)used[color]=1;
else cost++;
}
ret=min(ret,cost);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 388 DIV1 Easy - SmoothNumbers ○</title>
      <link>https://chaingng.github.io/post/srm-388-div1-easy---smoothnumbers-/</link>
      <pubDate>Sat, 25 Jul 2015 05:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-388-div1-easy---smoothnumbers-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8519&amp;amp;rd=11122
解き方 
あらかじめ対象となる全ての数について素数かどうか判定しておけば
O(sqrt(10^5) * 10^5)=O(3*10^7)なので間に合う。
素数かどうかの判定にエラトステネスのふるいを使えば
こちらの計算量も多く見積もってsqrt(10^5)*5*10^4=1.5*10^7程度。
コード 
int isprime[100001];
class SmoothNumbers {
public: int countSmoothNumbers(int N, int k) {
FORE(i,0,100001)isprime[i]=1;
isprime[0]=0,isprime[1]=0;
for(int i=2;i*i&amp;lt;=100000;i++)if(isprime[i]){
for(int j=i*2;j&amp;lt;=100000;j+=i)isprime[j]=0;
}
int ret=0;
for(int i=1;i&amp;lt;=N;i++){
int mx=0;
for(int j=2;j*j&amp;lt;=i;j++)if(i%j==0){
if(isprime[j])mx=max(mx,j);
if(isprime[i/j])mx=max(mx,i/j);
}
if(isprime[i])mx=i;
if(mx&amp;lt;=k)ret++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 389 DIV1 Easy - ApproximateDivision ○</title>
      <link>https://chaingng.github.io/post/srm-389-div1-easy---approximatedivision-/</link>
      <pubDate>Sat, 25 Jul 2015 05:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-389-div1-easy---approximatedivision-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6125&amp;amp;rd=11123
解き方 
問題分の通りに実装すればよい。
ただし、c/tの計算はそれぞれc,tをかけてから割り算を行うとオーバーフローするので
c/tを毎回掛けて計算する必要がある。
コード 
class ApproximateDivision {
public: double quotient(int a, int b, int terms) {
int t=1;
while(t&amp;lt;b)t*=2;
int c=t-b;
double ret=0,add=1/(double)t;
FORE(i,0,terms){
ret+=add;
add*=c/(double)t;
}
return ret*a;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 390 DIV1 Easy - ConcatenateNumber ○</title>
      <link>https://chaingng.github.io/post/srm-390-div1-easy---concatenatenumber-/</link>
      <pubDate>Sat, 25 Jul 2015 04:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-390-div1-easy---concatenatenumber-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8589&amp;amp;rd=11124
解き方 
そのままの整数でシミュレーションすると計算量が間に合わないが
MODにして計算してあげるとシンプルになる。
MOD後の数を保存しておき、すでに現れたMOD後の数が現れると
ループしているので−１となる。
コード 
class ConcatenateNumber {
public: int getSmallest(int number, int k) {
long long p=1,tmp=number;
while(tmp&amp;gt;0){
tmp/=10;
p*=10;
}
p%=k;
set&amp;lt;int&amp;gt; s;
int cnt=1,cur=number%k,add=number%k;
while(s.find(cur)==s.end()){
if(cur==0)return cnt;
s.insert(cur);
add=(p*add)%k;
cur=(cur+add)%k;
cnt++;
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 391 DIV1 Easy - IsomorphicWords ○</title>
      <link>https://chaingng.github.io/post/srm-391-div1-easy---isomorphicwords-/</link>
      <pubDate>Fri, 24 Jul 2015 18:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-391-div1-easy---isomorphicwords-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8175&amp;amp;rd=11125
解き方 
全ての文字について、可能な限り昇順になるように変換する。
変換後、一致する文字列群について組み合わせを計算してあげればよい。
コード 
class IsomorphicWords {
public: int countPairs(vector&amp;lt;string&amp;gt; words) {
int n=words.size();
FORE(i,0,n){
char ch=&#39;a&#39;;
FORE(j,0,words[i].size()){
if(words[i][j]==ch)ch++;
else if(words[i][j]&amp;gt;ch){
char prev=words[i][j];
FORE(k,j,words[i].size()){
if(words[i][k]==ch)words[i][k]=prev;
else if(words[i][k]==prev)words[i][k]=ch;
}
ch++;
}
}
}
int ret=0;
int used[n];
memset(used,0,sizeof(used));
FORE(i,0,n)if(used[i]==0){
int cnt=0;
FORE(j,i,n)if(used[j]==0 &amp;amp;&amp;amp; words[i]==words[j]){
used[j]=1,cnt++;
}
ret+=cnt*(cnt-1)/2;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 392 DIV1 Easy - TwoStringMasks x</title>
      <link>https://chaingng.github.io/post/srm-392-div1-easy---twostringmasks-x/</link>
      <pubDate>Fri, 24 Jul 2015 18:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-392-div1-easy---twostringmasks-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8706&amp;amp;rd=11126
解き方 
仮の文字列を作る。
＊にあたる共通の部分は？で埋めて、s1とs2について同じ長さの２つの文字列を作る。
各文字について一致していればその文字列は有効になるのでそれが答えになる。
そのような文字列が存在しなければimpossibleとなる。
コード 
class TwoStringMasks {
public: string shortestCommon(string s1, string s2) {
for(int l1=0;l1&amp;lt;=200;l1++){
int l2=s1.size()+l1-s2.size();
if(l2&amp;lt;0)continue;
string p1=&#34;&#34;;
FORE(i,0,s1.size()){
if(s1[i]==&#39;*&#39;)FORE(j,0,l1)p1+=&#39;?&#39;;
else p1+=s1[i];
}
string p2=&#34;&#34;;
FORE(i,0,s2.size()){
if(s2[i]==&#39;*&#39;)FORE(j,0,l2)p2+=&#39;?&#39;;
else p2+=s2[i];
}
string ans=&#34;&#34;;
int valid=1;
FORE(i,0,p1.size()){
char ch;
if(p1[i]==&#39;?&#39;)ch=p2[i];
else if(p2[i]==&#39;?&#39;)ch=p1[i];
else if(p1[i]==p2[i])ch=p1[i];
else{
valid=0;
break;
}
ans+=ch;
}
if(valid)return ans;
}
return &#34;impossible&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 393 DIV1 Easy - InstantRunoffVoting ○</title>
      <link>https://chaingng.github.io/post/srm-393-div1-easy---instantrunoffvoting-/</link>
      <pubDate>Fri, 24 Jul 2015 17:07:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-393-div1-easy---instantrunoffvoting-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8607&amp;amp;rd=11127
解き方 
問題分の通り実装し、収束するまで繰り返せば良い。
コード 
class InstantRunoffVoting {
public: int winner(vector&amp;lt;string&amp;gt; voters) {
int n=voters.size(),m=voters[0].size();
int used[10],v[10];
memset(used,0,sizeof(used));
while(1){
memset(v,0,sizeof(v));
int finish=1;
FORE(i,0,m)if(used[i]==0)finish=0;
if(finish)break;
FORE(i,0,n){
int idx=0;
while(used[voters[i][idx]-&#39;0&#39;]==1)idx++;
v[voters[i][idx]-&#39;0&#39;]++;
}
FORE(i,0,m)if(v[i]&amp;gt;n*0.5)return i;
int mx=100;
FORE(i,0,m)if(used[i]==0)mx=min(mx,v[i]);
FORE(i,0,m)if(v[i]==mx)used[i]=1;
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 394 DIV1 Easy - RoughStrings ○</title>
      <link>https://chaingng.github.io/post/srm-394-div1-easy---roughstrings-/</link>
      <pubDate>Fri, 24 Jul 2015 16:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-394-div1-easy---roughstrings-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8594&amp;amp;rd=11128
解き方 
文字を消す回数0〜ｎ回までそれぞれについて、
最も少ない文字を消す回数と頻出する回数すべての場合について全探索する。
O（50*50*50log50=1.25*10^6*log50）で間に合う。
コード 
class RoughStrings {
public: int minRoughness(string s, int n) {
int num[26]={};
FORE(i,0,s.size())num[s[i]-&#39;a&#39;]++;
vector&amp;lt;int&amp;gt; vx;
FORE(i,0,26)if(num[i]&amp;gt;0)vx.push_back(num[i]);
sort(all(vx));
int ret=1e+9;
for(int sum=0;sum&amp;lt;=n;sum++)for(int right=0;right&amp;lt;=sum;right++){
vector&amp;lt;int&amp;gt; cur=vx;
FORE(j,0,right){
int pos=0;
while(cur[pos]==0)pos++;
cur[pos]--;
}
FORE(j,right,sum){
cur[cur.size()-1]--;
sort(all(cur));
}
int idx=0;
while(cur[idx]==0)idx++;
ret=min(ret,cur[cur.size()-1]-cur[idx]);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 395 DIV1 Easy - StreetWalking ○</title>
      <link>https://chaingng.github.io/post/srm-395-div1-easy---streetwalking-/</link>
      <pubDate>Fri, 24 Jul 2015 16:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-395-div1-easy---streetwalking-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8464&amp;amp;rd=11129
解き方 
以下の３通りのうち、最小のものが答えになる。
１．すべて直線で移動（直線移動のコストが小さい時に有効）
２．できるだけ斜めに移動して、残りを直線で移動（斜め移動のコストが小さいときに有効）
３．最短距離で移動（どちらの移動のコストも同程度のときに有効）
コード 
class StreetWalking {
public: long long minTime(int X, int Y, int walkTime, int sneakTime) {
long long ret=(X+Y)*(long long)walkTime;
long long wnum=max(X,Y)-min(X,Y);
long long snum=min(X,Y);
ret=min(ret,snum*sneakTime+wnum*walkTime);
snum+=(wnum/2)*2;
wnum%=2;
ret=min(ret,snum*sneakTime+wnum*walkTime);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 396 DIV1 Easy - DNAString ○</title>
      <link>https://chaingng.github.io/post/srm-396-div1-easy---dnastring-/</link>
      <pubDate>Fri, 24 Jul 2015 15:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-396-div1-easy---dnastring-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8584&amp;amp;rd=12168
解き方 
間隔が１からmaxPeriodについてそれぞれ最小の変換コストを検索し、
そのうち最小のものが答えになる。
コード 
class DNAString {
public: int minChanges(int maxPeriod, vector&amp;lt;string&amp;gt; dna) {
string str=accumulate(all(dna),string());
int n=str.size();
int ret=1e+9;
for(int p=1;p&amp;lt;=maxPeriod;p++){
int cost=0;
for(int i=0;i&amp;lt;p;i++){
int a=0,t=0,g=0,c=0;
for(int j=i;j&amp;lt;n;j+=p){
if(str[j]==&#39;A&#39;)a++;
else if(str[j]==&#39;T&#39;)t++;
else if(str[j]==&#39;G&#39;)g++;
else c++;
}
int mx=max(max(a,t),max(g,c));
cost+=a+t+c+g-mx;
}
ret=min(ret,cost);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 399 DIV1 Easy - AvoidingProduct x</title>
      <link>https://chaingng.github.io/post/srm-399-div1-easy---avoidingproduct-x/</link>
      <pubDate>Fri, 24 Jul 2015 15:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-399-div1-easy---avoidingproduct-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8758&amp;amp;rd=12171
解き方 
zの探索を枝刈りすることによって、ほぼx,yのすべての組み合わせだけ調べればよいので
O(10^6)で全探索可能。
調べる範囲として、NGの値の上限は1000のため取りうる値は1001まで
調べる必要がある。上限値の設定によるエラーケースに注意。
コード 
class AvoidingProduct {
public: vector&amp;lt;int&amp;gt; getTriple(vector&amp;lt;int&amp;gt; a, int n) {
set&amp;lt;int&amp;gt; s;
FORE(i,0,a.size())s.insert(a[i]);
vector&amp;lt;int&amp;gt; ans(3,1001);
for(int x=1;x&amp;lt;=1001;x++)if(s.find(x)==s.end()){
for(int y=x;y&amp;lt;=1001;y++)if(s.find(y)==s.end()){
for(int z=y;z&amp;lt;=1001;z++)if(s.find(z)==s.end()){
int cur=abs(ans[0]*ans[1]*ans[2]-n);
if(cur&amp;gt;abs(x*y*z-n)){
ans[0]=x,ans[1]=y,ans[2]=z;
}
if(abs(x*y*z-n)&amp;gt; abs(x*y*(z-1)-n))break;
}
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 398 DIV1 Easy - CountExpressions ○</title>
      <link>https://chaingng.github.io/post/srm-398-div1-easy---countexpressions-/</link>
      <pubDate>Fri, 24 Jul 2015 14:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-398-div1-easy---countexpressions-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8157&amp;amp;rd=12170
解き方 
O（4! * 3^3）なので全探索可能。
ｘ２つ、ｙ２つの全ての並べ方、＋、ー、＊の全ての並び方に対して
valと一致するものの数を数えれば良い。
next_permutationを使えば重複しない。
コード 
class CountExpressions {
public:
int calc(int x,int y,int op){
if(op==0)return x+y;
if(op==1)return x-y;
return x*y;
}
int calcExpressions(int x, int y, int val) {
vector&amp;lt;int&amp;gt; num(4,0);
num[0]=x,num[1]=x,num[2]=y,num[3]=y;
sort(all(num));
int ret=0;
do{
int cur=0;
FORE(i,0,3)FORE(j,0,3)FORE(k,0,3){
cur=calc(num[0],num[1],i);
cur=calc(cur,num[2],j);
cur=calc(cur,num[3],k);
if(cur==val)ret++;
}
}while(next_permutation(all(num)));
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 662 DIV1 Easy - FoxesOfTheRoundTable △</title>
      <link>https://chaingng.github.io/post/srm-662-div1-easy---foxesoftheroundtable-/</link>
      <pubDate>Sun, 12 Jul 2015 15:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-662-div1-easy---foxesoftheroundtable-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13858&amp;amp;rd=16511
解き方 
Dが1000までなので、Dを固定することで解けそう。
ただ、Dをできるだけ小さくするということは、並べ方は以下の通り
一意に定まる。
要はh[i]の小さい順に0,1,2,3,4...とすると、単に0から左右に順に並べていけば良い。
3 1 0 2 4...となる。
コード 
class FoxesOfTheRoundTable {
public: vector&amp;lt;int&amp;gt; minimalDifference(vector&amp;lt;int&amp;gt; h) {
int n=h.size();
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
FORE(i,0,n)p.push_back(make_pair(h[i],i));
sort(all(p));
vector&amp;lt;int&amp;gt; ans;
int end = n%2 ? n-2 : n-1;
for(int i=end;i&amp;gt;0;i-=2)ans.push_back(p[i].second);
for(int i=0;i&amp;lt;n;i+=2)ans.push_back(p[i].second);
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>2015 TCO Round 2B Easy - Bitwisdom </title>
      <link>https://chaingng.github.io/post/2015-tco-round-2b-easy---bitwisdom/</link>
      <pubDate>Sun, 12 Jul 2015 09:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2015-tco-round-2b-easy---bitwisdom/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13778&amp;amp;rd=16500
解き方 
dpで解く。
dp[現在の位置][現在が1か0か][1が最初から連続しているかのフラグ]とする。
現在のビット０になったとき、
１が最初から連続していれば１回の操作が必要で、
連続していなければ２回の操作が必要になる。
#英出張中で出れなかったが、日本だと出場しやすい時間だったので出たかった…
コード 
class Bitwisdom {
public: double expectedActions(vector&amp;lt;int&amp;gt; p) {
int n=p.size();
double dp[301][2][2];
memset(dp,0,sizeof(dp));
double ret=0;
dp[0][0][0]=(100-p[0])*0.01;
dp[0][1][1]=p[0]*0.01;
for(int i=1;i&amp;lt;n;i++){
ret+=dp[i-1][1][0]*(100-p[i])*0.02;
ret+=dp[i-1][1][1]*(100-p[i])*0.01;
dp[i][0][0]+=dp[i-1][0][0]*(100-p[i])*0.01;
dp[i][0][0]+=dp[i-1][1][0]*(100-p[i])*0.01;
dp[i][0][0]+=dp[i-1][1][1]*(100-p[i])*0.01;
dp[i][1][0]+=dp[i-1][0][0]*p[i]*0.01;
dp[i][1][0]+=dp[i-1][1][0]*p[i]*0.01;
dp[i][1][1]+=dp[i-1][1][1]*p[i]*0.01;
}
ret+=dp[n-1][1][1]+dp[n-1][1][0];
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 588 DIV1 Easy - GUMIAndSongsDiv1</title>
      <link>https://chaingng.github.io/post/srm-588-div1-easy---gumiandsongsdiv1/</link>
      <pubDate>Sun, 31 May 2015 13:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-588-div1-easy---gumiandsongsdiv1/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12706&amp;amp;rd=15700
解き方 
どの範囲のトーンを利用するか、という情報がわかれば
あとはその範囲内のトーンについてdurationが小さい順に選んでいけばよい。
コード 
class GUMIAndSongsDiv1 {
public: int maxSongs(vector&amp;lt;int&amp;gt; duration, vector&amp;lt;int&amp;gt; tone, int T) {
int n=duration.size();
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
FORE(i,0,n)p.push_back(make_pair(tone[i],duration[i]));
sort(all(p));
int ret=0;
FORE(i,0,n)FORE(j,i,n){
vector&amp;lt;int&amp;gt; vx;
for(int k=i;k&amp;lt;=j;k++)vx.push_back(p[k].second);
sort(all(vx));
int tt=T-(p[j].first-p[i].first);
for(int k=0;k&amp;lt;vx.size();k++){
tt-=vx[k];
if(tt&amp;lt;0)break;
ret=max(ret,k+1);
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 592 DIV1 Easy - LittleElephantAndBalls</title>
      <link>https://chaingng.github.io/post/srm-592-div1-easy---littleelephantandballs/</link>
      <pubDate>Sun, 31 May 2015 13:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-592-div1-easy---littleelephantandballs/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12758&amp;amp;rd=15704
解き方 
問題文を、最終的にボールを置いた位置の状態にすると勘違いしてしまった。
ボールが左から順に与えられて、それを任意の位置に配置する、という
問題になる。
RGBそれぞれについて最初に出た時は左側に、次に出た時は右側においていけば
各色についてスコアは最初に出現した時は１、それ以降は２となる。
コード 
class LittleElephantAndBalls {
public: int getNumber(string S) {
int ret=0;
int r=0,g=0,b=0;
FORE(i,0,S.size()){
ret+=min(r,2)+min(g,2)+min(b,2);
if(S[i]==&#39;R&#39;)r++;
else if(S[i]==&#39;G&#39;)g++;
else b++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 589 DIV1 Easy - GooseTattarrattatDiv1 ○</title>
      <link>https://chaingng.github.io/post/srm-589-div1-easy---goosetattarrattatdiv1-/</link>
      <pubDate>Sun, 31 May 2015 13:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-589-div1-easy---goosetattarrattatdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12730&amp;amp;rd=15701
解き方 
回文にするために一致させなければならアルファベットの集合を考えた時、
もっとも出現回数の大きいものだけを残して、他を変換するのが
一番コストをおさえられる。
あとは、上記の集合をしらべるのに無向グラフを利用すればよい。
コード 
class GooseTattarrattatDiv1 {
public: int getmin(string S) {
int n=S.size();
int d[26][26],num[26],used[26];
memset(num,0,sizeof(num));
FORE(i,0,n)num[S[i]-&#39;a&#39;]++;
memset(d,0,sizeof(d));
for(int i=0;i&amp;lt;n/2;i++){
d[S[i]-&#39;a&#39;][S[n-1-i]-&#39;a&#39;]=1;
d[S[n-1-i]-&#39;a&#39;][S[i]-&#39;a&#39;]=1;
}
FORE(k,0,26)FORE(i,0,26)FORE(j,0,26)d[i][j]|=(d[i][k] &amp;amp;&amp;amp; d[k][j]);
int ret=0;
memset(used,0,sizeof(used));
FORE(i,0,26)if(!used[i]){
used[i]=1;
int sum=num[i],mx=num[i];
FORE(j,0,26)if(i!=j &amp;amp;&amp;amp; d[i][j]){
mx=max(mx,num[j]);
sum+=num[j];
used[j]=1;
}
ret+=sum-mx;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 587 DIV1 Easy - JumpFurther ○</title>
      <link>https://chaingng.github.io/post/srm-587-div1-easy---jumpfurther-/</link>
      <pubDate>Sun, 31 May 2015 13:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-587-div1-easy---jumpfurther-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12300&amp;amp;rd=15699
解き方 
最初はすべてのターンでジャンプし、そのときbadStepに当たらなければ
それが最大の答えとなる。
badStepにあたった時、最初の１ステップだけ待てばbadStepに当たらなくなるので
それが答えになる。
コード 
class JumpFurther {
public: int furthest(int N, int badStep) {
int valid=1;
int cur=0;
for(int i=1;i&amp;lt;=N;i++){
cur+=i;
if(cur==badStep)valid=0;
}
if(valid)return cur;
cur=0;
for(int i=2;i&amp;lt;=N;i++){
cur+=i;
}
return cur;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 590 DIV1 Easy - FoxAndChess ○</title>
      <link>https://chaingng.github.io/post/srm-590-div1-easy---foxandchess-/</link>
      <pubDate>Sun, 31 May 2015 13:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-590-div1-easy---foxandchess-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12725&amp;amp;rd=15702
解き方 
左にある要素から順に、
①アルファベットが一致するか
②Lならばbeginの方が右側にあるか
③Rならばbeginの方が左側にあるか
を調べていき、すべて満たすかどうかを判定すれば良い。
コード 
class FoxAndChess {
public: string ableToMove(string begin, string target) {
int n=begin.size();
while(1){
int finish=1;
FORE(i,0,n)if(begin[i]!=&#39;.&#39; || target[i]!=&#39;.&#39;)finish=0;
if(finish)break;
int idx1=-1,idx2=-1;
char ch1=&#39;*&#39;,ch2=&#39;*&#39;;
FORE(i,0,n)if(begin[i]!=&#39;.&#39;){
ch1=begin[i],idx1=i;
break;
}
FORE(i,0,n)if(target[i]!=&#39;.&#39;){
ch2=target[i],idx2=i;
break;
}
if(ch1!=ch2)return &#34;Impossible&#34;;
if(ch1==&#39;L&#39; &amp;amp;&amp;amp; idx1&amp;lt;idx2)return &#34;Impossible&#34;;
if(ch1==&#39;R&#39; &amp;amp;&amp;amp; idx1&amp;gt;idx2)return &#34;Impossible&#34;;
begin[idx1]=&#39;.&#39;,target[idx2]=&#39;.&#39;;
}
return &#34;Possible&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 552 DIV1 Easy - FoxPaintingBalls</title>
      <link>https://chaingng.github.io/post/srm-552-div1-easy---foxpaintingballs/</link>
      <pubDate>Sat, 30 May 2015 19:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-552-div1-easy---foxpaintingballs/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12146&amp;amp;rd=15174
解き方 
法則を導き出しても解けるが、少し複雑なことに気づけば
2分探索するのが確実。
N=1のときは必要なボールの数の計算が例外値となるので別に判定するのに注意。
コード 
class FoxPaintingBalls {
public: long long theMax(long long R, long long G, long long B, int N) {
if(N==1)return R+G+B;
long long sum=(long long)N*(N+1)/2LL;
long long one=(long long)N*(N+1)/6LL;
if((N%3)!=1){
return min(R,min(G,B))/one;
}
long long low=0,high=max(R,max(G,B));
while(high-low&amp;gt;1){
long long mid=(low+high)/2LL;
if( min(R,min(G,B))/one&amp;gt;=mid &amp;amp;&amp;amp; (R+G+B)/sum&amp;gt;=mid)low=mid;
else high=mid;
}
return low;
/*if(N==1)return R+G+B;
long long num=(long long)N*(N+1)/6;
if(N%3==1)return min(min(R,min(G,B))/num,(R+G+B)/((long long)N*(N+1)/2) );
return min(R,min(G,B))/num ;*/</description>
    </item>
    
    <item>
      <title>SRM 514 DIV1 Easy - MagicalGirlLevelOneDivOne</title>
      <link>https://chaingng.github.io/post/srm-514-div1-easy---magicalgirllevelonedivone/</link>
      <pubDate>Fri, 29 May 2015 22:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-514-div1-easy---magicalgirllevelonedivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11476&amp;amp;rd=14539
解き方 
(1,n)と(1,-n)の動作により現在のマスから２つ上下に移動したマスには
必ず到達することができる。
ここで、jumpTypesが偶数のとき、（ｘ，ｙ）が
（偶数、偶数）→上記より可能　（奇数、奇数）→(1,n) (n,1)により可能
（偶数、奇数）→(n,1)により可能
よってすべての（ｘ，ｙ）に到達可能。
jumpTypesが奇数のときは、
（偶数、偶数）→上記より可能　（奇数、奇数）→(1,n) により可能
（偶数、奇数）→不可能
よって（ｘ，ｙ）が（偶数、奇数）のときだけ不可能となる。

コード 
class MagicalGirlLevelOneDivOne {
public: string isReachable(vector&amp;lt;int&amp;gt; jumpTypes, int x, int y) {
int n=jumpTypes.size();
FORE(i,0,n)if(jumpTypes[i]%2==0)return &#34;YES&#34;;
if((x+y)%2==0)return &#34;YES&#34;;
return &#34;NO&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 540 DIV1 Easy - ImportantSequence</title>
      <link>https://chaingng.github.io/post/srm-540-div1-easy---importantsequence/</link>
      <pubDate>Wed, 27 May 2015 20:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-540-div1-easy---importantsequence/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11842&amp;amp;rd=14732
解き方 
上限と下限を決めるのに、最初の数字は増加列になる。
a(i)=s*a0+t、(初項はs=1,t=0)とする。
+が現れた時、そのときの数字B[i]について
a(i)+a(i+1)=B[i]となるので
a(i+1)=-s*a0+B[i]-tとなり、このとき切片が上限となる。
同様に-が現れた時、a(i)-a(i+1)=B[i]から
a(i+1)=s*a0+t-B[i]となり、このとき切片が下限となる。
以上の条件を満たしていくことで上下限が求められる。
コード 
class ImportantSequence {
public: int getCount(vector&amp;lt;int&amp;gt; B, string operators) {
int n=B.size();
long long s=1,t=0;
long long low=0,high=LONG_MAX;
FORE(i,0,n+1){
if(s==1){
low=max(low,-t);
}else{
high=min(high,t);
}
if(i==n)break;
if(operators[i]==&#39;+&#39;){
s*=-1;
t=B[i]-t;
}else{
t=t-B[i];
}
}
if(high==LONG_MAX)return -1;
if(low&amp;gt;=high)return 0;
return high-low-1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 464 DIV1 Easy - ColorfulStrings xx</title>
      <link>https://chaingng.github.io/post/srm-464-div1-easy---colorfulstrings-xx/</link>
      <pubDate>Wed, 27 May 2015 20:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-464-div1-easy---colorfulstrings-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10724&amp;amp;rd=14149
解き方 
Nは５０だが、同じ数字が２度出現すると条件を満たさないので
N=10までであれば全探索可能。
DFSでこれまで出現した数字をカウントし、有効であればカウントしていき
K番目のものが答えになる。
コード 
int was[11111111],n,k;
string ret,s;
class ColorfulStrings {
public:
void rec(int at){
if(at==n){
k--;
if(k==0)ret=s;
return;
}
for(char ch=&#39;0&#39;;ch&amp;lt;=&#39;9&#39;;ch++){
s+=ch;
int ok=1,p=1;
for(int i=at;i&amp;gt;=0;i--){
p*=s[i]-&#39;0&#39;;
if(was[p])ok=0;
was[p]++;
}
if(ok)rec(at+1);
p=1;
for(int i=at;i&amp;gt;=0;i--){
p*=s[i]-&#39;0&#39;;
was[p]--;
}
s=s.substr(0,s.size()-1);
}
}
string getKth(int nn, int kk) {
n=nn,k=kk;
if(n&amp;gt;10)return &#34;&#34;;
memset(was,0,sizeof(was));
ret=&#34;&#34;,s=&#34;&#34;;
rec(0);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 527 DIV1 Easy - P8XGraphBuilder</title>
      <link>https://chaingng.github.io/post/srm-527-div1-easy---p8xgraphbuilder/</link>
      <pubDate>Wed, 27 May 2015 20:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-527-div1-easy---p8xgraphbuilder/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11308&amp;amp;rd=14552
解き方 
ｄｐで解く。最終的に２＊ｎ−２個のエッジが発生する。
コード 
class P8XGraphBuilder {
public: int solve(vector&amp;lt;int&amp;gt; scores) {
int n=scores.size()+1;
int dp[n+1][2*n-1];
FORE(i,0,n+1)FORE(j,0,2*n-1)dp[i][j]=-(1e+9);
dp[0][0]=0;
for(int i=0;i&amp;lt;n;i++)for(int j=i;j&amp;lt;2*n-2;j++){
for(int k=0;k&amp;lt;n-1&amp;amp;&amp;amp;j+k+1&amp;lt;=2*n-2;k++){
dp[i+1][j+k+1]=max(dp[i+1][j+k+1],dp[i][j]+scores[k]);
}
}
return dp[n][2*n-2];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 539 DIV1 Easy - Over9000Rocks</title>
      <link>https://chaingng.github.io/post/srm-539-div1-easy---over9000rocks/</link>
      <pubDate>Wed, 27 May 2015 16:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-539-div1-easy---over9000rocks/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11855&amp;amp;rd=14731
解き方 
９０００以上となる数をすべて保存しては間に合わないので、
その始点と終点のみ保存してあげて、その間の範囲を計算していくことで
メモリ、計算量ともに制限内で解くことができる。
コード 
pair&amp;lt;int,int&amp;gt; p[1000000];
class Over9000Rocks {
public: int countPossibilities(vector&amp;lt;int&amp;gt; lowerBound, vector&amp;lt;int&amp;gt; upperBound) {
int n=lowerBound.size();
int m=0;
for(int mask=1;mask&amp;lt;(1&amp;lt;&amp;lt;n);mask++){
int minx=0,maxx=0;
FORE(i,0,n)if(mask&amp;amp;(1&amp;lt;&amp;lt;i)){
minx+=lowerBound[i];
maxx+=upperBound[i];
}
minx=max(minx,9001);
if(minx&amp;lt;=maxx){
p[m++]=make_pair(minx,1);
p[m++]=make_pair(maxx+1,-1);
}
}
sort(p,p+m);
int ret=0,cur=0;
FORE(i,0,m){
cur+=p[i].second;
if(cur!=0)ret+=p[i+1].first-p[i].first;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 576 DIV1 Easy - ArcadeManao</title>
      <link>https://chaingng.github.io/post/srm-576-div1-easy---arcademanao/</link>
      <pubDate>Wed, 27 May 2015 16:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-576-div1-easy---arcademanao/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12504&amp;amp;rd=15496
解き方 
各はしごの数について昇順で調べることができる。
通常の経路探索に、はしごの長さを考慮すればよい。
コード 
class ArcadeManao {
public:
int shortestLadder(vector&amp;lt;string&amp;gt; level, int coinRow, int coinColumn) {
int h=level.size(),w=level[0].size();
int used[h][w];
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
for(int len=0;len&amp;lt;50;len++){
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
q.push(make_pair(h-1,0));
memset(used,0,sizeof(used));
used[h-1][0]=1;
while(!q.empty()){
int r=q.front().first,c=q.front().second;
q.pop();
FORE(i,0,4)for(int j=0;j&amp;lt;=len;j++){
int nr=r+dx[i]*j,nc=c+dy[i];
if(0&amp;lt;=nr &amp;amp;&amp;amp; nr&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=nc &amp;amp;&amp;amp; nc&amp;lt;w &amp;amp;&amp;amp; !used[nr][nc] &amp;amp;&amp;amp; level[nr][nc]==&#39;X&#39;){
used[nr][nc]=1;
q.push(make_pair(nr,nc));
}
}
}
if(used[coinRow-1][coinColumn-1])return len;
}
return 50;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 579 DIV1 Easy - UndoHistory ○</title>
      <link>https://chaingng.github.io/post/srm-579-div1-easy---undohistory-/</link>
      <pubDate>Wed, 27 May 2015 16:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-579-div1-easy---undohistory-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12523&amp;amp;rd=15499
解き方 
前の文字列からそのまま続けられる時はその場合と、
以前の部分文字列を使う場合のうち最小のものを採用していけばよい。
コード 
class UndoHistory {
public: int minPresses(vector&amp;lt;string&amp;gt; lines) {
int n=lines.size();
int ret=n;
string prev=&#34;&#34;;
FORE(i,0,n){
int cost=1e+9;
if(prev.size()&amp;lt;=lines[i].size()){
int valid=1;
FORE(j,0,prev.size())if(prev[j]!=lines[i][j])valid=0;
if(valid)cost=min(cost,(int)lines[i].size()-(int)prev.size());
}
FORE(j,0,i){
int tmp=0;
for(int k=0;k&amp;lt;lines[i].size() &amp;amp;&amp;amp; k&amp;lt;lines[j].size();k++){
if(lines[i][k]==lines[j][k])tmp++;
else break;
}
cost=min(cost,(int)lines[i].size()-tmp+2);
}
ret+=cost;
prev=lines[i];
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 577 DIV1 Easy - EllysRoomAssignmentsDiv1 x</title>
      <link>https://chaingng.github.io/post/srm-577-div1-easy---ellysroomassignmentsdiv1-x/</link>
      <pubDate>Wed, 27 May 2015 16:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-577-div1-easy---ellysroomassignmentsdiv1-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12514&amp;amp;rd=15497
解き方 
部屋の数Rから、部屋への割り当てが行われる回数Kが決まる。
K回の割り当てのうち、
自分が割り当てられる場合はその他のメンバーは関係なく、
また最後の割り当てのときはすべての部屋ではなく、ランダムに部屋へ割り当てられるので別に値を保持しておく。
最後に、自分が最後の割り当てであれば部屋の人数はK人だけを考えればよく、
そうでなければK-1人となる確率pの期待値とK人である1-pの期待値の和が答えとなる。
コード 
class EllysRoomAssignmentsDiv1 {
public: double getAverage(vector&amp;lt;string&amp;gt; ratings) {
int rates[1010],N=0;
string input=accumulate(all(ratings),string());
stringstream out(input);
for(;out&amp;gt;&amp;gt;rates[N];)N++;
int my=rates[0];
sort(rates,rates+N,greater&amp;lt;int&amp;gt;());
int me=lower_bound(rates,rates+N,my,greater&amp;lt;int&amp;gt;())-rates;
int R=(N+19)/20;
int K=(N+R-1)/R;
double sum=0,add=0;
for(int i=0;i&amp;lt;K;i++){
if(R*i&amp;lt;=me &amp;amp;&amp;amp; me&amp;lt;R*(i+1)){
sum+=rates[me];
}else if(i==K-1){
double tmp=0.0;
for(int j=R*i;j&amp;lt;N;j++)tmp+=rates[j];
add+=tmp/(N-R*i);
}else{
double tmp=0.0;
for(int j=R*i;j&amp;lt;R*(i+1);j++)tmp+=rates[j];
sum+=tmp/R;
}
}
double p=(R*K-N)/(double)R;
if(R*(K-1)&amp;lt;=me)p=0;
double ret=0;
if(p&amp;gt;0)ret+=p*(sum/(K-1));
ret+=(1-p)*((sum+add)/K);
return ret;
}</description>
    </item>
    
    <item>
      <title>SRM 581 DIV1 Easy - SurveillanceSystem</title>
      <link>https://chaingng.github.io/post/srm-581-div1-easy---surveillancesystem/</link>
      <pubDate>Wed, 27 May 2015 16:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-581-div1-easy---surveillancesystem/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12588&amp;amp;rd=15501
解き方 
監視してる数ごとに、どのような場合が成り立つか考える。
その監視している数について、成り立つすべての場合をall、カメラの数をcntとすると
all-cnt以上その場合の数が存在した時は必ず＋となり、１位上であれば？となる。
コード 
class SurveillanceSystem {
public: string getContainerInfo(string containers, vector&amp;lt;int&amp;gt; reports, int L) {
int n=containers.size();
string ret=&#34;&#34;;
FORE(i,0,n)ret+=&#39;-&#39;;
int p[n];
for(int i=0;i&amp;lt;=n;i++){
int cnt=0;
FORE(j,0,reports.size())if(reports[j]==i)cnt++;
if(cnt==0)continue;
int all=0;
memset(p,0,sizeof(p));
for(int j=0;j+L-1&amp;lt;n;j++){
int tmp=0;
FORE(k,0,L)if(containers[j+k]==&#39;X&#39;)tmp++;
if(tmp==i){
all++;
FORE(k,0,L)p[j+k]++;
}
}
FORE(j,0,n){
if(p[j]==0)continue;
if(cnt&amp;gt;all-p[j])ret[j]=&#39;+&#39;;
else if(ret[j]==&#39;-&#39;)ret[j]=&#39;?&#39;;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 568 DIV1 Easy - BallsSeparating</title>
      <link>https://chaingng.github.io/post/srm-568-div1-easy---ballsseparating/</link>
      <pubDate>Mon, 25 May 2015 10:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-568-div1-easy---ballsseparating/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12398&amp;amp;rd=15488
解き方 
基本的に貪欲法だが、少なくとも各色ごとに１つは箱を用意する必要があるので
各色ひとつずつ箱を決めた場合について、貪欲法で解く。
コード 
class BallsSeparating {
public: int minOperations(vector&amp;lt;int&amp;gt; red, vector&amp;lt;int&amp;gt; green, vector&amp;lt;int&amp;gt; blue) {
int n=red.size();
int r=0,g=0,b=0;
FORE(i,0,n){
if(red[i]&amp;gt;0)r=1;
if(green[i]&amp;gt;0)g=1;
if(blue[i]&amp;gt;0)b=1;
}
if(r+g+b&amp;gt;n)return -1;
int ret=1e+9;
FORE(i,0,n)FORE(j,0,n)FORE(k,0,n)if(i!=j &amp;amp;&amp;amp; j!=k &amp;amp;&amp;amp; k!=i){
int cost=0;
FORE(l,0,n){
if(l==i)cost+=green[l]+blue[l];
else if(l==j)cost+=red[l]+blue[l];
else if(l==k)cost+=red[l]+green[l];
else{
cost+=red[l]+green[l]+blue[l]-max(red[l],max(green[l],blue[l]));
}
}
ret=min(ret,cost);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 559 DIV1 Easy - HyperKnight</title>
      <link>https://chaingng.github.io/post/srm-559-div1-easy---hyperknight/</link>
      <pubDate>Mon, 25 May 2015 10:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-559-div1-easy---hyperknight/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12201&amp;amp;rd=15181
解き方 
サンプルを表に書いて見ると、各動ける数ごとにどれだけのマスを占めるか
一意に決めることができる。ただきちんと表に落とすのがちょっと複雑。
コード 
class HyperKnight {
public: long long countCells(int a_, int b_, int numRows, int numColumns, int k) {
long long R=numRows,C=numColumns,a=a_,b=b_;
if(a&amp;lt;b)swap(a,b);
long long ans[9]={};
ans[2]=b*b*4;
ans[3]=b*(a-b)*8;
ans[6]=(R-2*a)*(a-b)*2+(C-2*a)*(a-b)*2;
ans[8]=(R-2*a)*(C-2*a);
ans[4]=R*C-ans[2]-ans[3]-ans[6]-ans[8];
return ans[k];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 542 DIV1 Easy - PatrolRoute</title>
      <link>https://chaingng.github.io/post/srm-542-div1-easy---patrolroute/</link>
      <pubDate>Wed, 20 May 2015 22:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-542-div1-easy---patrolroute/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11934&amp;amp;rd=14734
解き方 
３点を選んだ時、そのｘ座標の最小値と最大値の差、ｙ座標の最小値と最大値の差が
それぞれ１辺となる長方形の外周の長さが、たどるルートの長さになる。
あとはその長方形が与えられたセルでいくつつくれるか、
その長方形を作ることのできる点の組み合わせの数をかけてあげればよい。
コード 
class PatrolRoute {
public: int countRoutes(int X, int Y, int minT, int maxT) {
int ret=0;
int MOD=1000000007;
for(int xlen=3;xlen&amp;lt;=X;xlen++)for(int ylen=3;ylen&amp;lt;=Y;ylen++){
int len=((xlen-1)+(ylen-1))*2;
if(minT&amp;lt;=len &amp;amp;&amp;amp; len&amp;lt;=maxT){
long long sum=(xlen-2)*(ylen-2)*6;
sum=(sum*(X-xlen+1)*(Y-ylen+1))%MOD;
ret=(ret+sum)%MOD;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 541 DIV1 Easy - AntsMeet</title>
      <link>https://chaingng.github.io/post/srm-541-div1-easy---antsmeet/</link>
      <pubDate>Wed, 20 May 2015 22:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-541-div1-easy---antsmeet/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11887&amp;amp;rd=14733
解き方 
0.5単位のターンでぶつからないか試せば良い。
試す数の最大値に注意。
コード 
class AntsMeet {
public: int countAnts(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, string direction) {
int n=x.size();
double dx[]={1,0,-1,0},dy[]={0,1,0,-1};
int d[n];
FORE(i,0,n){
if(direction[i]==&#39;E&#39;)d[i]=0;
if(direction[i]==&#39;N&#39;)d[i]=1;
if(direction[i]==&#39;W&#39;)d[i]=2;
if(direction[i]==&#39;S&#39;)d[i]=3;
}
double px[n],py[n];
FORE(i,0,n){
px[i]=x[i];
py[i]=y[i];
}
int used[n];
memset(used,0,sizeof(used));
FORE(num,0,5000){
FORE(i,0,n){
px[i]+=dx[d[i]]*0.5;
py[i]+=dy[d[i]]*0.5;
}
FORE(i,0,n)if(!used[i]){
int update=0;
FORE(j,i+1,n)if(!used[j]){
if(px[i]==px[j] &amp;amp;&amp;amp; py[i]==py[j]){
used[j]=1;
update=1;
}
}
if(update)used[i]=1;
}
}
int ret=0;
FORE(i,0,n)if(used[i])ret++;
return n-ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 560 DIV1 Easy - TomekPhone</title>
      <link>https://chaingng.github.io/post/srm-560-div1-easy---tomekphone/</link>
      <pubDate>Wed, 20 May 2015 21:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-560-div1-easy---tomekphone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12296&amp;amp;rd=15182
解き方 
貪欲法で解けば良い。システムテストで落ちないように間違いの少ないような実装を
するよう気をつける。
コード 
class TomekPhone {
public: int minKeystrokes(vector&amp;lt;int&amp;gt; f, vector&amp;lt;int&amp;gt; key) {
int n=f.size();
int cnt=0;
FORE(i,0,key.size())cnt+=key[i];
if(n&amp;gt;cnt)return -1;
int ret=0,p=1;
while(1){
int finish=1;
FORE(i,0,n)if(f[i]!=0)finish=0;
if(finish)break;
sort(f.rbegin(),f.rend());
cnt=0;
FORE(i,0,key.size()){
if(key[i]&amp;gt;0)key[i]--,cnt++;
}
FORE(i,0,cnt)if(f[i%n]&amp;gt;0){
ret+=f[i%n]*p;
f[i%n]=0;
}
p++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 651 DIV1 Easy - ICPCBalloons ○</title>
      <link>https://chaingng.github.io/post/srm-651-div1-easy---icpcballoons-/</link>
      <pubDate>Wed, 20 May 2015 21:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-651-div1-easy---icpcballoons-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12314&amp;amp;rd=15183
解き方 
maxAcceptedの数は15個までなので、各問題についてMとLすべての分け方を試すことが
できる。
各分け方について、貪欲に風船を割り当てていけば最適解が求まる。
コード 
class ICPCBalloons {
public: int minRepaintings(vector&amp;lt;int&amp;gt; balloonCount, string balloonSize, vector&amp;lt;int&amp;gt; maxAccepted) {
int n=maxAccepted.size();
vector&amp;lt;int&amp;gt; m,l;
int allm=0,alll=0;
FORE(i,0,balloonCount.size()){
if(balloonSize[i]==&#39;M&#39;){
m.push_back(balloonCount[i]);
allm+=balloonCount[i];
}else{
l.push_back(balloonCount[i]);
alll+=balloonCount[i];
}
}
sort(m.rbegin(),m.rend());
sort(l.rbegin(),l.rend());
int ret=1e+9;
for(int mask=0;mask&amp;lt;(1&amp;lt;&amp;lt;n);mask++){
vector&amp;lt;int&amp;gt; cm,cl;
int cntm=0,cntl=0;
FORE(i,0,n){
if(mask&amp;amp;(1&amp;lt;&amp;lt;i)){
cm.push_back(maxAccepted[i]);
cntm+=maxAccepted[i];
}else{
cl.push_back(maxAccepted[i]);
cntl+=maxAccepted[i];
}
}
if(allm&amp;lt;cntm || alll&amp;lt;cntl)continue;
int cost=0;
sort(cm.rbegin(),cm.rend());
sort(cl.rbegin(),cl.rend());
FORE(i,0,cm.size()){
int cur= i&amp;gt;=m.size() ? 0 : m[i];</description>
    </item>
    
    <item>
      <title>SRM 538 DIV1 Easy - EvenRoute</title>
      <link>https://chaingng.github.io/post/srm-538-div1-easy---evenroute/</link>
      <pubDate>Sun, 17 May 2015 13:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-538-div1-easy---evenroute/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11808&amp;amp;rd=14729
解き方 
（ｘ，ｙ）の合計が奇数の座標と偶数の座標が存在すれば、どちらにもできるので
答えは必ずYESになる。
そうでない場合はそれぞれ奇数のみ、偶数のみのルートとなる。
コード 
class EvenRoute {
public: string isItPossible(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int wantedParity) {
int n=x.size();
int odd=0,even=0;
FORE(i,0,n){
if((x[i]+y[i])%2==0)even++;
else odd++;
}
if(even &amp;amp;&amp;amp; odd)return &#34;CAN&#34;;
if(even&amp;gt;0 &amp;amp;&amp;amp; wantedParity==0)return &#34;CAN&#34;;
if(odd&amp;gt;0 &amp;amp;&amp;amp; wantedParity==1)return &#34;CAN&#34;;
return &#34;CANNOT&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 537 DIV1 Easy - KingXNewCurrency</title>
      <link>https://chaingng.github.io/post/srm-537-div1-easy---kingxnewcurrency/</link>
      <pubDate>Sun, 17 May 2015 13:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-537-div1-easy---kingxnewcurrency/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11817&amp;amp;rd=14730
解き方 
A，B自身をXとYで表せられるような整数を求めれば良い。
どちらもXで割り切れるならばYが不要になるので−１となる。
コード 
class KingXNewCurrency {
public: int howMany(int A, int B, int X) {
if(A%X==0 &amp;amp;&amp;amp; B%X==0)return -1;
set&amp;lt;int&amp;gt; s1,s2;
for(int i=0;i&amp;lt;A;i+=X)for(int j=1;j&amp;lt;=A-i;j++){
if((A-i)%j==0)s1.insert(j);
}
for(int i=0;i&amp;lt;B;i+=X)for(int j=1;j&amp;lt;=B-i;j++){
if((B-i)%j==0)s2.insert(j);
}
if(A%X==0)return s2.size();
if(B%X==0)return s1.size();
int ret=0;
for(set&amp;lt;int&amp;gt;::iterator it=s1.begin();it!=s1.end();it++){
if(s2.find(*it)!=s2.end())ret++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 545 DIV1 Easy - StrIIRec</title>
      <link>https://chaingng.github.io/post/srm-545-div1-easy---striirec/</link>
      <pubDate>Sun, 17 May 2015 13:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-545-div1-easy---striirec/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12025&amp;amp;rd=14737
解き方 
貪欲法で、左のアルファベットから決めていけば良い。
決めていく材料として、
あるアルファベットを固定した時に最大のminInvが指定した値以上になり、
かつつくることのできる最も降順の文字列が与えられた文字列よりも大きければ良い。
コード 
class StrIIRec {
public: string recovstr(int n, int minInv, string minStr) {
int used[n];
memset(used,0,sizeof(used));
string ret=&#34;&#34;;
int cnt=0;
for(int i=0;i&amp;lt;n;i++){
for(int j=0;j&amp;lt;n;j++)if(used[j]==0){
string tmp=ret;
tmp+=&#39;a&#39;+j;
for(int k=n-1;k&amp;gt;=0;k--)if(!used[k] &amp;amp;&amp;amp; k!=j)tmp+=&#39;a&#39;+k;
if(tmp&amp;lt;minStr)continue;
int cost=cnt;
for(int k=0;k&amp;lt;j;k++)if(!used[k])cost++;
used[j]=1;
for(int k=n-1;k&amp;gt;=0;k--)if(!used[k]){
for(int l=k-1;l&amp;gt;=0;l--)if(!used[l])cost++;
}
if(cost&amp;lt;minInv){
used[j]=0;
continue;
}
ret+=&#39;a&#39;+j;
for(int k=0;k&amp;lt;j;k++)if(!used[k])cnt++;
break;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 549 DIV1 Easy - PointyWizardHats xx</title>
      <link>https://chaingng.github.io/post/srm-549-div1-easy---pointywizardhats-xx/</link>
      <pubDate>Sun, 17 May 2015 13:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-549-div1-easy---pointywizardhats-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11965&amp;amp;rd=15171
解き方 
上に載せるハットと下に載せるハットの組み合わせに分かれるので、
二部マッチングの問題に帰着できる。
最大フローアルゴリズムを用いれば良い。
コード 
int d[60][60];
int a[60],b[60],used[60];
int n,m;
class PointyWizardHats {
public:
bool ispossible(int th,int tr,int bh,int br){
return tr&amp;lt;br &amp;amp;&amp;amp; th*br&amp;gt;bh*tr;
}
bool dfs(int x){
if(x==-1)return true;
if(used[x])return false;
used[x]=1;
FORE(i,0,m){
if(d[x][i]){
if(dfs(b[i])){
a[x]=i;
b[i]=x;
return true;
}
}
}
return false;
}
int getNumHats(vector&amp;lt;int&amp;gt; topHeight, vector&amp;lt;int&amp;gt; topRadius, vector&amp;lt;int&amp;gt; bottomHeight, vector&amp;lt;int&amp;gt; bottomRadius) {
n=topHeight.size(),m=bottomHeight.size();
memset(d,0,sizeof(d));
FORE(i,0,n)FORE(j,0,m){
d[i][j]=ispossible(topHeight[i],topRadius[i],bottomHeight[j],bottomRadius[j]);
}
memset(a,-1,sizeof(a));
memset(b,-1,sizeof(b));
int ret=0;</description>
    </item>
    
    <item>
      <title>SRM 548 DIV1 Easy - KingdomAndTrees</title>
      <link>https://chaingng.github.io/post/srm-548-div1-easy---kingdomandtrees/</link>
      <pubDate>Sun, 17 May 2015 13:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-548-div1-easy---kingdomandtrees/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11967&amp;amp;rd=15170
解き方 
二分探索を用いればよい。
０が答えのときを含ませるには、lowを-1以下に設定する必要があることに注意。
コード 
class KingdomAndTrees {
public:
bool ispossible(vector&amp;lt;int&amp;gt; h,int m){
int n=h.size();
h[0]=max(1,h[0]-m);
FORE(i,1,n){
if(h[i]+m&amp;lt;=h[i-1])return false;
h[i]=max(h[i-1]+1,h[i]-m);
}
return true;
}
int minLevel(vector&amp;lt;int&amp;gt; heights) {
long long low=-1,high=INT_MAX;
while(high-low&amp;gt;1){
int mid=(low+high)/2;
if(ispossible(heights,mid))high=mid;
else low=mid;
}
return high;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 551 DIV1 Easy - ColorfulChocolates</title>
      <link>https://chaingng.github.io/post/srm-551-div1-easy---colorfulchocolates/</link>
      <pubDate>Sun, 17 May 2015 13:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-551-div1-easy---colorfulchocolates/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12137&amp;amp;rd=15173
解き方 
各アルファベットごとに最大の連続数を考え、最大のものを求める。
あるアルファベットについて最大の連続数を考えるとき、
どれか１つのアルファベットの位置は変わらないことを利用する。
よって、すべての位置を起点にして同じアルファベット結合させ、
そのスワップ回数がmaxswap数以下のときの連続数をそれぞれとっていけばよい。
コード 
class ColorfulChocolates {
public: int maximumSpread(string chocolates, int maxSwaps) {
int n=chocolates.size();
int ret=0;
for(char ch=&#39;A&#39;;ch&amp;lt;=&#39;Z&#39;;ch++){
vector&amp;lt;int&amp;gt; vx;
FORE(i,0,n)if(ch==chocolates[i])vx.push_back(i);
FORE(i,0,vx.size()){
vector&amp;lt;int&amp;gt; tmp;
FORE(j,0,vx.size())tmp.push_back(abs(vx[i]-vx[j]-(i-j)));
sort(all(tmp));
int sum=0,num=0;
FORE(j,0,vx.size()){
if(sum+tmp[j]&amp;lt;=maxSwaps){
num++;
sum+=tmp[j];
}
}
ret=max(ret,num);
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 550 DIV1 Easy - RotatingBot</title>
      <link>https://chaingng.github.io/post/srm-550-div1-easy---rotatingbot/</link>
      <pubDate>Sun, 17 May 2015 13:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-550-div1-easy---rotatingbot/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12033&amp;amp;rd=15172
解き方 
メモリも計算量も足りるので、正しく間違えないように実装すればよい。
コード 
int p[1300][1300];
class RotatingBot {
public: int minArea(vector&amp;lt;int&amp;gt; moves) {
int n=moves.size();
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
memset(p,0,sizeof(p));
int minx=650,miny=650,maxx=650,maxy=650;
int x=650,y=650,d=0;
FORE(i,0,n){
FORE(j,0,moves[i]){
int nx=x+dx[d],ny=y+dy[d];
x=nx,y=ny;
minx=min(minx,x);
maxx=max(maxx,x);
miny=min(miny,y);
maxy=max(maxy,y);
}
d=(d+1)%4;
}
x=650,y=650,d=0;
p[x][y]=1;
FORE(i,0,n){
FORE(j,0,moves[i]){
int nx=x+dx[d],ny=y+dy[d];
if(p[nx][ny]==1)return -1;
x=nx,y=ny;
p[x][y]=1;
}
int xx=x+dx[d],yy=y+dy[d];
if(!(xx&amp;lt;minx || xx&amp;gt;maxx || yy&amp;lt;miny || yy&amp;gt;maxy || p[xx][yy]==1 || i==n-1)){
return -1;
}
d=(d+1)%4;
}
return (maxx-minx+1)*(maxy-miny+1);</description>
    </item>
    
    <item>
      <title>SRM 553 DIV1 Easy - Suminator</title>
      <link>https://chaingng.github.io/post/srm-553-div1-easy---suminator/</link>
      <pubDate>Sun, 17 May 2015 13:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-553-div1-easy---suminator/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11354&amp;amp;rd=15175
解き方 
プログラムをスタックで実行し、０，１，２で出力させ
０で出力した時に求める値と一致すれば０，
１，２を出力させた時に出力が同じで、求める答えと違えば−１，
出力が求める答えよりも小さければ差分を足すことで答えが求められる。
intでは和がフローしてしまうのでlong long型を用いる。
コード 
class Suminator {
public:
long long rec(vector&amp;lt;int&amp;gt; program,int x){
stack&amp;lt;long long&amp;gt; s;
FORE(i,0,program.size()){
if(program[i]==-1)program[i]=x;
if(program[i]==0){
long long a=0,b=0;
if(!s.empty()){
a=s.top();
s.pop();
}
if(!s.empty()){
b=s.top();
s.pop();
}
s.push(a+b);
}else{
s.push(program[i]);
}
}
return s.empty() ? 0 : s.top();
}
int findMissing(vector&amp;lt;int&amp;gt; program, int wantedResult) {
if(rec(program,0)==wantedResult)return 0;
long long x=rec(program,1);
long long y=rec(program,2);
if(x==wantedResult)return 1;
if(x==y || x&amp;gt;wantedResult)return -1;</description>
    </item>
    
    <item>
      <title>SRM 555 DIV1 Easy - CuttingBitString</title>
      <link>https://chaingng.github.io/post/srm-555-div1-easy---cuttingbitstring/</link>
      <pubDate>Sun, 17 May 2015 13:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-555-div1-easy---cuttingbitstring/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12155&amp;amp;rd=15177
解き方 
ｄｐで解く。ｎは５０なので整数の最大は2^50=10^15程度なのでlong longで
表すことができる。
コード 
class CuttingBitString {
public:
bool ispossible(string s){
if(s[0]==&#39;0&#39;)return false;
int n=s.size();
long long ret=0,p=1;
for(int i=n-1;i&amp;gt;=0;i--){
ret+=(s[i]-&#39;0&#39;)*p;
p*=2;
}
if(ret==0)return false;
while(ret%5==0 &amp;amp;&amp;amp; ret&amp;gt;0)ret/=5;
return ret==1;
}
int getmin(string S) {
int n=S.size();
int dp[n+1];
FORE(i,0,n+1)dp[i]=1e+9;
dp[0]=0;
for(int i=0;i&amp;lt;=n;i++){
for(int j=0;j&amp;lt;=i;j++)if(dp[j]!=1e+9){
if(ispossible(S.substr(j,i-j+1))){
dp[i+1]=min(dp[i+1],dp[j]+1);
}
}
}
return dp[n]==1e+9 ? -1 : dp[n];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 526.5 DIV1 Easy - MagicCandy x</title>
      <link>https://chaingng.github.io/post/srm-526.5-div1-easy---magiccandy-x/</link>
      <pubDate>Wed, 13 May 2015 09:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-526.5-div1-easy---magiccandy-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11706&amp;amp;rd=14762
解き方 
普通に計算していては間に合わない。
例えば２０個のキャンディーからは
20-4=16→16-4=12→12-3=9→9-3=6→6-2=4→4-2=2→2-1=1となり、
この操作を逆にたどれば計算量が間に合う。
つまり、ある数からそのsqrtを引かれると次の数になる計算式を
逆にたどっていけばよい。
コード 
class MagicCandy {
public:
int rec(int n){
if(n==1)return 1;
int candy=rec(n-(int)sqrt(n));
int low=1,high=n;
while(low&amp;lt;high){
int mid=(low+high)/2;
if(mid-(int)sqrt(mid)&amp;gt;=candy)high=mid;
else low=mid+1;
}
return high;
}
int whichOne(int n) {
return rec(n);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 516 DIV1 Easy - NetworkXOneTimePad</title>
      <link>https://chaingng.github.io/post/srm-516-div1-easy---networkxonetimepad/</link>
      <pubDate>Mon, 11 May 2015 23:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-516-div1-easy---networkxonetimepad/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10846&amp;amp;rd=14541
解き方 
すべての暗号前の文字と暗号後の文字の組み合わせで、候補となる
キーがすべて作成できる。
あるキーについて、暗号後の文字を復号した時に暗号前の文字がすべて存在すれば
有効なので、上記で生成した全てのキーに対してこの条件が成り立つか判定すればよい。
コード 
class NetworkXOneTimePad {
public:
string calc(string s1,string s2){
string ret=&#34;&#34;;
FORE(i,0,s1.size()){
ret+= s1[i]==s2[i] ? &#39;0&#39; : &#39;1&#39;;
}
return ret;
}
int crack(vector&amp;lt;string&amp;gt; plaintexts, vector&amp;lt;string&amp;gt; ciphertexts) {
int n=plaintexts.size(),m=ciphertexts.size();
set&amp;lt;string&amp;gt; s;
FORE(i,0,n)FORE(j,0,m){
s.insert(calc(plaintexts[i],ciphertexts[j]));
}
set&amp;lt;string&amp;gt; ans;
for(set&amp;lt;string&amp;gt;::iterator it=s.begin();it!=s.end();it++){
int valid=1;
FORE(i,0,m){
string tmp=calc(*it,ciphertexts[i]);
int invalid=1;
FORE(j,0,n)if(tmp==plaintexts[j])invalid=0;
if(invalid)valid=0;
}
if(valid)ans.insert(*it);
}
return ans.size();
}
}; </description>
    </item>
    
    <item>
      <title>SRM 500 DIV1 Easy - MafiaGame x</title>
      <link>https://chaingng.github.io/post/srm-500-div1-easy---mafiagame-x/</link>
      <pubDate>Sun, 10 May 2015 21:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-500-div1-easy---mafiagame-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11342&amp;amp;rd=14429
解き方 
投票数が一番多い人が最後に残る候補となる。
よってそれがX人だとすると、最後に１人残るのであれば
確率は1/Xとなる。
最後に一人残るかどうかの判定は、NをX人で割った余りを更新していき
割り切れるのであれば全員消滅してしまうので答えは０になる。
最後に１人残れば上記の確率を返す。
コード 
class MafiaGame {
public: double probabilityToLose(int N, vector&amp;lt;int&amp;gt; decisions) {
map&amp;lt;int,int&amp;gt; m;
FORE(i,0,decisions.size())m[decisions[i]]++;
int mx=0,cnt=0;
for(map&amp;lt;int,int&amp;gt;::iterator it=m.begin();it!=m.end();it++){
mx=max(mx,it-&amp;gt;second);
}
for(map&amp;lt;int,int&amp;gt;::iterator it=m.begin();it!=m.end();it++){
if(mx==it-&amp;gt;second)cnt++;
}
if(mx==1)return 0.0;
double ret=1.0/cnt;
while(cnt&amp;gt;1){
if(N%cnt==0)return 0.0;
cnt=N%cnt;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 509 DIV1 Easy - LuckyRemainder</title>
      <link>https://chaingng.github.io/post/srm-509-div1-easy---luckyremainder/</link>
      <pubDate>Sun, 10 May 2015 20:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-509-div1-easy---luckyremainder/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11138&amp;amp;rd=14438
解き方 
各桁の数は与えられた整数の桁数をNとすると、それぞれ2^(N-1)回
足されることになる。
この数を９で割った余りが答えになる。
コード 
class LuckyRemainder {
public:
int getLuckyRemainder(string X) {
long long ret=0;
FORE(i,0,X.size())ret=(ret+X[i]-&#39;0&#39;)%9;
ret*=pow(2,X.size()-1);
return ret%9;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 502 DIV1 Easy - TheLotteryBothDivs x</title>
      <link>https://chaingng.github.io/post/srm-502-div1-easy---thelotterybothdivs-x/</link>
      <pubDate>Sun, 10 May 2015 15:56:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-502-div1-easy---thelotterybothdivs-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11359&amp;amp;rd=14431
解き方 
初期配列のままで各文字列ペアについて包含しているかで判定すると
３つ以上の要素が互いに関係する場合にただしく計算できない。
そのため、ある文字列に包含できる場合はその文字列を削除することで
排他的に答えを求める。
コード 
class TheLotteryBothDivs {
public:
bool issuffix(string s1,string s2){
int n=min(s1.size(),s2.size());
FORE(i,0,n)if(s1[s1.size()-1-i]!=s2[s2.size()-1-i])return false;
return true;
}
double find(vector&amp;lt;string&amp;gt; g) {
while(1){
next:
FORE(i,0,g.size())FORE(j,i+1,g.size()){
if(issuffix(g[i],g[j])){
if(g[i].size()&amp;lt;g[j].size())swap(g[i],g[j]);
vector&amp;lt;string&amp;gt;::iterator it=g.begin();
g.erase(it+i);
goto next;;
}
}
break;
}
double ret=0;
FORE(i,0,g.size())ret+=pow(0.1,g[i].size());
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 455 DIV1 Easy - DonutsOnTheGridEasy xx</title>
      <link>https://chaingng.github.io/post/srm-455-div1-easy---donutsonthegrideasy-xx/</link>
      <pubDate>Sun, 10 May 2015 15:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-455-div1-easy---donutsonthegrideasy-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10719&amp;amp;rd=14179
解き方 
ｄｐを利用して、ある長方形を考えた時
その内部にある長方形のうち最大のものか、
それより内部にある長方形＋現在の長方形のうち最大のものを求めていく。
コード 
int dp[55][55][55][55];
class DonutsOnTheGridEasy {
public:
int calc(vector&amp;lt;string&amp;gt; grid) {
int h=grid.size(),w=grid[0].size();
memset(dp,0,sizeof(dp));
for(int hh=3;hh&amp;lt;=h;hh++)for(int ww=3;ww&amp;lt;=w;ww++){
for(int i=0;i+hh-1&amp;lt;h;i++)for(int j=0;j+ww-1&amp;lt;w;j++){
int u=i+hh-1,v=j+ww-1;
int ok=1;
FORE(k,0,ww){
if(grid[i][j+k]!=&#39;0&#39; || grid[u][j+k]!=&#39;0&#39;)ok=0;
}
FORE(k,0,hh){
if(grid[i+k][j]!=&#39;0&#39; || grid[i+k][v]!=&#39;0&#39;)ok=0;
}
dp[i][j][u][v]=ok;
dp[i][j][u][v]=max(dp[i][j][u][v],dp[i+1][j][u][v]);
dp[i][j][u][v]=max(dp[i][j][u][v],dp[i][j+1][u][v]);
dp[i][j][u][v]=max(dp[i][j][u][v],dp[i][j][u-1][v]);
dp[i][j][u][v]=max(dp[i][j][u][v],dp[i][j][u][v-1]);
dp[i][j][u][v]=max(dp[i][j][u][v],dp[i+1][j+1][u-1][v-1]+ok);
}
}
return dp[0][0][h-1][w-1];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 453 DIV1 Easy - TheBasketballDivOne</title>
      <link>https://chaingng.github.io/post/srm-453-div1-easy---thebasketballdivone/</link>
      <pubDate>Sun, 10 May 2015 14:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-453-div1-easy---thebasketballdivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10687&amp;amp;rd=13907
解き方 
全探索可能。
DFSを用いて各チームの勝ち負けについてすべて調べ、
行列の対角側についてはすでに調べているのですでに決められた値を代入して
更新していく。
コード 
int a[5][5];
set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; s;
class TheBasketballDivOne {
public:
void rec(int n,int x,int y){
if(n==x){
int b[n];
memset(b,0,sizeof(b));
FORE(i,0,n)FORE(j,0,n)b[i]+=a[i][j];
vector&amp;lt;int&amp;gt; vx;
FORE(i,0,n)vx.push_back(b[i]);
sort(vx.rbegin(),vx.rend());
s.insert(vx);
return;
}
int xx=x+(y==n-1 ? 1 : 0);
int yy=(y+1)%n;
if(x&amp;gt;y){
a[x][y]=2-a[y][x];
rec(n,xx,yy);
}
else if(y&amp;gt;x){
FORE(i,0,3){
a[x][y]=i;
rec(n,xx,yy);
}
}
else rec(n,xx,yy);
}
int find(int n, int m) {
int ret=0;
s.clear();
rec(n,0,0);
for(set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;::iterator it=s.</description>
    </item>
    
    <item>
      <title>SRM 460 DIV1 Easy - TheQuestionsAndAnswersDivOne</title>
      <link>https://chaingng.github.io/post/srm-460-div1-easy---thequestionsandanswersdivone/</link>
      <pubDate>Sun, 10 May 2015 13:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-460-div1-easy---thequestionsandanswersdivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10768&amp;amp;rd=14146
解き方 
数が小さいので全探索可能。
すでに答えた人の数、YesかNoかを答えたかの情報を持たせて
答えなくてもよい場合と答えなければならない場合についてDFSを用いる。
計算量がオーバーしてしまうので、途中で全員答えられないとわかった場合は
打ち切りを行う。
コード 
int n,m;
int a[60];
class TheQuestionsAndAnswersDivOne {
public:
int rec(int num,int mask,int mask2){
if(m-num&amp;lt;n-__builtin_popcount(mask))return 0;
if(num==m)return 1;
int ret=0;
FORE(i,0,n){
if((mask&amp;amp;(1&amp;lt;&amp;lt;i)) &amp;amp;&amp;amp; &amp;nbsp;a[num]!=((mask2&amp;amp;(1&amp;lt;&amp;lt;i))!=0) )continue;
ret+=rec(num+1,mask|(1&amp;lt;&amp;lt;i),mask2|(a[num]&amp;lt;&amp;lt;i));
}
return ret;
}
int find(int questions, vector&amp;lt;string&amp;gt; answers) {
n=questions;
m=answers.size();
FORE(i,0,m)a[i]=(answers[i]==&#34;Yes&#34;);
return rec(0,0,0);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 512 DIV1 Easy - MysteriousRestaurant</title>
      <link>https://chaingng.github.io/post/srm-512-div1-easy---mysteriousrestaurant/</link>
      <pubDate>Sun, 10 May 2015 13:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-512-div1-easy---mysteriousrestaurant/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11295&amp;amp;rd=14537
解き方 
何日目まで訪れることができるかを固定することで貪欲法で解くことができる。
N日目まで訪れるとすると、１日目＋７の倍数・・・６日目＋７の倍数のそれぞれについて
一番コストの少ない種類の和をとり、それが予算以下であれば
N日目まで訪れることができる。
コード 
class MysteriousRestaurant {
public:
int calc(char ch){
if(&#39;A&#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&#39;Z&#39;)return ch-&#39;A&#39;+10;
if(&#39;a&#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&#39;z&#39;)return ch-&#39;a&#39;+36;
return ch-&#39;0&#39;;
}
int maxDays(vector&amp;lt;string&amp;gt; prices, int budget) {
int n=prices.size(),m=prices[0].size();
int ret=0;
FORE(i,0,n){
int cost=0;
for(int j=0;j&amp;lt;7&amp;amp;&amp;amp;j&amp;lt;=i;j++){
int sum=1e+9;
for(int k=0;k&amp;lt;m;k++){
int tmp=0;
for(int l=j;l&amp;lt;=i;l+=7)tmp+=calc(prices[l][k]);
sum=min(sum,tmp);
}
cost+=sum;
}
if(cost&amp;lt;=budget)ret=max(ret,i+1);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 511 DIV1 Easy - Zoo</title>
      <link>https://chaingng.github.io/post/srm-511-div1-easy---zoo/</link>
      <pubDate>Sun, 10 May 2015 13:03:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-511-div1-easy---zoo/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11485&amp;amp;rd=14536
解き方 
動物数がN匹であれば、各動物が（０匹，N匹）〜（N匹、０匹）までの
すべての場合が考えられる。
各場合について、動物が答えている数が一致しているか判定し、
有効であればmin（うさぎの数、猫の数）^2がその場合の総数になる。
コード 
class Zoo {
public: long long theCount(vector&amp;lt;int&amp;gt; answers) {
long long ret=0;
int n=answers.size();
map&amp;lt;int,int&amp;gt; m;
FORE(i,0,n)m[answers[i]]++;
for(int l=0;l&amp;lt;=n;l++){
int r=n-l;
int cnt=0,valid=1;
for(int i=0;i&amp;lt;min(l,r);i++){
if(m[i]!=2)valid=0;
cnt+=m[i];
}
for(int i=min(l,r);i&amp;lt;max(l,r);i++){
if(m[i]!=1)valid=0;
cnt+=m[i];
}
if(cnt!=n)valid=0;
if(valid){
ret+=pow(2,min(l,r));
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 510 DIV1 Easy - TheAlmostLuckyNumbersDivOne</title>
      <link>https://chaingng.github.io/post/srm-510-div1-easy---thealmostluckynumbersdivone/</link>
      <pubDate>Sun, 10 May 2015 13:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-510-div1-easy---thealmostluckynumbersdivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11461&amp;amp;rd=14439
解き方 
４か７以外の数字は最大ひとつしか含めてはいけないので、
１つ含んでいる場合とひとつも含んでいない場合で場合分けすれば
すべての数字を発生させられる。
あとはa以上かつb以下か判定すればよい。
コード 
class TheAlmostLuckyNumbersDivOne {
public:
int calc(long long x){
int ret=0;
while(x&amp;gt;0){
if(!(x%10==4||x%10==7))ret++;
x/=10;
}
return ret;
}
void dfs(long long x){
if(x&amp;lt;=b){
dfs(x*10+4);
dfs(x*10+7);
if(calc(x)==0){
for(int i=0;i&amp;lt;=9;i++){
if(i==0 &amp;amp;&amp;amp; x==0)continue;
if(i==4 || i==7)continue;
dfs(x*10+i);
}
}
if(a&amp;lt;=x)ret++;
}
}
long long find(long long a_, long long b_) {
a=a_,b=b_;
ret=0;
dfs(0);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 515 DIV1 Easy - RotatedClock</title>
      <link>https://chaingng.github.io/post/srm-515-div1-easy---rotatedclock/</link>
      <pubDate>Sun, 10 May 2015 12:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-515-div1-easy---rotatedclock/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11329&amp;amp;rd=14540
解き方 
３０度ずつ回転させることが可能なので、全探索して
有効な数字の時の値を更新すればよい。
コード 
class RotatedClock {
public: string getEarliest(int hourHand, int minuteHand) {
string ret=&#34;&#34;;
for(int i=0;i&amp;lt;=360;i+=30){
int h=(hourHand+i)%360;
int m=(minuteHand+i)%360;
if((h%30)*12==m){
char ch[20];
sprintf(ch,&#34;%02d:%02d&#34;,h/30,m/6);
if(ret.empty()||ch&amp;lt;ret)ret=ch;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 513 DIV1 Easy - YetAnotherIncredibleMachine</title>
      <link>https://chaingng.github.io/post/srm-513-div1-easy---yetanotherincrediblemachine/</link>
      <pubDate>Sun, 10 May 2015 12:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-513-div1-easy---yetanotherincrediblemachine/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11502&amp;amp;rd=14538
解き方 
各プラットフォームについて有効な場所の総数を、それぞれかけていけばよい。
あるプラットフォームについて有効な場所かどうかの判定は、
一番左側の点と右側の点の間にボールがなければよい。
この判定には二分探索を使うことができる。
コード 
class YetAnotherIncredibleMachine {
public: int countWays(vector&amp;lt;int&amp;gt; platformMount, vector&amp;lt;int&amp;gt; platformLength, vector&amp;lt;int&amp;gt; balls) {
int n=platformMount.size();
int MOD=1000000009;
int m=balls.size();
sort(all(balls));
int ret=1;
FORE(i,0,n){
int cur=0;
for(int l=platformMount[i]-platformLength[i];l&amp;lt;=platformMount[i];l++){
int r=l+platformLength[i];
int s=lower_bound(balls.begin(),balls.end(),l)-balls.begin();
if( !(0&amp;lt;=s &amp;amp;&amp;amp; s&amp;lt;m) || balls[s]&amp;gt;r )cur++;
}
ret=(1LL*ret*cur)%MOD;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 495 DIV1 Easy - ColorfulCards xx</title>
      <link>https://chaingng.github.io/post/srm-495-div1-easy---colorfulcards-xx/</link>
      <pubDate>Sun, 10 May 2015 10:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-495-div1-easy---colorfulcards-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11302&amp;amp;rd=14424
解き方 
すべての状態について、満たすすべての整数を調べていっては
コード量が大変になってしまう。
そこで各状態について、とりうる最小の整数と最大の整数を調べ、
一致していればその整数、一致していない、つまり複数通り存在するならば
−１を返す。
コード 
class ColorfulCards {
public: vector&amp;lt;int&amp;gt; theCards(int N, string colors) {
int prime[N+1];
FORE(i,1,N+1)prime[i]=1;
prime[1]=0;
for(int i=2;i&amp;lt;=N;i++)if(prime[i]){
for(int j=i*2;j&amp;lt;=N;j+=i)prime[j]=0;
}
int m=colors.size();
int minx[m],maxx[m];
int at=0;
for(int i=1;i&amp;lt;=N;i++){
if(at&amp;gt;=m)break;
if((colors[at]==&#39;R&#39;)==prime[i]){
minx[at++]=i;
}
}
at=m-1;
for(int i=N;i&amp;gt;=1;i--){
if(at&amp;lt;0)break;
if((colors[at]==&#39;R&#39;)==prime[i]){
maxx[at--]=i;
}
}
vector&amp;lt;int&amp;gt; ans;
ans.clear();
FORE(i,0,m){
if(minx[i]==maxx[i])ans.push_back(minx[i]);
else ans.push_back(-1);
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>TCO 2015 1C Middle - UnrelatedPaths</title>
      <link>https://chaingng.github.io/post/tco-2015-1c-middle---unrelatedpaths/</link>
      <pubDate>Sun, 10 May 2015 10:37:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/tco-2015-1c-middle---unrelatedpaths/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13746&amp;amp;rd=16434
解き方 
木のルートからDFSでたどっていってパスの数を足していけば良い。
ルート０に直接つながっているノードについて、
さらにその下にノードがつながっていればそのパスの和、
つながっていなければ１を返す。
コード 
vector&amp;lt;int&amp;gt; p;
int n;
class UnrelatedPaths {
public:
int dfs(int x){
int ret=0;
FORE(i,0,n)if(p[i]==x){
ret+=dfs(i+1);
}
return ret==0 ? 1 : ret;
}
int maxUnrelatedPaths(vector&amp;lt;int&amp;gt; parent) {
p=parent;
n=p.size();
return dfs(0);
}
}; </description>
    </item>
    
    <item>
      <title>2015 TCO Round 1C Easy - DevuAndPlantingTrees</title>
      <link>https://chaingng.github.io/post/2015-tco-round-1c-easy---devuandplantingtrees/</link>
      <pubDate>Sun, 10 May 2015 10:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2015-tco-round-1c-easy---devuandplantingtrees/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13743&amp;amp;rd=16434
解き方 
２つ行があるが、追加する木については上下のどちらに追加しても変わらないので
片方だけを考える。
すでに存在する木によって追加できるスペースはいくつかに区切られるが、
各区切りごとのセルの連続数によって、追加できる木の数が決まる。
コード 
class DevuAndPlantingTrees {
public: int maximumTreesDevuCanGrow(vector&amp;lt;string&amp;gt; garden) {
int n=garden[0].size();
int used[n];
int ret=0;
memset(used,0,sizeof(used));
FORE(i,0,2)FORE(j,0,n)if(garden[i][j]==&#39;*&#39;){
if(j-1&amp;gt;=0)used[j-1]=1;
if(j+1&amp;lt;n)used[j+1]=1;
used[j]=1;
ret++;
}
int at=0;
while(1){
while(at&amp;lt;n &amp;amp;&amp;amp; used[at])at++;
if(at&amp;gt;=n)break;
int l=at;
at++;
while(at&amp;lt;n &amp;amp;&amp;amp; !used[at+1])at++;
ret+=(at-l+2)/2;
at++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>TCO 2015 1C Hard  - MagicWords</title>
      <link>https://chaingng.github.io/post/tco-2015-1c-hard----magicwords/</link>
      <pubDate>Sun, 10 May 2015 10:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/tco-2015-1c-hard----magicwords/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13731&amp;amp;rd=16434
解き方 
dpの問題。
dp[現在調べている桁数][beautifulcountの数][10の連続数]＝そのbeautifulcountの総数
とすると、前の結果について以下のようになる。
１：前の結果から１０が連続しないように１桁追加
→連続数が１になり、beautifulcountが１増える
２：前の結果から１０が連続するように１桁追加
→連続数が１増えて、beautifulcountが連続数＋１個増える
コード 
class DevuAndBeautifulSubstrings {
public: long long countBeautifulSubstrings(int n, int cnt) {
int num=n*(n+1)/2;
long long dp[n+1][num][n+1];
memset(dp,0,sizeof(dp));
dp[1][1][1]=2;
for(int i=1;i&amp;lt;n;i++)for(int j=0;j&amp;lt;=num;j++)for(int prev=0;prev&amp;lt;=n;prev++){
if(dp[i][j][prev]!=0){
dp[i+1][j+1][1]+=dp[i][j][prev];
dp[i+1][j+1+prev][prev+1]+=dp[i][j][prev];
}
}
long long ret=0LL;
FORE(i,0,n+1)ret+=dp[n][cnt][i];
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 414 DIV1 Easy - Embassy</title>
      <link>https://chaingng.github.io/post/srm-414-div1-easy---embassy/</link>
      <pubDate>Sat, 09 May 2015 23:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-414-div1-easy---embassy/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9895&amp;amp;rd=13505
解き方 
スタート地点によって待ち時間は異なるので、
すべてのスタート地点においてシミュレーションし、最短となる
時間が答えとなる。
コード 
class Embassy {
public: int visaApplication(vector&amp;lt;int&amp;gt; forms, int dayLength, int openTime) {
int ret=1e+9;
int n=forms.size();
for(int s=0;s&amp;lt;=1000000;s++){
int tmp=0;
FORE(i,0,n){
tmp+=forms[i];
if( ((tmp-s)%dayLength+dayLength)%dayLength&amp;lt;=openTime)continue;
tmp+=dayLength-((tmp-s)%dayLength+dayLength)%dayLength;
}
ret=min(ret,tmp);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 405 DIV1 Easy - RelativePath x</title>
      <link>https://chaingng.github.io/post/srm-405-div1-easy---relativepath-x/</link>
      <pubDate>Sat, 09 May 2015 23:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-405-div1-easy---relativepath-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9760&amp;amp;rd=12177
解き方 
システムテストで落ちないようコーナーケースでの検討が必要。
可能であればそれぞれのパスについてディレクトリを取り出して
比較するのが確実。
コード 
class RelativePath {
public: string makeRelative(string path, string currentDir) {
string str=&#34;&#34;;
while(!path.empty() &amp;amp;&amp;amp; !currentDir.empty()){
if(path[0]==&#39;/&#39;&amp;amp;&amp;amp;currentDir[0]==&#39;/&#39;){
path=path.substr(1),currentDir=currentDir.substr(1);
}
string s1=&#34;&#34;,s2=&#34;&#34;;
int cur=0;
while(cur&amp;lt;path.size() &amp;amp;&amp;amp; path[cur]!=&#39;/&#39;)s1+=path[cur],cur++;
cur=0;
while(cur&amp;lt;currentDir.size() &amp;amp;&amp;amp; currentDir[cur]!=&#39;/&#39;)s2+=currentDir[cur],cur++;
if(s1!=s2 || s1.empty() || s2.empty())break;
path=path.substr(s1.size());
currentDir=currentDir.substr(s1.size());
}
if(!currentDir.empty()){
str+=&#34;../&#34;;
for(int i=0;i&amp;lt;currentDir.size();i++){
if(currentDir[i]==&#39;/&#39;)str+=&#34;../&#34;;
}
}
if(!path.empty() &amp;amp;&amp;amp; path[0]==&#39;/&#39;)path=path.substr(1);
str+=path;
return str;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 433 DIV1 Easy - MagicWords xx</title>
      <link>https://chaingng.github.io/post/srm-433-div1-easy---magicwords-xx/</link>
      <pubDate>Sat, 09 May 2015 17:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-433-div1-easy---magicwords-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10195&amp;amp;rd=13695
解き方 
ある文字列がずらすことで何通り同じ文字列が現れるかは、
その文字列で割りきれるサブ文字列がいくつつながっているかでわかる。
例えば長さ１２の文字列中、長さ３のサブ文字列が４つ連なっている場合、
１２／３で４通り存在する。
上記のように判定することで計算量がO(８！×１６０×sqrt(160)）で
時間内に収めることができる。
コード 
class MagicWords {
public:
int calc(string str){
int n=str.size();
for(int i=1;i&amp;lt;n;i++)if(n%i==0){
int valid=1;
for(int j=0;j&amp;lt;n;j++)if(str[j]!=str[(j+i)%n])valid=0;
if(valid)return n/i;
}
return 1;
}
int count(vector&amp;lt;string&amp;gt; S, int K) {
int m=S.size();
vector&amp;lt;int&amp;gt; idx(m);
FORE(i,0,m)idx[i]=i;
sort(all(idx));
int ret=0;
do{
string str=&#34;&#34;;
FORE(i,0,m)str+=S[idx[i]];
if(calc(str)==K)ret++;
}while(next_permutation(all(idx)));
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 449 DIV1 Easy - MaxTriangle</title>
      <link>https://chaingng.github.io/post/srm-449-div1-easy---maxtriangle/</link>
      <pubDate>Sat, 09 May 2015 17:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-449-div1-easy---maxtriangle/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10548&amp;amp;rd=13903
解き方 
すべての辺は「整数^2+整数^2」になっていなければならない。
そのような辺を構成するすべての点のペアについて、
（0,0）、（a,b）、（c,d）からなる三角形の面積が
|ad-bd|/2であることを利用して最大の面積を求める。
コード 
class MaxTriangle {
public:
double calculateArea(int A, int B) {
vector&amp;lt;double&amp;gt; x1,x2,y1,y2;
for(long long x=0;x*x&amp;lt;=A;x++){
long long y=sqrt(A-x*x);
if(x*x+y*y==A){
x1.push_back(x),y1.push_back(y);
x1.push_back(x),y1.push_back(-y);
x1.push_back(-x),y1.push_back(y);
x1.push_back(-x),y1.push_back(-y);
}
}
for(long long x=0;x*x&amp;lt;=B;x++){
long long y=sqrt(B-x*x);
if(x*x+y*y==B){
x2.push_back(x),y2.push_back(y);
x2.push_back(x),y2.push_back(-y);
x2.push_back(-x),y2.push_back(y);
x2.push_back(-x),y2.push_back(-y);
}
}
double ret=-1;
FORE(i,0,x1.size())FORE(j,0,x2.size()){
double s=labs(x1[i]*y2[j]-x2[j]*y1[i])/2.0;
ret=max(ret,s);
}
return ret;
}
} </description>
    </item>
    
    <item>
      <title>SRM 504 DIV1 Easy - MathContest</title>
      <link>https://chaingng.github.io/post/srm-504-div1-easy---mathcontest/</link>
      <pubDate>Sat, 09 May 2015 17:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-504-div1-easy---mathcontest/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11233&amp;amp;rd=14433
解き方 
キューが連続的になっているということに気をつければ、
現在左から見るか右から見るかの情報、
ひっくり返っているかそうでないかの情報を持つことで
配列を操作せずに解くことができる。
コード 
string str;
class MathContest {
public: int countBlack(string ballSequence, int repetitions) {
int ret=0;
str=&#34;&#34;;
FORE(i,0,repetitions)str+=ballSequence;
int n=str.size();
int turn=1,dir=1;
int l=0,r=n-1;
while(l&amp;lt;=r){
if(dir){
if(turn==(str[l]==&#39;B&#39;)){
turn=1-turn;
ret++;
}
else dir=1-dir;
l++;
}else{
if(turn==(str[r]==&#39;B&#39;)){
turn=1-turn;
ret++;
}
else dir=1-dir;
r--;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 402 DIV1 Easy - RandomSort</title>
      <link>https://chaingng.github.io/post/srm-402-div1-easy---randomsort/</link>
      <pubDate>Sat, 09 May 2015 17:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-402-div1-easy---randomsort/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8590&amp;amp;rd=12174
解き方 
全探索可能。
配列の状態を持つのでdpではなくmapを利用してDFSで解く。
コード 
map&amp;lt;vector&amp;lt;int&amp;gt;,double&amp;gt; m;
int n;
class RandomSort {
public:
double rec(vector&amp;lt;int&amp;gt; p){
if(m.find(p)!=m.end())return m[p];
int cnt=0;
FORE(i,0,n)FORE(j,i+1,n)if(p[i]&amp;gt;p[j])cnt++;
if(cnt==0)return m[p]=0;
double ret=0;
FORE(i,0,n)FORE(j,i+1,n){
if(p[i]&amp;gt;p[j]){
swap(p[i],p[j]);
ret+=rec(p)+1;
swap(p[i],p[j]);
}
}
return m[p]=ret/cnt;
}
double getExpected(vector&amp;lt;int&amp;gt; permutation) {
m.clear();
n=permutation.size();
return rec(permutation);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 437 DIV1 Easy - TheSwap</title>
      <link>https://chaingng.github.io/post/srm-437-div1-easy---theswap/</link>
      <pubDate>Sat, 09 May 2015 17:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-437-div1-easy---theswap/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10369&amp;amp;rd=13699
解き方 
全探索可能な問題。
setとvectorを利用して、各繰り返し回数で生成される数を更新していく。
コード 
class TheSwap {
public: int findMax(int n, int k) {
set&amp;lt;int&amp;gt; cur,next;
cur.insert(n);
FORE(i,0,k){
for(set&amp;lt;int&amp;gt;::iterator it=cur.begin();it!=cur.end();it++){
int x=*it;
vector&amp;lt;int&amp;gt; vx;
while(x&amp;gt;0){
vx.push_back(x%10);
x/=10;
}
FORE(a,0,vx.size())FORE(b,a+1,vx.size()){
if(!(b==vx.size()-1 &amp;amp;&amp;amp; vx[a]==0)){
swap(vx[a],vx[b]);
int tmp=0;
for(int c=vx.size()-1;c&amp;gt;=0;c--)tmp=tmp*10+vx[c];
next.insert(tmp);
swap(vx[a],vx[b]);
}
}
}
cur=next;
next.clear();
}
int ret=0;
if(cur.empty())return -1;
for(set&amp;lt;int&amp;gt;::iterator it=cur.begin();it!=cur.end();it++){
ret=max(ret,*it);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 445 DIV1 Easy - TheNewHouseDivOne</title>
      <link>https://chaingng.github.io/post/srm-445-div1-easy---thenewhousedivone/</link>
      <pubDate>Sat, 09 May 2015 16:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-445-div1-easy---thenewhousedivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10512&amp;amp;rd=13899
解き方 
元となる点はすべて座標上の点なので、
すべての実数上の点を調べなくても、0.5単位ですべての位置を調べればよい。
コード 
class TheNewHouseDivOne {
public: double distance(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int k) {
double ret=1e+9;
int n=x.size();
for(double xx=-100;xx&amp;lt;=100;xx+=0.5)for(double yy=-100;yy&amp;lt;=100;yy+=0.5){
vector&amp;lt;double&amp;gt; vx;
FORE(i,0,n)vx.push_back(abs(xx-x[i])+abs(yy-y[i]));
sort(all(vx));
ret=min(ret,vx[k-1]);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 448 DIV1 Easy - TheBlackJackDivOne</title>
      <link>https://chaingng.github.io/post/srm-448-div1-easy---theblackjackdivone/</link>
      <pubDate>Sat, 09 May 2015 16:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-448-div1-easy---theblackjackdivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10615&amp;amp;rd=13902
解き方 
探索箇所が少ないので全探索可能。
各カードについて既に使ったかどうかの情報が必要なので、
その情報を更新しつつDFSを用いればよい。
コード 
int s[]={0,11,2,3,4,5,6,7,8,9,10,10,10,10};
int c[14];
class TheBlackJackDivOne {
public:
double rec(int cur){
if(cur&amp;gt;=21)return 0;
int sum=0;
double ret=0.0;
FORE(i,0,14)sum+=c[i];
FORE(i,0,14)if(c[i]!=0){
c[i]--;
ret+=(1+rec(s[i]+cur))*(c[i]+1)/sum;
c[i]++;
}
return ret;
}
double expected(vector&amp;lt;string&amp;gt; cards) {
int score=0;
FORE(i,0,14)c[i]=4;
c[0]=0;
FORE(i,0,cards.size()){
if(cards[i][0]==&#39;A&#39;)c[1]--,score+=11;
else if(cards[i][0]==&#39;T&#39;)c[10]--,score+=10;
else if(cards[i][0]==&#39;J&#39;)c[11]--,score+=10;
else if(cards[i][0]==&#39;Q&#39;)c[12]--,score+=10;
else if(cards[i][0]==&#39;K&#39;)c[13]--,score+=10;
else c[cards[i][0]-&#39;0&#39;]--,score+=cards[i][0]-&#39;0&#39;;
}
return rec(score);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 478 DIV1 Easy - CarrotJumping x</title>
      <link>https://chaingng.github.io/post/srm-478-div1-easy---carrotjumping-x/</link>
      <pubDate>Sat, 09 May 2015 16:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-478-div1-easy---carrotjumping-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11022&amp;amp;rd=14187
解き方 
４x＊３を３回繰り返したときに８x＋７の２回繰り替えしたものと一致するため
探索回数は最大３０００００回となる。
この回数であれば全探索可能であるので、すべての点を調べればよい。
BFSを使えばキューのため更新箇所はつねに最短となるため、
各位置での値の更新は不要となる。
コード 
map&amp;lt;long long,int&amp;gt; m;
class CarrotJumping {
public: int theJump(int init) {
int MOD=1000000007;
m.clear();
m[init]=0;
queue&amp;lt;long long&amp;gt; q;
q.push(init);
while(!q.empty()){
long long x=q.front();
q.pop();
if(m[x]&amp;gt;100000||x==0)break;
if(m.find((x*4+3)%MOD)==m.end()){
q.push((x*4+3)%MOD);
m[(x*4+3)%MOD]=m[x]+1;
}
if(m.find((x*8+7)%MOD)==m.end()){
q.push((x*8+7)%MOD);
m[(x*8+7)%MOD]=m[x]+1;
}
}
return m[0]&amp;gt;100000||m[0]==0 ? -1 : m[0];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 492 DIV1 Easy - TimeTravellingGardener</title>
      <link>https://chaingng.github.io/post/srm-492-div1-easy---timetravellinggardener/</link>
      <pubDate>Sat, 09 May 2015 16:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-492-div1-easy---timetravellinggardener/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11060&amp;amp;rd=14245
解き方 
２つの木のペアのいずれかの傾きが、最適な傾きになることがわかる。
このうち、切らなくてもよい木が一番少なく、かつ地面より下に木がいかなく、
かつ現在存在する木よりも大きい位置にならないようなものを
すべて調べればよい。
コード 
class TimeTravellingGardener {
public: int determineUsage(vector&amp;lt;int&amp;gt; distance, vector&amp;lt;int&amp;gt; h) {
int n=h.size();
int sum[n];
sum[0]=0;
FORE(i,0,n-1)sum[i+1]=sum[i]+distance[i];
int ret=n-1;
FORE(i,0,n)FORE(j,i+1,n){
int cnt=0;
if((sum[n-1]-sum[i])*(h[j]-h[i])&amp;lt;-h[i]*(sum[j]-sum[i]))continue;
if((sum[0]-sum[i])*(h[j]-h[i])&amp;lt;-h[i]*(sum[j]-sum[i]))continue;
int valid=1;
for(int k=0;k&amp;lt;n;k++){
if((sum[k]-sum[i])*(h[j]-h[i])&amp;gt;(h[k]-h[i])*(sum[j]-sum[i])){
valid=0;
break;
}
if((sum[k]-sum[i])*(h[j]-h[i])!=(h[k]-h[i])*(sum[j]-sum[i])){
cnt++;
}
}
if(valid)ret=min(ret,cnt);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 447 DIV1 Easy - KnightsTour</title>
      <link>https://chaingng.github.io/post/srm-447-div1-easy---knightstour/</link>
      <pubDate>Sat, 09 May 2015 16:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-447-div1-easy---knightstour/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10577&amp;amp;rd=13901
解き方 
問題文の条件をすべて洗い出すのが大事。
洗い出すことができれば、あとは正確に実装すればよい。
コード 
int used[10][10];
int dr[]={1,1,2,2,-1,-1,-2,-2},dc[]={2,-2,1,-1,2,-2,1,-1};
int h,w;
class KnightsTour {
public:
int calc(vector&amp;lt;string&amp;gt; board,int r,int c){
int cnt=0;
FORE(i,0,8){
int nr=r+dr[i],nc=c+dc[i];
if(0&amp;lt;=nr &amp;amp;&amp;amp; nr&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=nc &amp;amp;&amp;amp; nc&amp;lt;w &amp;amp;&amp;amp; used[nr][nc]==0 &amp;amp;&amp;amp; board[nr][nc]!=&#39;*&#39;){
cnt++;
}
}
return cnt;
}
int visitedPositions(vector&amp;lt;string&amp;gt; board) {
h=board.size(),w=board[0].size();
memset(used,0,sizeof(used));
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
FORE(i,0,h)FORE(j,0,w)if(board[i][j]==&#39;K&#39;){
q.push(make_pair(i,j));
used[i][j]=1;
}
int ret=0;
while(!q.empty()){
int r=q.front().first;
int c=q.front().second;
q.pop();
ret=max(ret,used[r][c]);
int nextr=1e+9,nextc=1e+9,cost=1e+9;</description>
    </item>
    
    <item>
      <title>SRM 491 DIV1 Easy - FoxMakingDice</title>
      <link>https://chaingng.github.io/post/srm-491-div1-easy---foxmakingdice/</link>
      <pubDate>Sat, 09 May 2015 16:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-491-div1-easy---foxmakingdice/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11234&amp;amp;rd=14244
解き方 
Kを固定することで、そのKを作ることのできる組み合わせの数を
求めることができる。
よって、すべてのKについて作ることのできるサイコロの数を足していけばよい。
コード 
class FoxMakingDice {
public: long long theCount(int N, int K) {
long long ret=0;
for(int sum=K;sum&amp;lt;=2*N;sum++){
long long cnt=0;
for(int j=1;j&amp;lt;sum-j;j++){
if(j&amp;lt;=N &amp;amp;&amp;amp; sum-j&amp;lt;=N)cnt++;
}
if(cnt&amp;gt;=3)ret+=2*cnt*(cnt-1)*(cnt-2)/6;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 497 DIV1 Easy - PermutationSignature xx</title>
      <link>https://chaingng.github.io/post/srm-497-div1-easy---permutationsignature-xx/</link>
      <pubDate>Sat, 09 May 2015 16:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-497-div1-easy---permutationsignature-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11115&amp;amp;rd=14426
解き方 
配列の数が５０個なのですべての組み合わせは求められないので
順番が決まるか、貪欲法で求められるはず。
左から数を調べていくとすると、その数は昇順である方がよいので、
その点から連続するDの数だけ確保しておけば、そのうち最小の数を
とってもよいことがわかる。
よって、そのようにして左側から数を決定していく。l
コード 
class PermutationSignature {
public:
vector&amp;lt;int&amp;gt; reconstruct(string signature) {
int n=signature.size()+1;
int used[n+1];
memset(used,0,sizeof(used));
vector&amp;lt;int&amp;gt; ans;
FORE(i,0,n){
int cnt=0;
FORE(j,i,signature.size()){
if(signature[j]!=&#39;D&#39;)break;
cnt++;
}
int x=1;
while(used[x])x++;
while(cnt&amp;gt;0){
x++;
if(used[x])continue;
cnt--;
}
ans.push_back(x);
used[x]=1;
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 498 DIV1 Easy - FoxSequence</title>
      <link>https://chaingng.github.io/post/srm-498-div1-easy---foxsequence/</link>
      <pubDate>Sat, 09 May 2015 16:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-498-div1-easy---foxsequence/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11219&amp;amp;rd=14427
解き方 
システムテストで落ちないような実装の正確性が求められる問題。
共通処理は関数化し、各区間について点の不等号がどうであるか
正しく実装する。
コード 
class FoxSequence {
public:
bool ispossible(vector&amp;lt;int&amp;gt; seq,int s,int e,int d){
for(int i=s;i&amp;lt;=e;i++)if(seq[s]+(i-s)*d!=seq[i])return false;
return true;
}
string isValid(vector&amp;lt;int&amp;gt; seq) {
int n=seq.size();
int at=0,next=0;
while(next+1&amp;lt;n &amp;amp;&amp;amp; seq[next]&amp;lt;seq[next+1])next++;
if(at==next || next&amp;gt;=n)return &#34;NO&#34;;
if(!ispossible(seq,at,next,seq[at+1]-seq[at]))return &#34;NO&#34;;
at=next;
while(next+1&amp;lt;n &amp;amp;&amp;amp; seq[next]&amp;gt;seq[next+1])next++;
if(at==next || next&amp;gt;=n)return &#34;NO&#34;;
if(!ispossible(seq,at,next,seq[at+1]-seq[at]))return &#34;NO&#34;;
while(next+1&amp;lt;n &amp;amp;&amp;amp; seq[next]==seq[next+1])next++;
if(next&amp;gt;=n)return &#34;NO&#34;;
at=next;
while(next+1&amp;lt;n &amp;amp;&amp;amp; seq[next]&amp;lt;seq[next+1])next++;
if(at==next || next&amp;gt;=n)return &#34;NO&#34;;
if(!ispossible(seq,at,next,seq[at+1]-seq[at]))return &#34;NO&#34;;
at=next;
while(next+1&amp;lt;n &amp;amp;&amp;amp; seq[next]&amp;gt;seq[next+1])next++;</description>
    </item>
    
    <item>
      <title>SRM 499 DIV1 Easy - ColorfulRabbits ○</title>
      <link>https://chaingng.github.io/post/srm-499-div1-easy---colorfulrabbits-/</link>
      <pubDate>Sat, 09 May 2015 16:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-499-div1-easy---colorfulrabbits-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11327&amp;amp;rd=14428
様々な種類のうさぎがいる。
そのうちいくつかのうさぎに質問し、自分以外に同じ種類のうさぎが何匹いるか
答えている。
このとき、うさぎの総数について、矛盾しないような最小の数を求める。
解き方 
同じ数xを答えたうさぎについて、x＋１匹まで同じ種類二まとめられる。
答えたすべての数xについて、上記から計算できる最小のうさぎの総数を
求める。
コード 
class ColorfulRabbits {
public: int getMinimum(vector&amp;lt;int&amp;gt; replies) {
int n=replies.size();
int used[n];
memset(used,0,sizeof(used));
long long ret=0;
FORE(i,0,n)if(!used[i]){
int cnt=0;
FORE(j,0,n)if(replies[i]==replies[j]){
cnt++;
used[j]=1;
}
long long x=replies[i]+1;
ret+=x*((cnt+x-1)/x);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 496 DIV1 Easy - ColoredStrokes ○</title>
      <link>https://chaingng.github.io/post/srm-496-div1-easy---coloredstrokes-/</link>
      <pubDate>Sat, 09 May 2015 16:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-496-div1-easy---coloredstrokes-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11306&amp;amp;rd=14425
青を縦に塗ることができるブラシと、赤を横に塗ることができるブラシが
与えられる。
また青と赤が交わったセルは緑色になる。
最初は真っ白なボードからブラシを塗って、最終的に与えられた
形に絵を塗りたいとき、最小の塗る回数を求める。
解き方 
緑の色は赤を最初に塗っても、青を最初に塗ってもよく順番は関係ないので、
青の塗る回数と赤を塗る回数を独立で考え、最後に和をとればよい。
コード 
class ColoredStrokes {
public: int getLeast(vector&amp;lt;string&amp;gt; picture) {
int h=picture.size(),w=picture[0].size();
int ret=0;
for(int j=0;j&amp;lt;w;j++){
int at=0;
while(at&amp;lt;h){
while(at&amp;lt;h &amp;amp;&amp;amp; (picture[at][j]==&#39;.&#39;||picture[at][j]==&#39;R&#39;))at++;
if(at&amp;gt;=h)break;
ret++;
while(at&amp;lt;h &amp;amp;&amp;amp; (picture[at][j]==&#39;G&#39;||picture[at][j]==&#39;B&#39;))at++;
}
}
for(int i=0;i&amp;lt;h;i++){
int at=0;
while(at&amp;lt;w){
while(at&amp;lt;w &amp;amp;&amp;amp; (picture[i][at]==&#39;.&#39;||picture[i][at]==&#39;B&#39;))at++;
if(at&amp;gt;=w)break;
ret++;
while(at&amp;lt;w &amp;amp;&amp;amp; (picture[i][at]==&#39;G&#39;||picture[i][at]==&#39;R&#39;))at++;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 494 DIV1 Easy - Painting ○</title>
      <link>https://chaingng.github.io/post/srm-494-div1-easy---painting-/</link>
      <pubDate>Sat, 09 May 2015 16:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-494-div1-easy---painting-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11310&amp;amp;rd=14423
白いボードが与えられる。
これをN＊Nの黒いスタンプによって、与えられた絵を作りたい。
できるだけ大きいスタンプで与えられた絵を作りたいとき、
その最大の大きさを求める。
解き方 
スタンプを押す順番は関係ないので、各スタンプの大きさについて
スタンプが押せる位置のとき、スタンプを押してしまう。
押したスタンプのセルを？とし、最後にWと？だけが残れば
その大きさのスタンプで絵を作ることができる。
コード 
class Painting {
public: int largestBrush(vector&amp;lt;string&amp;gt; picture) {
int h=picture.size(),w=picture[0].size();
for(int len=min(w,h);len&amp;gt;=2;len--){
vector&amp;lt;string&amp;gt; p=picture;
while(1){
int finish=1;
for(int i=0;i+len-1&amp;lt;h;i++)for(int j=0;j+len-1&amp;lt;w;j++){
int valid=1;
for(int k=i;k&amp;lt;i+len;k++)for(int l=j;l&amp;lt;j+len;l++){
if(p[k][l]==&#39;W&#39;)valid=0;
}
if(valid){
for(int k=i;k&amp;lt;i+len;k++)for(int l=j;l&amp;lt;j+len;l++){
if(p[k][l]==&#39;B&#39;)finish=0;
p[k][l]=&#39;?&#39;;
}
}
}
if(finish)break;
}
int flag=1;
FORE(i,0,h)FORE(j,0,w)if(p[i][j]==&#39;B&#39;)flag=0;
if(flag)return len;
}
return 1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 504.5 DIV1 Easy - TheNumbersWithLuckyLastDigit</title>
      <link>https://chaingng.github.io/post/srm-504.5-div1-easy---thenumberswithluckylastdigit/</link>
      <pubDate>Sat, 09 May 2015 16:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-504.5-div1-easy---thenumberswithluckylastdigit/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11096&amp;amp;rd=14514
下１桁が４または７である数はラッキーナンバーとなる。
ある整数Nが与えられたとき、その数をラッキーナンバーの和で表したい。
ラッキーナンバーの数で表すことができれば必要な最小のラッキーナンバーの
数を返す。
表すことができなければー１を返す。
解き方 
チャレンジされやすそうな問題。
小さい数で試してみると、２１以上の数はすべてラッキーナンバーの和で
表すことができることがわかる。
またラッキーナンバーの和で表すことができる場合、下２桁以外の数は
いくらであっても必要な数は変わらない。
よって作ることのできるすべての下３桁の数について試し、
その最小のものが答えになる。
単純に下２桁をMOD１００でとると１０２０のような場合にー１となってしまうので
２桁の数で下１桁が４と７の数を引いたときの下２桁を求めれば
すべての場合で確かめることができる。
条件分岐のIF文をできるだけ少なくすることがシステムテストで落ちないためのコツ。
コード 
class TheNumbersWithLuckyLastDigit {
public: int find(int n) {
int dp[100];
FORE(i,0,100)dp[i]=1e+9;
FORE(i,1,100){
if(i%10==4||i%10==7)dp[i]=1;
for(int j=4;i+j&amp;lt;100;j+=10)dp[i+j]=min(dp[i+j],dp[i]+1);
for(int j=7;i+j&amp;lt;100;j+=10)dp[i+j]=min(dp[i+j],dp[i]+1);
}
int ret=1e+9;
ret=min(ret,dp[n%100]);
for(int i=4;i&amp;lt;100&amp;amp;&amp;amp;n-i&amp;gt;=0;i+=10)ret=min(ret,dp[(n-i)%100]+1);
for(int i=7;i&amp;lt;100&amp;amp;&amp;amp;n-i&amp;gt;=0;i+=10)ret=min(ret,dp[(n-i)%100]+1);
return ret==1e+9 ? -1 : ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 506 DIV1 Easy - SlimeXSlimesCity</title>
      <link>https://chaingng.github.io/post/srm-506-div1-easy---slimexslimescity/</link>
      <pubDate>Sat, 09 May 2015 15:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-506-div1-easy---slimexslimescity/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11154&amp;amp;rd=14435
スライムの島が複数あり、各島ごとに何匹スライムがいるかわかっている。
各島を１つに統合したい。
２つの島を統合するとき、もう一つの島にいるスライムの数以上であれば
その島の名前をつけることができる。
このとき、最大で何通りの島の数が存在しうるか求める。
解き方 
配列をソートし、初期値をその名前を残したい島のスライムの数とする。
小さい方から統合していき、すべての島を統合できればその名前は残り、
そうでなければその名前は残らなくなる。
コード 
class SlimeXSlimesCity {
public: int merge(vector&amp;lt;int&amp;gt; population) {
int n=population.size();
int ret=0;
sort(all(population));
FORE(i,0,n){
long long sum=population[i];
int at=0;
while(at&amp;lt;n){
if(at==i){
at++;
}
else if(sum&amp;gt;=population[at]){
sum+=population[at];
at++;
}
else break;
}
if(at&amp;gt;=n)ret++;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 507 DIV1 Easy - CubeStickers</title>
      <link>https://chaingng.github.io/post/srm-507-div1-easy---cubestickers/</link>
      <pubDate>Sat, 09 May 2015 15:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-507-div1-easy---cubestickers/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11315&amp;amp;rd=14436
６面体を与えられた色を使って塗りたい。
ただし、隣り合う面は違う色で塗らなくてはいけない。
使える色の集合が与えられたとき、６面体を塗ることができれば”Yes”、塗れなければ
”No”を返す。
解き方 
各色について、２色までであれば反対側の面で使うことができる。
よって各色についてその色の数もしくは２のうちの最小のものを足していき
最後にその数の和が６以上であれば６面体を塗ることができる。
コード 
class CubeStickers {
public: string isPossible(vector&amp;lt;string&amp;gt; sticker) {
int n=sticker.size();
map&amp;lt;string,int&amp;gt; m;
FORE(i,0,n)m[sticker[i]]++;
int sum=0;
for(map&amp;lt;string,int&amp;gt;::iterator it=m.begin();it!=m.end();it++){
sum+=min(2,it-&amp;gt;second);
}
return sum&amp;gt;=6 ? &#34;YES&#34; : &#34;NO&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 508 DIV1 Easy - DivideAndShift</title>
      <link>https://chaingng.github.io/post/srm-508-div1-easy---divideandshift/</link>
      <pubDate>Sat, 09 May 2015 15:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-508-div1-easy---divideandshift/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11434&amp;amp;rd=14437
数字の列と、現在の位置が与えられる。
２つの操作のいずれかによって、位置を１番目に移動させたい。
・位置を右か左に移動
・現在の列数の素数で割り、列の長さを列／素数に変換
このときの最小の操作回数を求める。
解き方 
N,Mが大きいのでdpでは配列を確保できない。
今回２つの匝瑳のうち、
移動の操作は割る操作よりも後で行えばよいので
各列についてたかだか１回の操作でよい。
よって各列について割る操作すべてについてBFSで調べていき、
また移動についても各列1度のみ調べていけばよい。
コード 
class DivideAndShift {
public:
int getLeast(int N, int M) {
int ret=1e+9;
int prime[N+1];
memset(prime,1,sizeof(prime));
prime[0]=0,prime[1]=0;
for(int i=2;i&amp;lt;=N;i++)if(prime[i]){
for(int j=i+i;j&amp;lt;=N;j+=i)prime[j]=0;
}
queue&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt; &amp;gt; q;
q.push(make_pair(make_pair(N,M-1),0));
while(!q.empty()){
int x=q.front().first.first;
int pos=q.front().first.second;
int turn=q.front().second;
q.pop();
ret=min(ret,turn+min(pos,x-pos));
vector&amp;lt;int&amp;gt; vx;
for(int i=2;i*i&amp;lt;=x;i++)if(x%i==0){
if(prime[i])vx.push_back(i);
if(prime[x/i])vx.push_back(x/i);
}
if(prime[x])vx.push_back(x);
FORE(i,0,vx.size()){
int len=x/vx[i];
q.push(make_pair(make_pair(len,pos%len),turn+1));
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 419 DIV1 Easy - Undo ○</title>
      <link>https://chaingng.github.io/post/srm-419-div1-easy---undo-/</link>
      <pubDate>Sat, 09 May 2015 15:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-419-div1-easy---undo-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10054&amp;amp;rd=13510
２つの操作の列が与えられる。
操作は以下の２種類。
・type a 与えられたアルファベット（ここではa）をタイプする
・undo x　x秒前までの操作を取り消す。
このとき、最後のこった文字列を求める。
解き方 
操作は右側の操作によって打ち消されるので、
右側の方から取り消される操作を調べていく。
残ったタイプの操作が最後に残る文字列となる。
コード 
class Undo {
public: string getText(vector&amp;lt;string&amp;gt; commands, vector&amp;lt;int&amp;gt; time) {
int n=commands.size();
int used[n];
memset(used,0,sizeof(used));
for(int i=n-1;i&amp;gt;=0;i--)if(!used[i]){
stringstream out(commands[i]);
string c;
int num;
out&amp;gt;&amp;gt;c&amp;gt;&amp;gt;num;
if(c==&#34;undo&#34;){
int e=time[i]-num;
used[i]=1;
for(int j=i-1;j&amp;gt;=0;j--)if(e&amp;lt;=time[j])used[j]=1;
}
}
string ret=&#34;&#34;;
for(int i=0;i&amp;lt;n;i++)if(!used[i]){
stringstream out(commands[i]);
string tmp;
char ch;
out&amp;gt;&amp;gt;tmp&amp;gt;&amp;gt;ch;
ret+=ch;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 423 DIV1 Easy - TheTower x</title>
      <link>https://chaingng.github.io/post/srm-423-div1-easy---thetower-x/</link>
      <pubDate>Sat, 09 May 2015 15:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-423-div1-easy---thetower-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9976&amp;amp;rd=13514
（x、y）の点がN個与えられる。
この点を１個～N個までそれぞれ同じ位置にあるよう移動させるときの、
それぞれの最小移動数を求める。
解き方 
各点の移動距離が最小となるx、y座標は、
与えられたx、y座標のいずれかになる。
よって、与えられたx、y座標のすべてを始点としたときの
移動距離が最小のものを更新していって求める。
コード 
class TheTower {
public: vector&amp;lt;int&amp;gt; count(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
int n=x.size();
vector&amp;lt;int&amp;gt; ans(n,1e+9);
FORE(i,0,n)FORE(j,0,n){
vector&amp;lt;int&amp;gt; vx;
FORE(k,0,n)vx.push_back(abs(x[i]-x[k])+abs(y[j]-y[k]));
sort(all(vx));
int sum=0;
FORE(k,0,n){
sum+=vx[k];
ans[k]=min(ans[k],sum);
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 424 DIV1 Easy - ProductOfDigits x</title>
      <link>https://chaingng.github.io/post/srm-424-div1-easy---productofdigits-x/</link>
      <pubDate>Sat, 09 May 2015 15:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-424-div1-easy---productofdigits-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10177&amp;amp;rd=13515
ある整数Nが与えられる。
各桁の数の積がNになる整数について、
その最小の桁数を求める。
解き方 
Nを９から１で順番に割れるか確かめていって、その商の数が桁数になる。
コード 
class ProductOfDigits {
public: int smallestNumber(int N) {
int ret=0;
for(int i=9;i&amp;gt;1;i--){
while(N%i==0)N/=i,ret++;
}
if(N!=1)return -1;
if(ret==0)return 1;
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 413 DIV1 Easy - ArithmeticProgression</title>
      <link>https://chaingng.github.io/post/srm-413-div1-easy---arithmeticprogression/</link>
      <pubDate>Sat, 09 May 2015 15:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-413-div1-easy---arithmeticprogression/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9839&amp;amp;rd=13504
整数の数列が与えられる。
与えられた数列は、ある実数が公差である数列について小数点以下の数を
切り捨てたものになる。
このとき、公差がいくつであるか求める。
解き方 
公差について、２分探索を用いればよい。
コード 
int n;
class ArithmeticProgression {
public:
int ispossible(double x,int a0,vector&amp;lt;int&amp;gt; seq){
double cur=a0;
FORE(i,0,n){
cur+=x;
if(floor(cur)==seq[i])continue;
if(floor(cur)&amp;gt;seq[i])return 1;
return -1;
}
return 0;
}
double minCommonDifference(int a0, vector&amp;lt;int&amp;gt; seq) {
if(seq.empty())return 0.0;
n=seq.size();
double low=seq[0]-a0,high=low+1.0;
if(low&amp;lt;0)return -1;
FORE(i,0,100){
double mid=(low+high)/2;
if(ispossible(mid,a0,seq)&amp;gt;=0)high=mid;
else low=mid;
}
return ispossible(high,a0,seq)==0 ? high : -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 658 DIV2 Hard - OddEvenTreeHard</title>
      <link>https://chaingng.github.io/post/srm-658-div2-hard---oddeventreehard/</link>
      <pubDate>Wed, 06 May 2015 12:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-658-div2-hard---oddeventreehard/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13784&amp;amp;rd=16461
Div1 Easyでノード間の情報が？となっている場合が追加されている。
解き方 
まずは以下について判定し、有効な木か判定する。
・自分のノードへのエッジはOではない
・エッジi~jとj~iは等しい
上記を満たす場合について、以下について判定し？が特定できる場合は埋めていく。
・あるノードからの距離が偶数同士のノード間距離は偶数
・あるノードからの距離が偶数と奇数のノード間距離は奇数
・あるノードからの距離が奇数同士のノード間距離は偶数
上記で？が存在する場合は、一つをOにして、？がなくなるまでDFSで判定していく。最後にすべての状態がわかるので、そこからひとつのエッジ集合を返してあげればよい。
コード 
int d[60],n;
vector&amp;lt;string&amp;gt; x;
class OddEvenTreeHard {
public:
bool dfs(){
FORE(i,0,n)FORE(j,0,n){
int update=0;
if(x[i][j]==&#39;?&#39;){
if(d[i]!=-1 &amp;amp;&amp;amp; d[j]!=-1){
x[i][j]= (d[i]^d[j]) ? &#39;O&#39; : &#39;E&#39;;
x[j][i]=x[i][j];
update=1;
}
}
else{
int cur= x[i][j]==&#39;O&#39; ? 1 : 0;
if(d[i]!=-1 &amp;amp;&amp;amp; d[j]!=-1){
if(cur!=(d[i]^d[j]))return false;
}
else if(d[i]!=-1 &amp;amp;&amp;amp; d[j]==-1)d[j]=(cur^d[i]),update=1;
else if(d[i]==-1 &amp;amp;&amp;amp; d[j]!=-1)d[i]=(cur^d[j]),update=1;
}
if(update)dfs();
}
return true;</description>
    </item>
    
    <item>
      <title>SRM 488 DIV1 Easy - OddEvenTree x</title>
      <link>https://chaingng.github.io/post/srm-488-div1-easy---oddeventree-x/</link>
      <pubDate>Wed, 06 May 2015 12:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-488-div1-easy---oddeventree-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13759&amp;amp;rd=16461
N個のノード、N-1のエッジからなる木がある。
どのノードとエッジが接続しているかわからないが、各ノード間の距離が
偶数ならE,奇数ならOであるという情報が与えられている。
このとき、与えられた情報で木が再現できるならそのエッジの例を一つ出力する。
そうでない場合はー１を返す。
解き方 
まずは木でつながっていることから、一つの木（例えばノード０）からのエッジが
すべてEなら再現できない。
上記を満たす場合、一つのノード０を基準にして、
・ノード０からの距離が偶数同士のノード間エッジはE
・偶数と奇数であればO
・奇数同士であればE
であるか判定し、存在する場合は一つのエッジO（例えばノード０～ノード３）
を固定して、そこからエッジを伸ばしていけば有効なエッジの集合となる。
コード 
class OddEvenTree {
public: vector&amp;lt;int&amp;gt; getTree(vector&amp;lt;string&amp;gt; x) {
int n=x.size();
int d[n];
vector&amp;lt;int&amp;gt; invalid(1,-1);
int flag=1;
FORE(i,0,n)if(x[0][i]==&#39;O&#39;)flag=0;
if(flag)return invalid;
FORE(i,0,n)d[i]=(x[0][i]==&#39;O&#39;);
FORE(i,0,n)FORE(j,0,n){
int cur=(x[i][j]==&#39;O&#39;);
if(cur!=(d[i]^d[j]))return invalid;
}
int r0=0,r1;
FORE(i,0,n)if(x[0][i]==&#39;O&#39;)r1=i;
vector&amp;lt;int&amp;gt; ans;
ans.push_back(r0),ans.push_back(r1);
FORE(i,1,n)if(i!=r1){
if(d[i]){
ans.push_back(r0),ans.push_back(i);
}else{
ans.push_back(i),ans.push_back(r1);
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 475 DIV1 Easy - RabbitStepping</title>
      <link>https://chaingng.github.io/post/srm-475-div1-easy---rabbitstepping/</link>
      <pubDate>Tue, 05 May 2015 23:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-475-div1-easy---rabbitstepping/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10878&amp;amp;rd=14156
１次元のセルがあり、赤、白、黒のいずれかの色が塗られている。
またセルのうちいくつかにうさぎがいる。
各ターンごとに、うさぎはそのセルの色と場所によって動く場所が決まる。
・一番右もしくはその右のセルにいるときは左へ
・一番左にいるときは右へ
そうでないときは以下に従って動く。
・白のとき、ひとつ左に移動
・黒のとき、ひとつ右に移動
・赤のとき、最初のステップであれば左に、そうでなければ前のステップにいた場所へ移動
各ターン終了後、一番右のセルは消滅し、セルの長さが２になったときに終了する。
さまざまなうさぎの初期位置が考えられるとき、最後に残るうさぎの数の
期待値を求める。
解き方 
実装の問題。
すべてのうさぎの初期位置に対して、間違いのないようシンプルに実装する。
コード 
class RabbitStepping {
public: double getExpected(string field, int r) {
int n=field.size();
double cnt=0,sum=0;
for(int mask=0;mask&amp;lt;(1&amp;lt;&amp;lt;n);mask++){
if(__builtin_popcount(mask)!=r)continue;
sum++;
vector&amp;lt;int&amp;gt; prev(r,-1),cur(r),next(r,-1);
int at=0;
for(int i=0;i&amp;lt;n;i++)if(mask&amp;amp;(1&amp;lt;&amp;lt;i))cur[at++]=i;
for(int len=n;len&amp;gt;2;len--){
FORE(i,0,r)if(cur[i]!=-1){
if(cur[i]==0)next[i]=1;
else if(cur[i]==len-1||cur[i]==len-2)next[i]=cur[i]-1;
else{
if(field[cur[i]]==&#39;W&#39;)next[i]=cur[i]-1;
if(field[cur[i]]==&#39;B&#39;)next[i]=cur[i]+1;
if(field[cur[i]]==&#39;R&#39;)next[i]= len==n ? cur[i]-1 : prev[i];
}
}
FORE(i,0,len){
int tmp=0;
FORE(j,0,r)if(next[j]==i)tmp++;
if(tmp&amp;gt;=2)FORE(j,0,r)if(next[j]==i)next[j]=-1;
}
FORE(i,0,r)if(next[i]==len-1)next[i]=-1;
prev=cur;</description>
    </item>
    
    <item>
      <title>SRM 432 DIV1 Easy - LampsGrid ○</title>
      <link>https://chaingng.github.io/post/srm-432-div1-easy---lampsgrid-/</link>
      <pubDate>Tue, 05 May 2015 23:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-432-div1-easy---lampsgrid-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10154&amp;amp;rd=13694
１と０からなるランプが複数並べられている。
各ランプは１行から成り、すべてのランプが一列に並べられている。
ランプの値がすべて１となったとき、そのランプは点灯する。
プレイヤーはK回、一つの列を選んでそのすべての値を反転させる。
このとき、点灯するランプが最大となるときのそのランプ数を求める。
解き方 
０１の並びがまったく同じランプだけが、最終的に同時に点灯する可能性がある。
すべての並びのランプについて、その０の値とKの値によってすべて点灯させられるか
確かめればよい。
コード 
class LampsGrid {
public: int mostLit(vector&amp;lt;string&amp;gt; initial, int K) {
int n=initial.size(),m=initial[0].size();
int ret=0;
FORE(i,0,n){
int cnt=0,num=0;
FORE(j,0,n)if(initial[i]==initial[j])cnt++;
FORE(j,0,m)if(initial[i][j]==&#39;0&#39;)num++;
if(K&amp;gt;=num &amp;amp;&amp;amp; (K-num)%2==0)ret=max(ret,cnt);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 487 DIV1 Easy - BunnyComputer x</title>
      <link>https://chaingng.github.io/post/srm-487-div1-easy---bunnycomputer-x/</link>
      <pubDate>Tue, 05 May 2015 23:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-487-div1-easy---bunnycomputer-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11157&amp;amp;rd=14240
Bコンピュータをすべてのうさぎが使いたい。
ただしBコンピュータは１台しかないため、１度に１匹のうさぎしか使えない。
うさぎがタスクをこなすのに、１秒Bコンピュータを専有し、その後K秒机上で計算を行い、その後１秒コンピュータを専有する。
コンピュータを専有する時間によってpreferenceの値が与えられ、この時間を最大化したい。
その最大値を求める。
解き方 
スタート時間を０〜Kとし、各スタート時間に対しK+1秒ごとに同じ集合に
することができる。
この集合ごとに得られるpreferenceを最大化し、その和を求める。
各集合についてpreferenceを最大化する選び方は貪欲法では難しいので
dpを用いればよい。
コード 
class BunnyComputer {
public: int getMaximum(vector&amp;lt;int&amp;gt; preference, int k) {
int n=preference.size();
int ret=0;
for(int i=0;i&amp;lt;k+1;i++){
vector&amp;lt;int&amp;gt; vx;
for(int j=i;j&amp;lt;n;j+=k+1)vx.push_back(preference[j]);
int m=vx.size();
int dp[m+1];
memset(dp,0,sizeof(dp));
for(int j=2;j&amp;lt;=m;j++){
dp[j]=max(dp[j],dp[j-1]);
dp[j]=max(dp[j],dp[j-2]+vx[j-2]+vx[j-1]);
}
ret+=dp[m];
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 483 DIV1 Easy - BestApproximationDiv1 ○</title>
      <link>https://chaingng.github.io/post/srm-483-div1-easy---bestapproximationdiv1-/</link>
      <pubDate>Tue, 05 May 2015 19:07:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-483-div1-easy---bestapproximationdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11023&amp;amp;rd=14236
ある小数が与えられる。
この小数と、接頭辞が最も多く一致する、分母がmaxDen以下の分数と
それが何桁一致するかを求める。
そのような分数が複数存在する場合は、最も分母が小さいもの、
分母が一緒であれば分子が最も小さいものを求める。
解き方 
分母の数が１０００なのでO(10^6)となり、全探索で求められる。
コード 
class BestApproximationDiv1 {
public:
int calc(string s1,string s2){
int ret=1;
FORE(i,0,s1.size()){
if(s1[i]==s2[i])ret++;
else break;
}
return ret;
}
string findFraction(int maxDen, string number) {
int a=1000,b=1000,score=-1;
for(int i=1;i&amp;lt;=maxDen;i++)for(int j=0;j&amp;lt;i;j++){
int x=(int)(1000000.0*j/i);
stringstream out;
string str;
out&amp;lt;&amp;lt;x;
out&amp;gt;&amp;gt;str;
while(str.size()&amp;lt;6)str=&#39;0&#39;+str;
int tmp=calc(str,number.substr(2));
if(tmp&amp;gt;score){
a=j,b=i,score=tmp;
}
}
char ch[100];
sprintf(ch,&#34;%d/%d has %d exact digits&#34;,a,b,score);
return ch;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 486 DIV1 Easy - OneRegister</title>
      <link>https://chaingng.github.io/post/srm-486-div1-easy---oneregister/</link>
      <pubDate>Tue, 05 May 2015 19:03:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-486-div1-easy---oneregister/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10992&amp;amp;rd=14239
ある整数sからtに変換したい。
変換には＋、＊、ー、／の４つの操作があり、＋は現在の数と同じ数を足し、
＊は現在の数と同じ数をかけ、ーは現在の数と同じ数を引き、／は同じ数を割る。
このとき、ｔに変換したときの操作手順を返す。
複数の操作手順があるときは少ない手順数のものを、同じ手順数であれば
辞書順で最小のものを返す。
そのような手順がないときは”:-(”を返す。
解き方 
まず、ーにしたときは０となり、答えは１以上であるためーは使用しない。
次に、＋と＊の操作をしたときは
操作後の数がtから割れる数にならなければならない。
このような数について、幅優先探索で調べていく。
また、／は数を１にして調べていくので、最初に／がある場合も
一緒に調べればよい。
コード 
class OneRegister {
public: string getProgram(int s, int t) {
if(s==t)return &#34;&#34;;
map&amp;lt;long long,string&amp;gt; m;
string ret=&#34;&#34;;
queue&amp;lt;pair&amp;lt;long long,string&amp;gt; &amp;gt; q;
q.push(make_pair(s,&#34;&#34;));
q.push(make_pair(1,&#34;/&#34;));
while(!q.empty()){
long long x=q.front().first;
string str=q.front().second;
q.pop();
if(x==t){
if(ret.empty() || ret.size()&amp;gt;str.size() ||
(ret.size()==str.size() &amp;amp;&amp;amp; ret&amp;gt;str))ret=str;
}
if(t%(x*2)==0){
q.push(make_pair(x*2,str+&#39;+&#39;));
}
if(x!=1 &amp;amp;&amp;amp; t%(x*x)==0){
q.push(make_pair(x*x,str+&#39;*&#39;));
}
}
return !ret.empty() ?</description>
    </item>
    
    <item>
      <title>SRM 420 DIV1 Easy - SolitaireSimulation ○</title>
      <link>https://chaingng.github.io/post/srm-420-div1-easy---solitairesimulation-/</link>
      <pubDate>Tue, 05 May 2015 18:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-420-div1-easy---solitairesimulation-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9917&amp;amp;rd=13511
カードが数枚ずつ山になって積まれている。
各ターン、すべての山から１枚ずつカードをとって、そのカードで
一つ山を追加する操作を繰り返す。
この操作を繰り返したとき必ずもとの配列にもどる周期が必ず存在し、
そのような周期はいくつであるか求める。
解き方 
問題の通り実装する。
各操作ごとにカードの配列を保存し、最初に同じ配列が
改めて出現した時にそのターン数の差分を飼えしてあげればよい。
コード 
class SolitaireSimulation {
public: int periodLength(vector&amp;lt;int&amp;gt; heaps) {
map&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt; m;
sort(all(heaps));
m[heaps]=0;
int turn=0;
while(1){
turn++;
vector&amp;lt;int&amp;gt; tmp;
for(int i=0;i&amp;lt;heaps.size();i++){
if(heaps[i]-1&amp;gt;0)tmp.push_back(heaps[i]-1);
}
tmp.push_back(heaps.size());
sort(all(tmp));
heaps=tmp;
if(m.find(heaps)==m.end())m[heaps]=turn;
else return turn-m[heaps];
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 444 DIV1 Easy - UnfoldingTriangles ○</title>
      <link>https://chaingng.github.io/post/srm-444-div1-easy---unfoldingtriangles-/</link>
      <pubDate>Tue, 05 May 2015 18:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-444-div1-easy---unfoldingtriangles-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10484&amp;amp;rd=13898
白と黒の２種類からなる２次元のセルがある。
ただし、そのうちのいくつかの黒のセルは折られており、左半分が白、右半分が
黒になっている。
ここからUnfoldlimit数だけ折られているセルを黒のセルに戻すことができる。
このとき、作ることのできる最大の三角形のセルの数を求める。
ただし、三角形は左上がすべて斜めのセルであり、右辺と下の辺は端、もしくは
白のセルで区切られており、中のセルはすべて黒のものとなる。
解き方 
実装問題。上記の条件をコードに落とし込んでシンプルに実装する。
コード 
int h,w;
class UnfoldingTriangles {
public:
bool can(vector&amp;lt;string&amp;gt; grid,int unfoldLimit,int r,int c,int len){
if(r+1&amp;lt;h)for(int j=c;j&amp;lt;c+len;j++)if(grid[r+1][j]==&#39;#&#39;)return false;
if(c+len&amp;lt;w)for(int i=r;i&amp;gt;=r-len+1;i--)if(grid[i][c+len]==&#39;#&#39;)return false;
for(int j=c;j&amp;lt;c+len;j++)if(grid[r-(j-c)][j]!=&#39;/&#39;)return false;
int cnt=0;
for(int j=c;j&amp;lt;c+len;j++){
for(int i=r;i&amp;gt;r-(j-c);i--){
if(grid[i][j]==&#39;/&#39;)cnt++;
if(grid[i][j]==&#39;.&#39;)return false;
}
}
return unfoldLimit&amp;gt;=cnt;
}
int solve(vector&amp;lt;string&amp;gt; grid, int unfoldLimit) {
h=grid.size(),w=grid[0].size();
int ret=-1;
FORE(i,0,h)FORE(j,0,w){
for(int len=1;len&amp;lt;=i+1&amp;amp;&amp;amp;len&amp;lt;=w-j;len++){
if(can(grid,unfoldLimit,i,j,len)){
int score= len==1 ? 1 : len*(len+1)/2;</description>
    </item>
    
    <item>
      <title>SRM 446 DIV1 Easy - CubeWalking ○</title>
      <link>https://chaingng.github.io/post/srm-446-div1-easy---cubewalking-/</link>
      <pubDate>Tue, 05 May 2015 18:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-446-div1-easy---cubewalking-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10515&amp;amp;rd=13900
六面体のキューブがある。
キューブの各面は３＊３のセルからなり、
真ん中が緑、その上下左右が青、その他は赤色に塗られている。
プレイヤーは最初緑のセルからスタートし、いずれかの方向を向いている。
そこから左に向く、右に向く、前に進むの３種類のコマンドからなる
行動リストが与えられる。
このとき、最終的にいる位置のセルの色を求める。
解き方 
キューブを展開して無限のセルの集合と考える。
このとき、最後の位置が最初の位置とｘ座標、ｙ座標ともに３で割り切れれば緑、
どちらも割り切れないなら赤、どちらでもなければ青色になる。
コード 
class CubeWalking {
public: string finalPosition(string movement) {
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
int dir=0;
int x=0,y=0;
FORE(i,0,movement.size()){
if(movement[i]==&#39;L&#39;)dir--;
else if(movement[i]==&#39;R&#39;)dir++;
else{
x+=dx[((dir%4)+4)%4],y+=dy[((dir%4)+4)%4];
}
}
if(x%3==0 &amp;amp;&amp;amp; y%3==0)return &#34;GREEN&#34;;
if(x%3!=0 &amp;amp;&amp;amp; y%3!=0)return &#34;RED&#34;;
return &#34;BLUE&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 452 DIV1 Easy - NotTwo ○</title>
      <link>https://chaingng.github.io/post/srm-452-div1-easy---nottwo-/</link>
      <pubDate>Tue, 05 May 2015 18:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-452-div1-easy---nottwo-/</guid>
      <description>問題 
H＊Wの大きさである２次元の座標があり、そこにできるだけ多くの
石を置きたい。
ただし、それぞれの石の距離についてユークリッド距離が２にならないようにしたい。
このとき、最も多くおける石の個数を求める。
解き方 
ユークリッド距離が２になりうるセルについて、４つの区間に分けることができる。
この区間はそれぞれどのような石の置かれ方をされてもユークリッド距離が
２になることはない。
あとは、各区間について置ける最大の石の個数を求めればよい。
区間中のセルの数をDFSで求め、その（セルの数＋１）／２が
置くことができる最大の石の個数となる。
コード 
int used[1010][1010];
int dr[]={2,0,-2,0},dc[]={0,2,0,-2};
int w,h,cnt;
class NotTwo {
public:
void dfs(int r,int c){
used[r][c]=1;
cnt++;
FORE(i,0,4){
int nr=r+dr[i],nc=c+dc[i];
if(0&amp;lt;=nr &amp;amp;&amp;amp; nr&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=nc &amp;amp;&amp;amp; nc&amp;lt;w &amp;amp;&amp;amp; !used[nr][nc]){
dfs(nr,nc);
}
}
}
int maxStones(int width, int height) {
int ret=0;
w=width,h=height;
memset(used,0,sizeof(used));
FORE(i,0,height)FORE(j,0,width)if(used[i][j]==0){
cnt=0;
dfs(i,j);
ret+=(cnt+1)/2;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 418 DIV1 Easy - TwoLotteryGames ○</title>
      <link>https://chaingng.github.io/post/srm-418-div1-easy---twolotterygames-/</link>
      <pubDate>Tue, 05 May 2015 18:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-418-div1-easy---twolotterygames-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10071&amp;amp;rd=13509
ｎ個のくじからm個選ぶ。
相手も同様にm個選ぶ。
選んだくじのうち、相手がえらんだくじとk個一致していれば勝ちとなる。
このとき、勝ちとなる確率を求める。
解き方 
ｎが８と小さいので、全探索すればよいだけ。
コード 
class TwoLotteryGames {
public: double getHigherChanceGame(int n, int m, int k) {
double ret=0.0,sum=0.0;
for(int i=1;i&amp;lt;1&amp;lt;&amp;lt;n;i++)if(__builtin_popcount(i)==m){
for(int j=1;j&amp;lt;1&amp;lt;&amp;lt;n;j++)if(__builtin_popcount(j)==m){
sum++;
if(__builtin_popcount(i&amp;amp;j)&amp;gt;=k)ret++;
}
}
return ret/sum;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 450 DIV1 Easy - OrderedNim ○</title>
      <link>https://chaingng.github.io/post/srm-450-div1-easy---orderednim-/</link>
      <pubDate>Mon, 04 May 2015 22:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-450-div1-easy---orderednim-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10190&amp;amp;rd=13904
Nimを少し変化させたゲームがあり、
ある山についてそれよりも左の山が存在する時は選ぶことができない。
山が与えられたとき、２人のうちどちらが勝つか求める。
解き方 
左側からしか山を選ぶことができないので、
その中で法則がないか考察する。
まず、すべて１のときは選び方が一様なので
配列数が偶数のときはBob,そうでないときはAliceが勝つ。
次に、すべて１でないときは最初に２以上の山が当たられた方が
その後の順番をコントロールできるので、その選択権を持った方が勝ちとなる。
コード 
class OrderedNim {
public: string winner(vector&amp;lt;int&amp;gt; layout) {
int n=layout.size();
FORE(i,0,n)if(layout[i]!=1){
return i%2 ? &#34;Bob&#34; : &#34;Alice&#34;;
}
return n%2 ? &#34;Alice&#34; : &#34;Bob&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 451 DIV1 Easy - MagicalSource x</title>
      <link>https://chaingng.github.io/post/srm-451-div1-easy---magicalsource-x/</link>
      <pubDate>Mon, 04 May 2015 21:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-451-div1-easy---magicalsource-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10635&amp;amp;rd=13905
ある整数が与えられ、下のように同じ数が段になって足されているとき、
そのような元の数の最小値を求める。
１２
１２
ーーー
１３２
解き方 
最後の一桁を固定して、すべての元の数の桁数で全探索して・・・と
考えたくなるが、段になって足されているということは
元の数に１１、１１１、１１１１・・・のいずれかの数が
かけられたものになる。
よって、１、１１、１１１・・・と割っていき
割りきれるもののうち最小の商が答えになる。
コード 
class MagicalSource {
public: long long calculate(long long x) {
long long ret=x;
long long p=1LL;
while(p&amp;lt;x){
p=p*10+1;
if(x%p==0)ret=min(ret,x/p);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 453.5 DIV1 Easy - MazeMaker</title>
      <link>https://chaingng.github.io/post/srm-453.5-div1-easy---mazemaker/</link>
      <pubDate>Mon, 04 May 2015 21:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-453.5-div1-easy---mazemaker/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10451&amp;amp;rd=14174
迷路とプレイヤーが１ターンで移動できる方向のマスが与えられる。
このとき、プレイヤーがゴールできない位置、もしくはゴールできるときは
一番遠い位置にゴールを置きたい。
ゴールできない位置におけるときはー１を、そうでないときは
もっとも遠いターン数を求める。
解き方 
幅優先探索で全探索すればよい。
幅優先探索なのでセルの値の更新は一度だけでよい。
コード 
class MazeMaker {
public: int longestPath(vector&amp;lt;string&amp;gt; maze, int startRow, int startCol, vector&amp;lt;int&amp;gt; moveRow, vector&amp;lt;int&amp;gt; moveCol) {
int h=maze.size(),w=maze[0].size(),n=moveRow.size();
int used[h][w];
memset(used,-1,sizeof(used));
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
q.push(make_pair(startRow,startCol));
used[startRow][startCol]=0;
while(!q.empty()){
int r=q.front().first;
int c=q.front().second;
int turn=used[r][c];
q.pop();
FORE(i,0,n){
int nr=r+moveRow[i],nc=c+moveCol[i];
if(0&amp;lt;=nr &amp;amp;&amp;amp; nr&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=nc &amp;amp;&amp;amp; nc&amp;lt;w &amp;amp;&amp;amp; maze[nr][nc]!=&#39;X&#39; &amp;amp;&amp;amp; used[nr][nc]==-1){
q.push(make_pair(nr,nc));
used[nr][nc]=turn+1;
}
}
}
int ret=0;
FORE(i,0,h)FORE(j,0,w)if(maze[i][j]==&#39;.&#39;){</description>
    </item>
    
    <item>
      <title>SRM 457 DIV1 Easy - TheTriangleBothDivs</title>
      <link>https://chaingng.github.io/post/srm-457-div1-easy---thetrianglebothdivs/</link>
      <pubDate>Mon, 04 May 2015 21:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-457-div1-easy---thetrianglebothdivs/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10696&amp;amp;rd=14144
”17:45 GMT-4”と時刻を表す時計がある。
ただし時計の一部が壊れており、その箇所は？になっている。
このとき、考えられる昇順で一番早い時間を求める。
解き方 
法則を考えると大変なため、全探索を用いる必要があるのがわかる。
ここでのコツは、すべての数字を前端さ区しようとするのではなくて
すべての文字列を発生させて全探索する。
コード 
string ret;
class TheTriangleBothDivs {
public:
void rec(string time, int pos){
if(pos&amp;gt;=time.size()){
int h=(time[0]-&#39;0&#39;)*10+(time[1]-&#39;0&#39;);
int m=(time[3]-&#39;0&#39;)*10+(time[4]-&#39;0&#39;);
int d=time[10]-&#39;0&#39;;
if(time[9]==&#39;-&#39; &amp;amp;&amp;amp; d==0)return;
if(h&amp;gt;=24 || m&amp;gt;=60)return;
if(time[9]==&#39;-&#39;)d=-d;
char ch[50];
sprintf(ch,&#34;%02d:%02d&#34;,((h-d)+24)%24,m);
if(ch&amp;lt;ret)ret=ch;
}else if(time[pos]==&#39;?&#39;){
string str=&#34;0123456789&#34;;
if(pos==9)str=&#34;-+&#34;;
FORE(i,0,str.size()){
time[pos]=str[i];
rec(time,pos+1);
time[pos]=&#39;?&#39;;
}
}else rec(time,pos+1);
}
string fix(string time) {
ret=&#34;99:99&#34;;
rec(time,0);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 470 DIV1 Easy - DoorsGame ○</title>
      <link>https://chaingng.github.io/post/srm-470-div1-easy---doorsgame-/</link>
      <pubDate>Mon, 04 May 2015 21:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-470-div1-easy---doorsgame-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10915&amp;amp;rd=14153
AからPまでの16色のいずれかの色がついたドアがある。
Johnは最初左端におり、Brusは最初右端にいる。
Johnからスタートし、交互に好きな色を選んでいく。
選ばれた色のドアはすべてオープンする。
また、トロフィーが置かれている場所もわかっている。
このとき、Johnが勝つときはそのターン数を、
Brusが勝つときはそのターン数にー１をかけたものを、
引き分けのときは０を返す。
解き方 
色の選び方は最大１６！となり単純な全探索では解くことができない。
今回、JohnとBrusがドアを開けていくのに必要な情報は、
「john側だけにある色数」「Brus側だけにある色数」「両方にある色のドアの色数」
だけであり、各ドアの色の種類や数は関係ない。
上記の集合に変換することができれば、
あとは各プレイヤーが最適な戦略をとるようにして全探索で解くことができる。
コード 
class DoorsGame {
public: int determineOutcome(string doors, int trophy) {
int n=doors.size();
int a=0,b=0,common=0;
for(char ch=&#39;A&#39;;ch&amp;lt;=&#39;P&#39;;ch++){
int flaga=0,flagb=0;
for(int j=0;j&amp;lt;trophy;j++)if(doors[j]==ch)flaga=1;
for(int j=n-1;j&amp;gt;=trophy;j--)if(doors[j]==ch)flagb=1;
if(flaga &amp;amp;&amp;amp; flagb)common++;
else if(flaga)a++;
else if(flagb)b++;
}
int turn=0;
while(a+b+common&amp;gt;0){
turn++;
if(turn%2){
if(a&amp;gt;0)a--;
else if(common&amp;gt;0)common--;
else b--;
}
else{
if(b&amp;gt;0)b--;
else if(common&amp;gt;0)common--;
else a--;
}
if(a+b+common==0)return 0;</description>
    </item>
    
    <item>
      <title>SRM 474 DIV1 Easy - RouteIntersection</title>
      <link>https://chaingng.github.io/post/srm-474-div1-easy---routeintersection/</link>
      <pubDate>Mon, 04 May 2015 21:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-474-div1-easy---routeintersection/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10804&amp;amp;rd=14185
N個の次元があり、最初はすべての次元について位置０からスタートする。
各ステップについて、どの次元の座標を＋ーするか与えられる。
このとき、ステップ中にすでに通った道に戻るときはInvalidを、
そうでないときはvalidを返す。
解き方 
Nが大きく配列に保存できないため、必要な配列だけを保存する。
同じ場所にもどってくるかどうかは、ある地点を基準にして
各エリアの＋ーがすべて０になったときとなる。
上記ついてすべての地点で判定してあげれば良い。
コード 
class RouteIntersection {
public: string isValid(int N, vector&amp;lt;int&amp;gt; coords, string moves) {
int len=coords.size();
FORE(i,0,len){
map&amp;lt;int,int&amp;gt; m;
FORE(j,i,len){
if(moves[j]==&#39;+&#39;)m[coords[j]]++;
else m[coords[j]]--;
int invalid=1;
for(map&amp;lt;int,int&amp;gt;::iterator it=m.begin();it!=m.end();it++){
if(it-&amp;gt;second!=0)invalid=0;
}
if(invalid)return &#34;NOT VALID&#34;;
}
}
return &#34;VALID&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 477 DIV1 Easy - Islands</title>
      <link>https://chaingng.github.io/post/srm-477-div1-easy---islands/</link>
      <pubDate>Mon, 04 May 2015 21:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-477-div1-easy---islands/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10874&amp;amp;rd=14157
六角形で表されるlandとwaterのエリアがあり、
その接点がビーチとなる。
地形が与えられたとき、存在するビーチの数を求める。
解き方 
ビーチとなる条件を判定文に落とし込んで実装するだけ。
まず、ビーチはlandとwaterひとつずつに接する場合なので
landについて調べることで重複なく調べられる。
あとは、高さのMOD2が０のときと１のときの条件を落としこんで
実装してあげれば良い。
コード 
class Islands {
public: int beachLength(vector&amp;lt;string&amp;gt; kingdom) {
int h=kingdom.size(),w=kingdom[0].size();
int ret=0;
FORE(i,0,h)FORE(j,0,w)if(kingdom[i][j]==&#39;#&#39;){
if(j-1&amp;gt;=0 &amp;amp;&amp;amp; kingdom[i][j-1]==&#39;.&#39;)ret++;
if(j+1&amp;lt;w &amp;amp;&amp;amp; kingdom[i][j+1]==&#39;.&#39;)ret++;
if(i-1&amp;gt;=0 &amp;amp;&amp;amp; kingdom[i-1][j]==&#39;.&#39;)ret++;
if(i+1&amp;lt;h &amp;amp;&amp;amp; kingdom[i+1][j]==&#39;.&#39;)ret++;
if(i%2==0 &amp;amp;&amp;amp; j-1&amp;gt;=0 &amp;amp;&amp;amp; i+1&amp;lt;h &amp;amp;&amp;amp; kingdom[i+1][j-1]==&#39;.&#39;)ret++;
if(i%2==0 &amp;amp;&amp;amp; j-1&amp;gt;=0 &amp;amp;&amp;amp; i-1&amp;gt;=0 &amp;amp;&amp;amp; kingdom[i-1][j-1]==&#39;.&#39;)ret++;
if(i%2 &amp;amp;&amp;amp; j+1&amp;lt;w &amp;amp;&amp;amp; i+1&amp;lt;h &amp;amp;&amp;amp; kingdom[i+1][j+1]==&#39;.&#39;)ret++;
if(i%2 &amp;amp;&amp;amp; j+1&amp;lt;w &amp;amp;&amp;amp; i-1&amp;gt;=0 &amp;amp;&amp;amp; kingdom[i-1][j+1]==&#39;.&#39;)ret++;
}
return ret;</description>
    </item>
    
    <item>
      <title>SRM 476 DIV1 Easy - Badgers ○</title>
      <link>https://chaingng.github.io/post/srm-476-div1-easy---badgers-/</link>
      <pubDate>Mon, 04 May 2015 21:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-476-div1-easy---badgers-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10797&amp;amp;rd=14186
動物BadgersがN匹おり、できるだけ多く飼いたい。
ただし１日に与えられる餌がtotalFoodしかないため、この餌の中で
できるだけ多くの動物を飼うようにしたい。
各Badgersは一人でいるときに必要な餌の数hungerと、複数匹飼われたときに
追加で必要な餌greedが与えられる。
例えば４匹飼われた際はhunger+greed*3の餌が必要になる。
このとき、最大で何匹のBadgersが飼えるか求める。
解き方 
Nは50のため、すべての組み合わせは確かめられない。
ここで、何匹買うかの情報を固定すると、そのときに必要な餌の量は
固定値となるため、貪欲法で求めることができる。
よって、飼う匹数を１〜Nまで固定して、
それぞれについて貪欲法で選んだ時にtotalFoodに収まる
最大の匹数を求めればよい。
コード 
class Badgers {
public: int feedMost(vector&amp;lt;int&amp;gt; hunger, vector&amp;lt;int&amp;gt; greed, int totalFood) {
int n=hunger.size();
int ret=0;
for(int num=1;num&amp;lt;=n;num++){
vector&amp;lt;int&amp;gt; vx;
FORE(i,0,n){
int cost=hunger[i]+greed[i]*(num-1);
vx.push_back(cost);
}
sort(all(vx));
int sum=0;
FORE(i,0,num)sum+=vx[i];
if(totalFood&amp;gt;=sum)ret=max(ret,num);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 481 DIV1 Easy - ChickenOracle △</title>
      <link>https://chaingng.github.io/post/srm-481-div1-easy---chickenoracle-/</link>
      <pubDate>Mon, 04 May 2015 21:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-481-div1-easy---chickenoracle-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11004&amp;amp;rd=14234
鶏が先か卵が先かという古典的な問題がある。
オラクルはどちらが答えかわかっており、ｎ人にその答えを伝えた。
ただし、liecount人には嘘の答えを教えている。
また、ｎ人について鶏と答えた人数と卵と答えた人数がわかっている。
ただし、liarcount人は教えられたものと違う答えを答えている。
このとき、答えが卵か鶏のどちらかを求める。
ただし、両方の場合が考えられる時はAmbiguousを、
オラクルが嘘をついているのであればThe oracle is a lieを返す。
解き方 
答えが卵である場合と、鶏である場合それぞれについて
最終的な数（卵が答えのときはｎ人ーliecount）はわかっている。
ただし、嘘をついている人が何人どちらの答えを教えられているかは、
様々な場合が考えられるため、
この人数について全探索して一致するかどうかを調べればよい。
コード 
class ChickenOracle {
public: string theTruth(int n, int e, int lieCount, int liarCount) {
int c=n-e;
int flagc=0,flage=0;
int tmpc=n-lieCount,tmpe=n-tmpc;
for(int move=0;move&amp;lt;=liarCount;move++){
if(move&amp;gt;tmpc || liarCount-move&amp;gt;tmpe)continue;
if(tmpc-move+(liarCount-move)==c || tmpe-(liarCount-move)+move==e){
flagc=1;
}
}
tmpe=n-lieCount,tmpc=n-tmpe;
for(int move=0;move&amp;lt;=liarCount;move++){
if(move&amp;gt;tmpc || liarCount-move&amp;gt;tmpe)continue;
if(tmpc-move+(liarCount-move)==c || tmpe-(liarCount-move)+move==e){
flage=1;
}
}
if(flagc &amp;amp;&amp;amp; flage)return &#34;</description>
    </item>
    
    <item>
      <title>SRM 480 DIV1 Easy - InternetSecurity ○</title>
      <link>https://chaingng.github.io/post/srm-480-div1-easy---internetsecurity-/</link>
      <pubDate>Mon, 04 May 2015 21:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-480-div1-easy---internetsecurity-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11064&amp;amp;rd=14159
N個のWebサイトがあり、その危険性を検証したい。
各Webサイトについて、サイトのアドレスと関連するキーワードが
わかっている。
また、危険なキーワードが複数与えられ、あるWebサイト中に
危険なキーワードがthreshold以上存在するとそのWebサイトは危険になる。
また、Webサイトが危険になると、そのサイトに関連する
すべてのキーワードも危険になる。
このとき、危険なWebサイトのアドレスすべてを昇順に並べたものを求める。
解き方 
実装問題なので、正確にかつシンプルなデータ構造で実装するだけ。
コード 
class InternetSecurity {
public: vector&amp;lt;string&amp;gt; determineWebsite(vector&amp;lt;string&amp;gt; address, vector&amp;lt;string&amp;gt; keyword, vector&amp;lt;string&amp;gt; dangerous, int threshold) {
int n=address.size();
int p[n];
memset(p,-1,sizeof(p));
set&amp;lt;string&amp;gt; d;
FORE(i,0,dangerous.size())d.insert(dangerous[i]);
string key[51][51];
FORE(i,0,51)FORE(j,0,51)key[i][j]=&#34;&#34;;
FORE(i,0,n){
stringstream out(keyword[i]);
int at=0;
while(out&amp;gt;&amp;gt;key[i][at++]);
}
int next=1;
while(next){
next=0;
FORE(i,0,n){
int cnt=0,at=0;
while(!key[i][at].empty()){
if(d.find(key[i][at])!=d.end())cnt++;
at++;
}
if(p[i]==-1 &amp;amp;&amp;amp; cnt&amp;gt;=threshold){
p[i]=cnt;
next=1;
int att=0;
while(!key[i][att].empty()){
d.insert(key[i][att++]);
}
}</description>
    </item>
    
    <item>
      <title>SRM 479 DIV1 Easy - TheCoffeeTimeDivOne</title>
      <link>https://chaingng.github.io/post/srm-479-div1-easy---thecoffeetimedivone/</link>
      <pubDate>Mon, 04 May 2015 21:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-479-div1-easy---thecoffeetimedivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11028&amp;amp;rd=14158
1列の席に座っている客にコーヒーか紅茶を提供したい。
１番めの席の横にサーブマシンがあり、そこで紅茶かコーヒーを７人分
入れることができる。入れるのには４７秒かかる。
また、お客に飲み物を提供するのに４秒かかる。
お客はコーヒーか紅茶どちらを要望しているかあらかじめわかっている。
このとき、すべてのお客に要望する飲み物を提供するのにかかる時間を求める。
解き方 
nは4*10^7。
配列を作るのにメモリは足りないが、全探索可能なので必要な配列だけを
作るように全探索すればよい。
コード 
class TheCoffeeTimeDivOne {
public: long long find(int n, vector&amp;lt;int&amp;gt; tea) {
int tn=tea.size();
long long ret=n*4LL;
ret+=47*((tn+6)/7)+47*((n-tn+6)/7);
sort(all(tea));
for(int i=tn-1;i&amp;gt;=0;i-=7)ret+=tea[i]*2;
set&amp;lt;int&amp;gt; s;
FORE(i,0,tn)s.insert(tea[i]);
int cnt=0;
for(int i=n;i&amp;gt;=1;i--){
if(s.find(i)!=s.end())continue;
if(cnt==0){
ret+=i*2LL;
cnt=7;
}
cnt--;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 454 DIV1 Easy - DoubleXor x</title>
      <link>https://chaingng.github.io/post/srm-454-div1-easy---doublexor-x/</link>
      <pubDate>Sun, 03 May 2015 22:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-454-div1-easy---doublexor-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10706&amp;amp;rd=13908
＾＾で表される演算がある。
これは１０進数で表される各桁のXORをとった後にその１０の余りが
各桁の数になる。
整数Nが与えられた時、N＾＾（N-1)＾＾（N-2)…^^1の値を求める。
解き方 
１からたどっていくと法則のようなものが見つかるが、
実際は(N^^(N^1))^^(N-1) とN^^((N^1)^^(N-1))は異なるためこの方法では解けない。
計算量は間に合うので、題意の通り実装して解く。
コード 
class DoubleXor {
public:
int calc(int x,int y){
int ret=0;
for(int p=1;x&amp;gt;0||y&amp;gt;0;x/=10,y/=10,p*=10){
ret+=(((x%10)^(y%10))%10)*p;
}
return ret;
}
int calculate(int N) {
int ret=N;
for(int i=N-1;i&amp;gt;=1;i--){
ret=calc(ret,i);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 456 DIV1 Easy - SilverDistance x</title>
      <link>https://chaingng.github.io/post/srm-456-div1-easy---silverdistance-x/</link>
      <pubDate>Sun, 03 May 2015 22:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-456-div1-easy---silverdistance-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10699&amp;amp;rd=13909
銀の動きをする駒がある。
２次元のセル上でスタート位置とゴール位置が与えられた時、
ゴールにたどりつくまでの最小のターン数を求める。
解き方 
☓の形で４つのエリアに分け、場合分けして求める方法があるが
複雑になってしまうためシステムで落ちやすくなる。
今回、セルをチェスのように白と黒で分けた時、
同じエリアであればｘとｙの位置の差の最大の方が答えになる。
エリアが異なる場合は、一つ上に移動することで同じエリアに移動することができる。
コード 
class SilverDistance {
public: int minSteps(int sx, int sy, int gx, int gy) {
int ret=0;
if((abs(gx-sx)-abs(gy-sy))%2)ret++,sy++;
ret+=max(abs(gx-sx),abs(gy-sy));
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 458 DIV1 Easy - BouncingBalls</title>
      <link>https://chaingng.github.io/post/srm-458-div1-easy---bouncingballs/</link>
      <pubDate>Sun, 03 May 2015 22:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-458-div1-easy---bouncingballs/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10726&amp;amp;rd=14180
１直線上に複数のボールが置かれている。
ボールの置かれている位置はあらかじめわかっている。
各ボールを同時に、それぞれ左右のどちらかに転がしたとき
T秒後にボールが衝突した回数の期待値を求める。
解き方 
ボールが衝突した時に左右に移動することは考えず、
すり抜けると考えることができる。
このとき、各ボールが左右に動くすべての場合に対し、
ボールのペアすべてに対し衝突しているかどうかカウントしていけばよい。
別解として、ボールのペアそれぞれについてカウントすることになるので
左右に動くすべての場合を求めずとも、
各ペアについて衝突する可能性があるなら０．２５を足していけば求められる。
コード 
class BouncingBalls {
public: double expectedBounces(vector&amp;lt;int&amp;gt; x, int T) {
int n=x.size();
sort(all(x));
double ret=0;
for(int mask=0;mask&amp;lt;(1&amp;lt;&amp;lt;n);mask++){
FORE(i,0,n)FORE(j,i+1,n){
if( (mask&amp;amp;(1&amp;lt;&amp;lt;i)) &amp;amp;&amp;amp; !(mask&amp;amp;(1&amp;lt;&amp;lt;j)) &amp;amp;&amp;amp; x[j]-x[i]&amp;lt;=2*T){
ret++;
}
}
}
return ret/(double)(1&amp;lt;&amp;lt;n);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 459 DIV1 Easy - Inequalities</title>
      <link>https://chaingng.github.io/post/srm-459-div1-easy---inequalities/</link>
      <pubDate>Sun, 03 May 2015 22:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-459-div1-easy---inequalities/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10682&amp;amp;rd=14145
不等式は複数与えられる。
与えられた不等式をできるだけ多く満たすような実数に対し
その満たす不等式の最大数を求める。
解き方 
不等式の数Xは０～１０００になる。
よってー１～１００１まで0.5刻みの数を考え、このすべてに対し
不等式をどれだけ満たすか求めてあげればよい。
実数に対して配列のインデックスと一致させるために、
実数＊２＋２と変換してあげれば配列を利用できる。
コード 
int num[2100];
class Inequalities {
public:
void calc(string str){
stringstream out(str);
string s1,s2;
int x;
out&amp;gt;&amp;gt;s1&amp;gt;&amp;gt;s2&amp;gt;&amp;gt;x;
if(s2==&#34;&amp;lt;&#34;)for(double i=-1;i&amp;lt;x;i+=0.5)num[(int)(i*2+2)]++;
if(s2==&#34;&amp;lt;=&#34;)for(double i=-1;i&amp;lt;=x;i+=0.5)num[(int)(i*2+2)]++;
if(s2==&#34;=&#34;)num[x*2+2]++;
if(s2==&#34;&amp;gt;&#34;)for(double i=x+0.5;i&amp;lt;=1005;i+=0.5)num[(int)(i*2+2)]++;
if(s2==&#34;&amp;gt;=&#34;)for(double i=x;i&amp;lt;=1005;i+=0.5)num[(int)(i*2+2)]++;
}
int maximumSubset(vector&amp;lt;string&amp;gt; inequalities) {
memset(num,0,sizeof(num));
FORE(i,0,inequalities.size()){
calc(inequalities[i]);
}
int ret=0;
FORE(i,0,2100){
ret=max(ret,num[i]);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 461 DIV1 Easy - ColoringRectangle ○</title>
      <link>https://chaingng.github.io/post/srm-461-div1-easy---coloringrectangle-/</link>
      <pubDate>Sun, 03 May 2015 22:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-461-div1-easy---coloringrectangle-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10731&amp;amp;rd=14181
長方形を、与えられた赤と青の円で覆いたい。
各円について、その直径が与えられる。
また、円の中心は長方形を横１線に分割する線上にあるようにする。
また円が重複するとき、前の円とは違う色にしなければならない。
このとき、すべて覆うのに必要な最小の円の数を求める。
ただし、そのような場合がないときは−１を返す。
解き方 
赤と青それぞれの円に対し降順にソートし、
赤から覆い始める場合、青から覆い始める場合それぞれについて
いくつの円で覆えるか確かめてあげればよい。
コード 
class ColoringRectangle {
public:
int calc(vector&amp;lt;int&amp;gt; a,vector&amp;lt;int&amp;gt; b,int w,double h){
double sum=0;
int at=0,ret=0;
while(1){
if(at&amp;gt;=a.size()||a[at]/2.0&amp;lt;h)break;
sum+=sqrt(a[at]*a[at]/4.0-h*h)*2;
ret++;
if(sum&amp;gt;=w)return ret;
if(at&amp;gt;=b.size()||b[at]/2.0&amp;lt;h)break;
sum+=sqrt(b[at]*b[at]/4.0-h*h)*2;
ret++;
if(sum&amp;gt;=w)return ret;
at++;
}
return 1e+9;
}
int chooseDisks(int width, int height, vector&amp;lt;int&amp;gt; red, vector&amp;lt;int&amp;gt; blue) {
sort(red.rbegin(),red.rend());
sort(blue.rbegin(),blue.rend());
int ret=1e+9;
ret=min(ret,calc(red,blue,width,height/2.0));
ret=min(ret,calc(blue,red,width,height/2.0));
return ret==1e+9 ? -1 : ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 462 DIV1 Easy - AgeEncoding</title>
      <link>https://chaingng.github.io/post/srm-462-div1-easy---ageencoding/</link>
      <pubDate>Sun, 03 May 2015 22:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-462-div1-easy---ageencoding/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10589&amp;amp;rd=14147
１と０からなる数が与えられ、これをｘ進数にすることでｎを表したい。
ｘは整数でなくても良いとき、ｘを求める。
ただしそのようなｘが存在しない場合は−１を、
複数存在する場合は−２を返す。
解き方 
２分探索の問題。
あとは例外判定が重要になる。
①N＝１のときは１のとき複数の場合があるので−２、
また一番下の桁が１で、その他の桁がすべて０でない場合は−１になる。
②ｎは１以上のため、すべて０のときは−１となる。
③N=1でなくすべて１のときは表すことができないので−１となる。
コード 
class AgeEncoding {
public:
double calc(double b,string s){
int n=s.size();
double sum=0.0;
double p=1;
for(int i=n-1;i&amp;gt;=0;i--){
if(s[i]==&#39;1&#39;)sum+=p;
p*=b;
if(sum&amp;gt;100)return sum;
}
return sum;
}
double getRadix(int age, string candles) {
int n=candles.size();
int valid=1;
FORE(i,0,n-1)if(candles[i]!=&#39;0&#39;)valid=0;
if(age==1){
if(!valid &amp;amp;&amp;amp; candles[n-1]==&#39;1&#39;)return -1;
if(valid &amp;amp;&amp;amp; candles[n-1]==&#39;1&#39;)return -2;
}
if(valid &amp;amp;&amp;amp; candles[n-1]==&#39;1&#39;)return -1;
if(valid &amp;amp;&amp;amp; candles[n-1]==&#39;0&#39;)return -1;</description>
    </item>
    
    <item>
      <title>SRM 469 DIV1 Easy - TheMoviesLevelOneDivOne</title>
      <link>https://chaingng.github.io/post/srm-469-div1-easy---themovieslevelonedivone/</link>
      <pubDate>Sun, 03 May 2015 21:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-469-div1-easy---themovieslevelonedivone/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10898&amp;amp;rd=14152
２人が座席に横並びで座りたい。
座席はn個の行だけ与えられる。
座席は各行、m個の席が横並びになっている。
また、すでに予約されている席もわかっている。
このとき、座り方の総数を求める。
解き方 
n,mともに10^9なので単純な全探索では求められない。
ここで予約されている席は47個なので、
出現した行の列を除いてあげれば、残りの行ｘ(m-1)で
出現していない行の席の総数を求められるので
nをすべて計算しなくてよい。
また出現した行について、その間だけ調べることで
mもすべて計算しなくてよい。
コード 
class TheMoviesLevelOneDivOne {
public: long long find(int n, int m, vector&amp;lt;int&amp;gt; row, vector&amp;lt;int&amp;gt; seat) {
long long ret=0,num=0;
int l=row.size();
int used[l];
memset(used,0,sizeof(used));
FORE(i,0,l)if(!used[i]){
num++;
vector&amp;lt;int&amp;gt; vx;
vx.push_back(0),vx.push_back(m+1);
FORE(j,0,l)if(row[i]==row[j]){
vx.push_back(seat[j]);
used[j]=1;
}
sort(all(vx));
FORE(j,0,vx.size()-1)ret+=max(0,vx[j+1]-vx[j]-2);
}
ret+=(long long)(n-num)*(long long)(m-1);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 465 DIV1 Easy - TurretPlacement</title>
      <link>https://chaingng.github.io/post/srm-465-div1-easy---turretplacement/</link>
      <pubDate>Sun, 03 May 2015 21:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-465-div1-easy---turretplacement/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10840&amp;amp;rd=14182
２次元座標上の複数の点が与えられる。
ここから２つの点を選び、それぞれ各点が中心となるように正方形をそれぞれ
１つずつ設置したい。
正方形の１辺は整数になるようにしたい。
また、正方形は互いに重ならないようにしたい。
このとき、正方形の設置の仕方の総数を求める。
解き方 
ある２点の選び方すべてについて、置けるすべての正方形の長さを
試してあげればよい。
選んだ２点の距離＊２が、２つの正方形の１辺の和以下であればよい。
ある点の距離＊２我与えられたときの置き方の総数は、
例えば長さがn=５であったとき１＋２＋３＋４となるので（n-1)*n/2となる。
コード 
class TurretPlacement {
public: long long count(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
long long ret=0;
int n=x.size();
FORE(i,0,n)FORE(j,i+1,n){
double d=sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));
long long num=d*2;
ret+=(num-1)*num/2.0;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 463 DIV1 Easy - RabbitNumbering ○</title>
      <link>https://chaingng.github.io/post/srm-463-div1-easy---rabbitnumbering-/</link>
      <pubDate>Sun, 03 May 2015 21:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-463-div1-easy---rabbitnumbering-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10697&amp;amp;rd=14148
複数のうさぎが存在し、すべてのうさぎに番号をつけたい。
それぞれのうさぎは違う番号をつける。
各うさぎはつけて欲しい番号の最大数を持っており、１～その最大数までの
いずれかの数字をつける。
このとき、うさぎの番号の付け方の総数を求める。
解き方 
普通に考えると計算量がオーバーしてしまう。
各うさぎのmaxnumberでソートし、小さい数から順番に見ていくことで
総数を簡単に数えることができる。
コード 
class RabbitNumbering {
public: int theCount(vector&amp;lt;int&amp;gt; maxNumber) {
int MOD=1000000007;
int n=maxNumber.size();
int ret=1;
sort(all(maxNumber));
FORE(i,0,n){
ret=(ret*1LL*(maxNumber[i]-i))%MOD;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 434 DIV1 Easy - FindingSquareInTable</title>
      <link>https://chaingng.github.io/post/srm-434-div1-easy---findingsquareintable/</link>
      <pubDate>Sat, 02 May 2015 22:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-434-div1-easy---findingsquareintable/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10268&amp;amp;rd=13696
1桁の数字がかかれた２次元のセルが与えられる。
各列、行番号についてそれぞれ等差数列になるように任意の数字を連結させることができる。
連結した数字のうち、それがある数の２乗になるようなもののうち
最大のものを求める。
解き方 
すべての位置について、列番号、行番号それぞれについてとりうる
等差数列すべてを調べてあげればよい。
2乗の確認はdoubleでは確かめられなく、整数型にすることに注意。
コード 
class FindingSquareInTable {
public:
long long tolong(string str){
stringstream out(str);
long long num;
out&amp;gt;&amp;gt;num;
return num;
}
int findMaximalSquare(vector&amp;lt;string&amp;gt; table) {
int h=table.size(),w=table[0].size();
long long ret=-1;
FORE(i,0,h)FORE(j,0,w){
for(int dr=-h;dr&amp;lt;=h;dr++)for(int dc=-w;dc&amp;lt;=w;dc++){
if(dr==0&amp;amp;&amp;amp;dc==0)continue;
string str=&#34;&#34;;
int r=i,c=j;
while(0&amp;lt;=r &amp;amp;&amp;amp; r&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=c &amp;amp;&amp;amp; c&amp;lt;w){
str+=table[r][c];
r+=dr,c+=dc;
long long num=tolong(str);
if((long long)sqrt(num)*(long long)sqrt(num)==num)ret=max(ret,num);
}
}
}
return ret;
}</description>
    </item>
    
    <item>
      <title>SRM 438 DIV1 Easy - UnluckyIntervals</title>
      <link>https://chaingng.github.io/post/srm-438-div1-easy---unluckyintervals/</link>
      <pubDate>Sat, 02 May 2015 22:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-438-div1-easy---unluckyintervals/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10356&amp;amp;rd=13803
luckyである整数の集合が与えられる。
また、unluckyな区間の取り方が定義される。
unluckyな区間とは、[A B]となるA&amp;lt;Bである取り方で
区間中一つもluckyな数字がない場合となる。
各整数について、unluckyな区間の取り方ができるだけ少ない方がよい。
整数ｎ個を、できるだけunluckyでない順に求める。
解き方 
整数は10^9であるためすべての数字を調べられない。
ただしnは100であるため、luckyな数字の前後ｎ個ずつとってあげればよい。
unluckyな値はその前後のluckyな整数によって定義されるので
ピックアップした各整数について計算してあげればよい。
整数のピックアップについて重複しないことに注意。
コード 
vector&amp;lt;pair&amp;lt;long long,long long&amp;gt; &amp;gt; p;
class UnluckyIntervals {
public: vector&amp;lt;int&amp;gt; getLuckiest(vector&amp;lt;int&amp;gt; luckySet, int n) {
int m=luckySet.size();
p.clear();
FORE(i,0,m)p.push_back(make_pair(0LL,luckySet[i]));
luckySet.push_back(0);
sort(all(luckySet));
int cur=0;
FORE(i,0,m){
for(long long j=luckySet[i]+1;j&amp;lt;luckySet[i+1]&amp;amp;&amp;amp;j&amp;lt;luckySet[i]+n;j++){
long long cost=max(0LL,(long long)(luckySet[i+1]-j)*(j-luckySet[i])-1);
p.push_back(make_pair(cost,j));
cur=j;
}
for(long long j=max(cur+1,luckySet[i+1]-n);j&amp;lt;luckySet[i+1];j++){
int valid=1;
FORE(k,0,m+1)if(j==luckySet[k])valid=0;
if(!valid)continue;
long long cost=max(0LL,(long long)(luckySet[i+1]-j)*(j-luckySet[i])-1);
p.push_back(make_pair(cost,j));
cur=j;
}
}
for(long long i=luckySet[m]+1;i&amp;lt;luckySet[m]+n+1;i++){</description>
    </item>
    
    <item>
      <title>SRM 416 DIV1 Easy - ShipLoading</title>
      <link>https://chaingng.github.io/post/srm-416-div1-easy---shiploading/</link>
      <pubDate>Thu, 30 Apr 2015 08:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-416-div1-easy---shiploading/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9933&amp;amp;rd=13506
複数のクレーンがあり、それぞれが運ぶことのできる最大の重さがわかっている。
また複数の積荷があり、これをすべて運びたい。
クレーンは同時に複数種類を動かすことができる。
このとき、すべての積荷を運ぶのに必要な最小時間を求める。
解き方 
要素数は５０なので全探索可能。
vectorでeraseを使えばシンプルに実装できる。
コード 
class ShipLoading {
public: int minimumTime(vector&amp;lt;int&amp;gt; cranes, vector&amp;lt;string&amp;gt; boxes) {
int n=cranes.size();
vector&amp;lt;int&amp;gt; box;
string str=&#34;&#34;;
FORE(i,0,boxes.size())str+=boxes[i];
stringstream out;
out&amp;lt;&amp;lt;str;
for(int num;out&amp;gt;&amp;gt;num;)box.push_back(num);
sort(cranes.rbegin(),cranes.rend());
sort(box.rbegin(),box.rend());
if(box.empty() || cranes[0]&amp;lt;box[0])return -1;
int ret=0;
while(!box.empty()){
ret++;
FORE(i,0,n)FORE(j,0,box.size()){
if(cranes[i]&amp;gt;=box[j]){
vector&amp;lt;int&amp;gt;:: iterator it=box.begin();
box.erase(it+j);
break;
}
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 412 DIV1 Easy - ForbiddenStrings ○</title>
      <link>https://chaingng.github.io/post/srm-412-div1-easy---forbiddenstrings-/</link>
      <pubDate>Wed, 29 Apr 2015 22:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-412-div1-easy---forbiddenstrings-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8480&amp;amp;rd=13503
A,B,Cからなる文字列がある。
ただし、AとBとCが連続して３つ並ばないようにしたい。
文字列の長さnが与えられたとき、そのような文字列の総数を求める。
解き方 
dpで解けそうな問題。
前の状態として直前２つの文字が何であったか覚えていればよいので、
dp[現在位置][２つ前までのAの有無][２つ前までのBの有無][２つ前までのCの有無]
としてあげればよい。
コード 
class ForbiddenStrings {
public: long long countNotForbidden(int n) {
long long dp[n+1][4][4][4];
memset(dp,0,sizeof(dp));
dp[0][0][0][0]=1;
FORE(i,0,n)FORE(j,0,4)FORE(k,0,4)FORE(l,0,4){
int nextj=(j&amp;amp;1)&amp;lt;&amp;lt;1;
int nextk=(k&amp;amp;1)&amp;lt;&amp;lt;1;
int nextl=(l&amp;amp;1)&amp;lt;&amp;lt;1;
if(!(k &amp;amp;&amp;amp; l))dp[i+1][nextj|1][nextk][nextl]+=dp[i][j][k][l];
if(!(j &amp;amp;&amp;amp; l))dp[i+1][nextj][nextk|1][nextl]+=dp[i][j][k][l];
if(!(j &amp;amp;&amp;amp; k))dp[i+1][nextj][nextk][nextl|1]+=dp[i][j][k][l];
}
long long ret=0;
FORE(i,0,4)FORE(j,0,4)FORE(k,0,4)ret+=dp[n][i][j][k];
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 409 DIV1 Easy - OrderedSuperString</title>
      <link>https://chaingng.github.io/post/srm-409-div1-easy---orderedsuperstring/</link>
      <pubDate>Wed, 29 Apr 2015 22:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-409-div1-easy---orderedsuperstring/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9823&amp;amp;rd=12181
複数の文字列が与えられる。
各文字列を順につなげていく。
ただし、これまでの文字列の後ろ部分と、次につなげる文字列の前部分で一致
しているところがあれば重ねてつなげることができる。
また、毎回つなげる位置は、前につなげた位置もしくはそれより後ろで
なければいけない。
このとき、最後にできた文字列のうち最小のものの長さを求める。
解き方 
貪欲法で解くことができる。

つなげる位置は毎回後ろになっていくため、
毎回最適なつなぎかたを求めていけばよい。
コード 
class OrderedSuperString {
public:
string rec(int pos,string s1,string s2){
int cur=0;
while(pos+cur&amp;lt;s1.size() &amp;amp;&amp;amp; cur&amp;lt;s2.size()){
if(s1[pos+cur]!=s2[cur])return &#34;&#34;;
cur++;
}
if(cur&amp;gt;=s2.size())return s1;
return s1+s2.substr(cur);
}
int getLength(vector&amp;lt;string&amp;gt; words) {
int n=words.size(),pos=0;
string str=&#34;&#34;;
FORE(i,0,n){
string tmp=&#34;&#34;;
while(pos&amp;lt;str.size()){
tmp=rec(pos,str,words[i]);
if(!tmp.empty()){
str=tmp;
break;
}
pos++;
}
if(tmp.empty())str+=words[i];
}
return str.size();
}
}; </description>
    </item>
    
    <item>
      <title>SRM 408 DIV1 Easy - OlympicCandles ○</title>
      <link>https://chaingng.github.io/post/srm-408-div1-easy---olympiccandles-/</link>
      <pubDate>Wed, 29 Apr 2015 22:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-408-div1-easy---olympiccandles-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8467&amp;amp;rd=12180
キャンドルが複数与えられ、それぞれの高さがわかっている。
１日目は１つ、2日めは２つ、、、とキャンドルをつけていき、
最大何日目までキャンドルをつけられるか求める。
ただし、つけられたキャンドルは１日につき高さが１減り、０となると消滅してしまう。
解き方 
要素数が５０であることから最大値は５０になる。
よって、毎回ソートしてもO(50*50*50log50)=O(1.25*10^5log50)となり
貪欲法で全探索しても間に合う。
コード 
class OlympicCandles {
public: int numberOfNights(vector&amp;lt;int&amp;gt; candles) {
int n=candles.size();
int turn=0;
while(turn&amp;lt;n){
sort(candles.rbegin(),candles.rend());
for(int i=0;i&amp;lt;turn+1;i++){
if(candles[i]&amp;lt;=0)return turn;
}
for(int i=0;i&amp;lt;turn+1;i++)candles[i]--;
turn++;
}
return turn;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 406 DIV1 Easy - SymmetricPie ○</title>
      <link>https://chaingng.github.io/post/srm-406-div1-easy---symmetricpie-/</link>
      <pubDate>Wed, 29 Apr 2015 22:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-406-div1-easy---symmetricpie-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8784&amp;amp;rd=12178
パイチャートを作り、各要素が全体の何％を占めるかわかっている。
このパイチャートを作るにあたって、できるだけ区切りの線が真ん中を
横断するようにしたい。
要素我与えられたとき、すべての作り方の中で
最大となる区切りの線の数を求める。
解き方 
区切りの線はある線からちょうど５０％分のパイを並べたときに
作ることができる。
また、要素数は８のためすべての並べ方について調べることができる。
よって、各並べ方の部分列の和が５０となるものの和が区切りの和となるので
そのようなうち最大のものを答えとする。
ただし、最初から５０％をとったとき、残りも５０％となり重複してしまうので
このケースだけ１つしか数え内容にする。
コード 
class SymmetricPie {
public: int getLines(vector&amp;lt;int&amp;gt; dogs) {
int n=dogs.size();
int ret=0;
sort(all(dogs));
do{
int score=0;
FORE(i,0,n){
int tmp=0;
FORE(j,i,n)if(tmp&amp;lt;50)tmp+=dogs[j];
if(tmp==50 &amp;amp;&amp;amp; i!=0)score++;
}
ret=max(ret,score);
}while(next_permutation(all(dogs)));
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 404 DIV1 Easy - RevealTriangle ○</title>
      <link>https://chaingng.github.io/post/srm-404-div1-easy---revealtriangle-/</link>
      <pubDate>Wed, 29 Apr 2015 22:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-404-div1-easy---revealtriangle-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8215&amp;amp;rd=12176
逆三角形からなる数字の配列が与えられる。
高さが４のとき、1行目は数字が４つ、2行めは３つ、、、４行めは数字が１つになる。
また、各行について１つは数字がわかっているがその他の数字は？となりわかっていない。
ある位置の数字は、その上にある数字と右上にある数字の和の一桁目の数になる。
このとき、？の数字をすべて復元して求める。
解き方
一番下の行は１つ、つまりすべての数字が分かっているため、
すべての数字を復元することができる。
また、復元については下から上へ順に行っていけばよい。
ある行について調べるとき、その下の行はすべてわかっていることから
？２
３
のように上側の数字が？になる。
このとき、（３＋１０ー２）％１０が？の数になるので
このようにすべての？を求めてあげればよい。
コード 
class RevealTriangle {
public: vector&amp;lt;string&amp;gt; calcTriangle(vector&amp;lt;string&amp;gt; q) {
int n=q.size();
for(int i=n-2;i&amp;gt;=0;i--){
while(1){
if(q[i].find(&#39;?&#39;)==string::npos)break;
for(int j=0;j&amp;lt;n-i;j++){
int cnt= (q[i][j]==&#39;?&#39;) + (q[i][j+1]==&#39;?&#39;);
if(cnt==1){
int y=0;
if(q[i][j]!=&#39;?&#39;)y=q[i][j]-&#39;0&#39;;
else y=q[i][j+1]-&#39;0&#39;;
int x=(q[i+1][j]-&#39;0&#39;+10-y)%10;
if(q[i][j]==&#39;?&#39;)q[i][j]=x+&#39;0&#39;;
else q[i][j+1]=x+&#39;0&#39;;
}
}
}
}
return q;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 403 DIV1 Easy - TheLuckyNumbers ○</title>
      <link>https://chaingng.github.io/post/srm-403-div1-easy---theluckynumbers-/</link>
      <pubDate>Wed, 29 Apr 2015 22:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-403-div1-easy---theluckynumbers-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8568&amp;amp;rd=12175
整数aとbが与えられる。
a以上かつb以下の整数のうち、4と7からなる整数の総数を求める。
解き方 
a,bは10^9でありすべて全探索しては間に合わないが、
４と７からなる数字は2^9のため、
DFSにて４と７からなるすべての数字について調べればよい。
コード 
int ret,a,b;
class TheLuckyNumbers {
public:
void dfs(long long x){
if(x&amp;lt;=b){
dfs(x*10+4);
dfs(x*10+7);
if(a&amp;lt;=x)ret++;
}
}
int count(int a_, int b_) {
a=a_,b=b_;
ret=0;
dfs(0);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 401 DIV1 Easy - FIELDDiagrams</title>
      <link>https://chaingng.github.io/post/srm-401-div1-easy---fielddiagrams/</link>
      <pubDate>Tue, 28 Apr 2015 21:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-401-div1-easy---fielddiagrams/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8776&amp;amp;rd=12173
整数fieldDiagramが与えられて、fieldDiagram行からなるBOXを作る。
各行0,1,2,...において、長さはそれぞれfieldDiagram,fieldDiagram-1,fieldDiagram-2以下で
なければならない。
また、各行において上の行以下の長さでなければならない。
このような条件を満たすようなBOXの作り方の総数を求める。
解き方 
上の行における長さがわかっていれば、上から順にたどっていくことで総数が
計算できるのでｄｐで解ける。
すべて０の場合は空になるので、最後にそのケース１通りを引いてあげれば良い。
コード 
class FIELDDiagrams {
public: long long countDiagrams(int f) {
long long dp[f+1][f+1];
memset(dp,0,sizeof(dp));
dp[0][f]=1LL;
FORE(i,0,f)FORE(j,0,f+1){
for(int k=min(j,f-i);k&amp;gt;=0;k--)dp[i+1][k]+=dp[i][j];
}
long long ret=0;
FORE(i,0,f+1)ret+=dp[f][i];
return ret-1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 400 DIV1 Easy - StrongPrimePower</title>
      <link>https://chaingng.github.io/post/srm-400-div1-easy---strongprimepower/</link>
      <pubDate>Tue, 28 Apr 2015 20:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-400-div1-easy---strongprimepower/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8763&amp;amp;rd=12172
ある整数ｎが与えられる。
このｎが素数の階乗で表せるならその素数と階乗数を返す。
そのように表せられなければ空の文字列を返す。
解き方 
nの最大は10^18で全探索できないが、
2乗の場合を除けば探索範囲はO(10^6)となり全探索可能。
2乗の場合の計算はdouble*double==longにならないよう、型を一致させることに注意。
コード 
class StrongPrimePower {
public: vector&amp;lt;int&amp;gt; baseAndExponent(string n) {
vector&amp;lt;int&amp;gt; ans;
long long x;
stringstream out(n);
out&amp;gt;&amp;gt;x;
for(int i=2;i&amp;lt;=1000000 &amp;amp;&amp;amp; i&amp;lt;x;i++)if(x%i==0){
long long tmp=x;
int cnt=0;
while(tmp%i==0){
tmp/=i;
cnt++;
}
if(tmp==1){
ans.push_back(i);
ans.push_back(cnt);
return ans;
}
return ans;
}
long long y=sqrt((double)x);
if(y*y==x){
ans.push_back(y);
ans.push_back(2);
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 657 DIV1 Easy - ProblemSets x</title>
      <link>https://chaingng.github.io/post/srm-657-div1-easy---problemsets-x/</link>
      <pubDate>Tue, 28 Apr 2015 20:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-657-div1-easy---problemsets-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13771&amp;amp;rd=16417
・問題Easy,EM,Middle,MH,Hardの数が与えられる。
・ここから問題のセットをできるだけ多く作りたい。
・各問題セットは、Easy,Middle,Hardの問題を各一つ含む必要がある。
・問題EMはEasyもしくはMiddleの代わり、MHはMiddleもしくはHardの代わりに使える。
・このとき、作ることのできる最大の問題セット数を求める。
解き方 
まずは法則がないか考えてしまうが、かなり複雑になりそう。
ここで作ることの問題セットがわかっていれば、それを作ることができるかどうかは
すぐに判定することができる。
よって二分探索を用いればよい。
コード 
class ProblemSets {
public:
bool ispossible(long long x,long long E, long long EM, long long M, long long MH, long long H){
if(EM&amp;lt;x-E)return false;
if(MH&amp;lt;x-H)return false;
if(E&amp;lt;x)EM-=(x-E);
if(H&amp;lt;x)MH-=(x-H);
return M+EM+MH&amp;gt;=x;
}
long long maxSets(long long E, long long EM, long long M, long long MH, long long H) {
long long low=0,high=LONG_MAX;
while(high-low&amp;gt;1){
long long mid=(low+high)/2;</description>
    </item>
    
    <item>
      <title>TCO 2015 1A Middle - Autogame</title>
      <link>https://chaingng.github.io/post/tco-2015-1a-middle---autogame/</link>
      <pubDate>Mon, 27 Apr 2015 22:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/tco-2015-1a-middle---autogame/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13716&amp;amp;rd=16433
ノード数Nの有向グラフが与えられる。
エッジの数は最大Nであり、各ノードから出るエッジはひとつだけになる。
このグラフで最初に任意のノードを選んでトークンを置き、Kステップ遷移させる。
Kステップ経過後、どのトークンも重ならないような置き方の総数を求める。
解き方 
法則を考えようとして複雑なコードになってしまった。
ステップ数Kは10^9であるがノード数が５０なので、シミュレーションさせて
最後の位置の重なり具合で場合の数を求めればシンプルに求められる。
コード 
class Autogame {
public: int wayscnt(vector&amp;lt;int&amp;gt; a, int K) {
int n=a.size();
int p[n];
int MOD=1000000007;
FORE(i,0,n)p[i]=i;
for(int i=0;i&amp;lt;K &amp;amp;&amp;amp; i&amp;lt;100;i++){
for(int j=0;j&amp;lt;n;j++)p[j]=a[p[j]]-1;
}
int ret=1;
FORE(i,0,n){
int cnt=0;
FORE(j,0,n)if(p[j]==i)cnt++;
if(cnt&amp;gt;0)ret=(ret*1LL*(cnt+1))%MOD;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>TCO 2015 1B Middle - TheTips</title>
      <link>https://chaingng.github.io/post/tco-2015-1b-middle---thetips/</link>
      <pubDate>Mon, 27 Apr 2015 08:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/tco-2015-1b-middle---thetips/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13716&amp;amp;rd=16433
N人のクルーが隠れており、そのクルーを見つけたい。
各クルーについては見つけられる確率が与えられている。
また、各クルーについて、そのクルーが見つかったときに見つけられるクルーも与えられる。
このとき、見つけられるクルーの数の期待値を求める。
解き方 
期待値なのでｄｐを考えたいが、順序関係を明らかにする必要がある。
まず期待値の考え方として独立な事象とそうでない事象を考える。
独立な事象としては、全体で見つかる人数に対して、各クルーが見つかるかどうかは
独立で考えて和をとればよい。
そして各クルーについて見つかるかどうかは、その他のクルーが見つかったときにそのクルーも必ず見つかる場合について、そのクルーが全て見つからない事象の積の排他を
とればよい。
コード 
class TheTips {
public: double solve(vector&amp;lt;string&amp;gt; clues, vector&amp;lt;int&amp;gt; probability) {
int n=probability.size();
int d[n][n];
FORE(i,0,n)FORE(j,0,n)d[i][j]=(clues[i][j]==&#39;Y&#39;);
FORE(i,0,n)d[i][i]=1;
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)d[i][j]|=d[i][k]&amp;amp;d[k][j];
double ret=0.0;
FORE(i,0,n){
double p=1.0;
FORE(j,0,n)if(d[j][i])p*=(1.0-probability[j]*0.01);
ret+=(1.0-p);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 601 DIV1 Easy - WinterAndPresents</title>
      <link>https://chaingng.github.io/post/srm-601-div1-easy---winterandpresents/</link>
      <pubDate>Sat, 25 Apr 2015 07:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-601-div1-easy---winterandpresents/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12860&amp;amp;rd=15713
りんごとオレンジが入ったバッグが複数与えられる。
各バッグについて、りんごとオレンジそれぞれ何個入っているかわかっている。
ここで、各バッグからX個ずつフルーツを取り出す。
このとき、取り出し方の総数を求める。
解き方 
各バッグから取り出す数は、各バッグのフルーツの総数の最小数Xとなる。
なので、各バッグから１個ずつ〜X個ずつの各ケースについて場合の数を求める。
各バッグからX個ずつ取り出すときの総数について
すべての場合の数を計算していては間に合わない。
ここで、りんごの取り出し方の最大数とオレンジの取り出し方の最大数さえわかれば
場合の数は計算できる。
２種類のフルーツで合計の数がわかっている場合、１種類だけに着目すれば
もう１種類は計算しなくてもよいのがコツ。
コード 
class WinterAndPresents {
public: long long getNumber(vector&amp;lt;int&amp;gt; apple, vector&amp;lt;int&amp;gt; orange) {
int n=apple.size();
int minx=1e+9;
FORE(i,0,n)minx=min(minx,apple[i]+orange[i]);
long long ret=0;
for(int x=1;x&amp;lt;=minx;x++){
int numa=0,numo=0;
FORE(i,0,n){
numa+=min(x,apple[i]);
numo+=min(x,orange[i]);
}
if(numa&amp;lt;numo)swap(numa,numo);
ret+=numa-(x*n-numo)+1;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 603 DIV1 Easy - MaxMinTreeGame</title>
      <link>https://chaingng.github.io/post/srm-603-div1-easy---maxmintreegame/</link>
      <pubDate>Sat, 25 Apr 2015 06:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-603-div1-easy---maxmintreegame/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12946&amp;amp;rd=15836
有向グラフが与えられる。
各ノードについてはコストを持つ。
２人のプレイヤーがゲームを行い、各ターンごとにグラフを２つに分割し、
好きな方の１つを消すことができる。
最初のプレイヤーはできるだけ最後に残るノードのコストを大きくしたく、
２人目のプレイヤーはできるだけ小さくしたい。
このとき、最後に残るノードの最大コストを求める。
解き方 
２人ゲームなので必勝法を考察する。
今回は間にあるノードを残したくても、相手のターンで必ず消されてしまう。
逆に端にあるノードは必ず残すことができる。
よって、端にあるノードのうち最大のものが答えになる。
コード 
class MaxMinTreeGame {
public: int findend(vector&amp;lt;int&amp;gt; edges, vector&amp;lt;int&amp;gt; costs) {
int n=costs.size();
int d[n][n];
memset(d,0,sizeof(d));
FORE(i,0,edges.size()){
d[edges[i]][i+1]=1;
d[i+1][edges[i]]=1;
}
int ret=0;
FORE(i,0,n){
int cnt=0;
FORE(j,0,n)if(d[i][j])cnt++;
if(cnt&amp;lt;=1)ret=max(ret,costs[i]);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>2014 TCO Semifinal2 DIV1 Easy - PlankTiling</title>
      <link>https://chaingng.github.io/post/2014-tco-semifinal2-div1-easy---planktiling/</link>
      <pubDate>Wed, 22 Apr 2015 22:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-semifinal2-div1-easy---planktiling/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13437&amp;amp;rd=16188
・１＊Hの棒が与えられる。
・この棒を、（２H-1）＊Wのセルに敷き詰める場合の数を求める。
・WはHの倍数となる。
解き方 
WがHの倍数のときにすべて敷き詰めることができる。
敷き詰め方としては、W＝３、H＝３のとき
---
---
---
---
---
が必ず１通り存在し、さらに
||
||
||
と縦に並べる並べ方がH通りあるので合計H＋１通り。
さらにWが３増えると（H+1）＊H通り＋（H+1）通りになる。
加えて、WがH+1以上のときは
上記のようにWをH個のブロック区切りで考える他に、
区切りの間に敷き詰める方法がある。
上記の３つについてｄｐを適用させていけば良い。
コード 
class PlankTiling {
public: int sumup(int H, int W) {
int dp[W+1];
int MOD=1000000007;
memset(dp,0,sizeof(dp));
dp[0]=1;
for(int i=0;i&amp;lt;W;i++){
if(i+H&amp;lt;=W)dp[i+H]=(dp[i+H]+dp[i])%MOD;
if(i%H==0)dp[i+1]=(dp[i+1]+dp[i]*1LL*H)%MOD;
else dp[i+1]=(dp[i+1]+dp[i])%MOD;
}
return dp[W];
}
}; </description>
    </item>
    
    <item>
      <title>2014 TCO Semifinal1 DIV1 Easy - ZooExchangeProgram</title>
      <link>https://chaingng.github.io/post/2014-tco-semifinal1-div1-easy---zooexchangeprogram/</link>
      <pubDate>Wed, 22 Apr 2015 15:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-semifinal1-div1-easy---zooexchangeprogram/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13268&amp;amp;rd=16187
・複数の動物がおりラベルが付けられている。
・そのうち番号がlowerからupperまでのラベルの動物を各種類最低１匹ずつ選びたい。
その他の動物については１匹も選ばないようにしたい。
・動物の選び方としては隣り合う動物については一つの集合とすることができる。
・このとき、そのような動物の選び方のうち一番少なくなる集合数を求める。
そのような選び方がない場合は−１を返す。
解き方 
たとえばサンプルから選ぶラベルが２〜６のとき、
{[3, 4, 3], 1, [6, 2, 5, 7, 5, 2]}が選ぶ集合となる。
同じラベルの動物は１種類以上であれば問題ないので、
選ぶだけ選んだ方が集合が少なくなるので存在するものはすべて貪欲に選ぶ。
このとき、要素数は最大４４なので集合数は最大２２個となる。
このとき集合の選び方は2^22となり全探索が可能なので、
すべての選び方に対し、すべてのラベルの動物が含まれているか判定すればよい。
コード 
long long dp[2000000];
class ZooExchangeProgram {
public: int getNumber(vector&amp;lt;int&amp;gt; label, int lower, int upper) {
int n=label.size();
int count=0;
for(int pos=0;pos&amp;lt;n;pos++){
while(pos&amp;lt;n &amp;amp;&amp;amp; !(lower&amp;lt;=label[pos] &amp;amp;&amp;amp; label[pos]&amp;lt;=upper))pos++;
if(pos&amp;gt;=n)break;
long long mask=0;
while(pos&amp;lt;n){
if(lower&amp;lt;=label[pos] &amp;amp;&amp;amp; label[pos]&amp;lt;=upper){
mask|=(1LL&amp;lt;&amp;lt;label[pos]);
pos++;
}
else break;
}
dp[count++]=mask;</description>
    </item>
    
    <item>
      <title>2014 TCO Celebrity Match DIV1 Easy - AnEasyProblem</title>
      <link>https://chaingng.github.io/post/2014-tco-celebrity-match-div1-easy---aneasyproblem/</link>
      <pubDate>Wed, 22 Apr 2015 15:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-celebrity-match-div1-easy---aneasyproblem/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13527&amp;amp;rd=16191
・関数F（h,r）が与えられる。その要素は{1,2,3,...h-1,h,h-1...r+1,r}となる。
（例）F(3,2)={1,2,3,2}
・関数Fの和があらかじめわかっているとき、その和を構成できる関数Fのうち
最も少ない要素数を求める。
そのようなFがない場合は−１を返す。
解き方 
和の最大が10^12であるため、n*(n+1)/2&amp;lt;=10^12から
nは最大でも10^6程度なので全探索できそう。
まず１から単調増加で和を計算していき、そのような和が構成できれば
それは最小要素なので答えになる。
そのような最小要素がなければ、途中で折り返す要素を計算する。
この場合最悪ケースで10^12になってしまうので、工夫が必要。
このとき、折り返し分の要素は最大のnからn-1,n-2・・・の和のいずれかであるので
あらかじめ累積和を計算しておき、二分探索することで
計算量を20*10^6に収めることができる。
コード 
long long dp[1500000];
class AnEasyProblem {
public: int solve(long long sum) {
long long cur=0;
int n=0;
while(cur+n+1&amp;lt;=sum){
n++;
cur+=n;
}
if(cur==sum)return n;
dp[0]=0;
for(int i=1;i&amp;lt;=n;i++)dp[i]=dp[i-1]+i;
for(int x=n;x&amp;gt;=1;x--){
if(dp[x-1]*2+x&amp;lt;sum)break;
long long tmp=dp[x-1]-(sum-dp[x]);
int m = (lower_bound(dp,dp+n,tmp)) - dp ;
if(dp[m]==tmp)return (x-1)-m+x;
}
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 646 DIV2 Middle - TheGridDivTwo</title>
      <link>https://chaingng.github.io/post/srm-646-div2-middle---thegriddivtwo/</link>
      <pubDate>Tue, 21 Apr 2015 17:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-646-div2-middle---thegriddivtwo/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13628&amp;amp;rd=16278
・２次元の座標が与えられる。
・（０，０）がスタート地点になり、各ターン上下左右のいずれかに移動することができる。
・ただし複数の障害物が与えられ、障害物がある方向には移動することができない。
・Kターン移動するとき、最後に移動することができる最大のｘ座標の値を求める。
解き方 
問題文を見るとｋ＝１０００なので前探索できそう。
ただしマイナスの方向にも移動するので、座標変換が必要。
今回は最小で−１０００なので、ｘ，ｙ座標ともに１０００を足してあげて、最後の答えから１０００を引けば良い。
コード 
int dp[2010][2010];
class TheGridDivTwo {
public: int find(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int k) {
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
memset(dp,0,sizeof(dp));
FORE(i,0,x.size())dp[x[i]+1000][y[i]+1000]=-1;
dp[1000][1000]=1;
q.push(make_pair(1000,1000));
while(!q.empty()){
int x=q.front().first;
int y=q.front().second;
if(dp[x][y]==k+1)break;
q.pop();
FORE(i,0,4){
int cx=x+dx[i];
int cy=y+dy[i];
if(dp[cx][cy]==0){
dp[cx][cy]=dp[x][y]+1;
q.push(make_pair(cx,cy));
}
}
}
int ret=-3000;
FORE(i,0,2010)FORE(j,0,2010)if(dp[i][j]&amp;gt;0)ret=max(ret,i);
return ret-1000;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 641 DIV1 Easy - TrianglesContainOrigin x</title>
      <link>https://chaingng.github.io/post/srm-641-div1-easy---trianglescontainorigin-x/</link>
      <pubDate>Tue, 21 Apr 2015 16:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-641-div1-easy---trianglescontainorigin-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13309&amp;amp;rd=16084
・２次元の座標上の点が複数与えられる。
・このうち選んだ３点がなす三角形が原点を含む場合の数を求める。
解き方 
まず３点を選んだ時に、その三角形が原点を含むかの判定をする必要がある。
これはatan2を使い、２点i,jを選んだときiのatan2+πとjのatan2＋πの間に
もうひとつの点があれば原点を含む三角形となる。
次にこのような三角形の選び方は、N=2500のため
O(2500*2500*2500）では前探索できない。
ここで2点を選んだ時に残りの１点について２分探索を使うことで、
O(2500*2500*log2500）で計算量を間に合わせることができる。
コード 
class TrianglesContainOrigin {
public: long long count(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
int n=x.size();
long long ret=0LL;
vector&amp;lt;double&amp;gt; p(n);
FORE(i,0,n)p[i]=atan2((double)x[i],(double)y[i]);
sort(all(p));
FORE(i,0,n)FORE(j,i+1,n)if(p[j]-p[i]&amp;lt;PI){
int e=lower_bound(p.begin(),p.end(),p[j]+PI)-p.begin();
int s=lower_bound(p.begin(),p.end(),p[i]+PI)-p.begin();
ret+=e-s;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 642 DIV1 Easy - WaitingForBus x</title>
      <link>https://chaingng.github.io/post/srm-642-div1-easy---waitingforbus-x/</link>
      <pubDate>Tue, 21 Apr 2015 16:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-642-div1-easy---waitingforbus-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13540&amp;amp;rd=16085
・バスが複数あり、各バスごとに１周にかかる時間と、そのバスが選ばれる確率が与えられる。
・スタート時にひとつのバスが与えられた確率で選ばれ、そのバスが戻ってきたときに
また、そのバスを含むすべてのバスからひとつ選ばれ出発する。
・あなたが到着する時間が与えられるとき、待ち時間の期待値を求める。
解き方 
期待値を求めるのでｄｐが使えそう。
dp[現在の時刻]と定義する。
各dp[i]について、すべてのバスjに対してdp[i+time[j]]を更新する。
このとき、i+time[j]が自分が到着する時間よりも大きければその待ち時間を
答えの期待値に加えていけば良い。
コード 
double dp[100001];
class WaitingForBus {
public: double whenWillBusArrive(vector&amp;lt;int&amp;gt; time, vector&amp;lt;int&amp;gt; prob, int s) {
if(s==0)return 0.0;
int n=time.size();
double ret=0.0;
memset(dp,0,sizeof(dp));
dp[0]=1.0;
for(int i=0;i&amp;lt;s;i++){
FORE(j,0,n){
if(s&amp;lt;=i+time[j])ret+=(i+time[j]-s)*dp[i]*prob[j]/100.0;
else dp[i+time[j]]+=dp[i]*prob[j]/100.0;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 656 DIV1 Easy - RandomPancakeStack xx</title>
      <link>https://chaingng.github.io/post/srm-656-div1-easy---randompancakestack-xx/</link>
      <pubDate>Tue, 21 Apr 2015 15:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-656-div1-easy---randompancakestack-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13747&amp;amp;rd=16416
・N個のパンケーキが与えられ、i番目のパンケーキの幅はi+1になる。
また、各パンケーキのおいしさの値が与えられる。
・ここからパンケーキをひとつづつ選び、上に重ねていく。
ただし、現在積み重ねられている一番上のパンケーキより幅が大きいパンケーキを選んだらそこで終了となる。
・ランダムにパンケーキが重ねられるとき、パンケーキおおいしさの値の期待値を求める。
解き方 
期待値の問題なのでｄｐが使えそう。（SRM607）
現在積み重ねられているパンケーキについて、
dp[現在の幅の広さ][現在のパンケーキの数]と定義する。
このとき、各dp[i][j]についてdp[0〜i][j+1]を更新してあげればよい。
コード 
double dp[310][310];
class RandomPancakeStack {
public: double expectedDeliciousness(vector&amp;lt;int&amp;gt; d) {
memset(dp,0,sizeof(dp));
int n=d.size();
FORE(i,0,n+1)dp[n][0]=1.0;
//recurrence
for(int i=n-1;i&amp;gt;=0;i--){
for(int j=1;j&amp;lt;=n;j++){
for(int k=i+1;k&amp;lt;=n;k++)dp[i][j]+=dp[k][j-1]/(n-(j-1));
}
}
//transition
/*for(int i=n;i&amp;gt;=0;i--){
for(int j=0;j&amp;lt;n;j++){
for(int k=0;k&amp;lt;i;k++)dp[k][j+1]+=dp[i][j]/(n-j);
}
}*/
double ret=0.0;
FORE(i,0,n)FORE(j,0,n+1)ret+=d[i]*dp[i][j];
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 643 DIV1 Easy - TheKingsFactorization x○</title>
      <link>https://chaingng.github.io/post/srm-643-div1-easy---thekingsfactorization-x/</link>
      <pubDate>Sun, 19 Apr 2015 12:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-643-div1-easy---thekingsfactorization-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13594&amp;amp;rd=16086
整数Nを素因数分解したい。
ただし、Nはとても大きいため、Nを素因数分解したときの答えの
昇順に1番目、3番目、、と一つ置きの因数が与えられる。
このとき、すべての因数を求める。
解き方 
Nが最大で10^18のため計算量の考慮が必要。
まず、Nを与えられた素因数で割ってから残りの数を求めようとすると
{2,(2),2,(10^16)}のときO(10^8)となり計算量オーバー。
次に、与えられた素因数の間の数prime[i]とprime[i+1]の間を求めていくやり方も
{2,(2),10^16}のときO(10^16)となり計算量オーバー。
そこで、両方の判定を加えてあげることで
{2,(2),10^6,(10^11)}の場合でも、最大でO(10^6)に収められる。
コード 
class TheKingsFactorization {
public: vector&amp;lt;long long&amp;gt; getVector(long long N, vector&amp;lt;long long&amp;gt; primes) {
int n=primes.size();
FORE(i,0,n)N/=primes[i];
vector&amp;lt;long long&amp;gt; ans=primes;
FORE(i,0,n-1){
for(long long j=primes[i];j&amp;lt;=primes[i+1] &amp;amp;&amp;amp; j*j&amp;lt;=N;j++){
while(N%j==0){
ans.push_back(j);
N/=j;
}
}
}
if(N!=1)ans.push_back(N);
sort(all(ans));
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 645 DIV1 Easy - JanuszTheBusinessman</title>
      <link>https://chaingng.github.io/post/srm-645-div1-easy---januszthebusinessman/</link>
      <pubDate>Sun, 19 Apr 2015 11:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-645-div1-easy---januszthebusinessman/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13603&amp;amp;rd=16277
ホテルに複数の人が宿泊に訪れる。
各ゲストについて到着日と出発日がわかっている。
ここで、ホテルでプロモーションを行うことができ、プロモーションを行うとその日に宿泊している人はよいレビューを残してくれる。
また、プロモーションを受けた人とそうでない人の宿泊日が重なると、プロモーションを受けていない人もよいレビューを残してくれる。
このとき、すべての宿泊客がよいレビューを残してくれる最小のプロモーション開催日数を求める。
解き方 
条件を満たす集合の数を求めていけばよい。
プロモーションを「直接」受けている人と宿泊日が重ならなければ
よいレビューを残さないことに注意。
まず、プロモーションの開催日を求める。
このとき、一番早く出発する人からプロモーション日を求めていけば貪欲法で解ける。
プロモーション日が決まったら、そのプロモーションを直接受けられる宿泊客のうち
最も遅く出発する日を求める。
その最も遅い出発日と重なる宿泊客は同じ集合にすることができ、
このオペレーションの回数が最小のプロモーション開催日数となる。
コード 
class JanuszTheBusinessman {
public: int makeGuestsReturn(vector&amp;lt;int&amp;gt; arrivals, vector&amp;lt;int&amp;gt; departures) {
int n=arrivals.size();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int ok[n];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; memset(ok,0,sizeof(ok));
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int ret=0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while(true){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int promday=1e+9;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; FORE(i,0,n)if(!ok[i])promday=min(promday,departures[i]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(promday==1e+9)break;</description>
    </item>
    
    <item>
      <title>2015 TCO Round 1A Easy - Similars</title>
      <link>https://chaingng.github.io/post/2015-tco-round-1a-easy---similars/</link>
      <pubDate>Sun, 19 Apr 2015 10:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2015-tco-round-1a-easy---similars/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13714&amp;amp;rd=16432
ある数字ｘとｙが与えられた時、０〜９のうち同じ数字が存在する数だけSimilarityの値が高くなる。
（例）ｘ＝１１２４、ｙ＝１１２２　１と２が双方に出るのでSimilarityは２
数字の範囲LとRが与えられた時、L~Rのうちの２つの数字のペアのうち、
最も高いSimilarityを求める。
解き方 
数字が10^5のため、全探索すると10^10で間に合わない。
このような場合、探索する集合を変換できないか考える。
今回は１〜９の出現数が答えであるので、
「数字の集合」→「１〜９までの出現数の集合」に変換できる。
このとき、集合の総数は10^3（0から9の数字がそれぞれ出現するかどうか）となるので
全探索が可能になる。
コード 
class Similars {
public: int maxsim(int L, int R) {
int dp[1024];
memset(dp,0,sizeof(dp));
for(int i=L;i&amp;lt;=R;i++){
int x=i;
int mask=0;
while(x&amp;gt;0){
mask|=1&amp;lt;&amp;lt;(x%10);
x/=10;
}
dp[mask]++;
}
int ret=0;
FORE(i,0,1024)FORE(j,0,1024){
if(i==j &amp;amp;&amp;amp; dp[i]&amp;lt;=1)continue;
if(dp[i]==0 || dp[j]==0)continue;
ret=max(ret,__builtin_popcount(i&amp;amp;j));
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 649 DIV1 Easy - Decipherability</title>
      <link>https://chaingng.github.io/post/srm-649-div1-easy---decipherability/</link>
      <pubDate>Sun, 12 Apr 2015 21:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-649-div1-easy---decipherability/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13656&amp;amp;rd=16313
・a～ｚから成る文字列が与えられる。
・この文字列から、任意のK個の文字を取り除いたとき、それがどの箇所か
特定できればCertain、特定できなければUncertainを返す。
解き方 
どのような文字列が削除されると特定できないかの法則を探す。
まず、すべての文字列が削除された場合は特定できる。
次に、文字列の対称性を考えた場合に、a***aの文字列があった場合
Kが４以上だとaだけを残すことができ、どちらを消したか特定できない。
このような同じ文字ではさまれたサブ文字列すべてに対して判定を行い
ひとつでもあてはまれば特定できない文字列となる。
コード 
class Decipherability {
public: string check(string s, int K) {
int n=s.size();
if(K==n)return &#34;Certain&#34;;
FORE(i,0,n)FORE(j,i+1,n)if(s[i]==s[j]){
if(j-i&amp;lt;=K)return &#34;Uncertain&#34;;
}
return &#34;Certain&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 647 DIV1 Easy - BuildingTowersEasy x</title>
      <link>https://chaingng.github.io/post/srm-647-div1-easy---buildingtowerseasy-x/</link>
      <pubDate>Sun, 12 Apr 2015 20:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-647-div1-easy---buildingtowerseasy-x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13634&amp;amp;rd=16279
・N個の建物を建てたい。
・建物は１からNまですべて連続していなければならなく、隣合う建物の高さの差は
１以内でなければならない。
・また、最初の建物の高さは０になる。
・加えて、x[i]番目の建物の高さはt[i]以下でなければならない。
・このとき、建物の中で最も高い建物の高さを求める。
解き方 
2013 1cEasyと類似した、山の問題。
条件は以下の２つ。
・建物１は高さ０から始まって、そこからの差は１以内ずつとなる。
・各位置pについて、すべてのx[i]と比較して最大の高さはt[i]＋abs(p-x[i])以内にならなければいけない。
最後に２つの条件を満たすもっとも高い建物の高さが答えになる。
コード 
class BuildingTowersEasy {
public: int maxHeight(int N, vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; t) {
int d[N+1];
for(int i=1;i&amp;lt;=N;i++)d[i]=i-1;
for(int i=1;i&amp;lt;=N;i++){
FORE(j,0,x.size()){
d[i]=min(d[i],t[j]+abs(i-x[j]));
}
}
return *max_element(d+1,d+1+N);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 652 DIV1 Easy - ThePermutationGame </title>
      <link>https://chaingng.github.io/post/srm-652-div1-easy---thepermutationgame/</link>
      <pubDate>Sun, 12 Apr 2015 11:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-652-div1-easy---thepermutationgame/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13229&amp;amp;rd=16316
・１～Nの数それぞれからなる、数字の列が与えられる。
（例）N=2、｛１，２｝　N=3、｛１，２，３｝
・この数はランダムの回数シャッフルされる。
・また、関数ｆが与えられる。
・シャッフルされたあとの数列をpとすると、 f(1)=p[1]、f(m)=p[f(m-1)]となる。
このとき、どのようにシャッフルされてもf(x)=1となるような最小のｘを求める。
解き方 
SRM441と似ている。周期をまず求める。
シャッフルされた数列の最初の数を考えると、
この数は１～Nの場合が考えられ、それぞれ１～N回の周期でf(x)が１となる。
つまり、１～Nの全ての周期で割り切れる1～Nの最小公倍数が答えになる。
最小公倍数を求めるとき、途中でMODで剰余をとってしまうと最小公倍数が計算できないので
工夫が必要。
ある数列の最小公倍数を求めるとき、存在する素数それぞれについて、
N以下でその素数が存在する最大数をかけていけば答えを求めることができる。
コード 
int MOD=1000000007;
class ThePermutationGame {
public:
int findMin(int N) {
int ret=1;
for(int i=2;i&amp;lt;=N;i++){
bool prime=true;
for(int j=2;j*j&amp;lt;=i;j++){
if(i%j==0){
prime=false;
break;
}
}
if(prime){
int add=i;
while(add&amp;lt;=N/i)add*=i;
ret=(ret*1LL*add)%MOD;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 653 DIV1 Easy - CountryGroupHard</title>
      <link>https://chaingng.github.io/post/srm-653-div1-easy---countrygrouphard/</link>
      <pubDate>Sun, 12 Apr 2015 10:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-653-div1-easy---countrygrouphard/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13688&amp;amp;rd=16317
・様々な国の人々が、１列になって並んでいる。
・同じ国の人々は連続して並んでいる。
・ここで、その国の人がどのように並んでいるか確かめたい。
・並んでいる人に対して、同じ国の人が何人連続で並んでいるか聞くことができ、
その結果が与えられる。
ただし、聞いていない人の数は０になる。
・このとき、並べ方が１通りに定まればSufficient、そうでなければInsufficientを返す。
解き方 
場合の数を求めるのでｄｐを使う。
SRM411の応用で、ある位置iを考えた時、それより前の長さjからｊ-iまでの長さを
足すことができるか判定する、ｄｐになる。
今回長さを足すことができるかの判定は、
j-iまでの区間について0を除く人の答えが、すべてj-iの長さと一致していればよい。
最終的に、場合の数が１通りであればSuffientになる。
コード 
class CountryGroupHard {
public: string solve(vector&amp;lt;int&amp;gt; a) {
int n=a.size();
int dp[n+1];
memset(dp,0,sizeof(dp));
dp[0]=1;
FORE(i,0,n){
FORE(j,0,i+1){
int len=i-j+1;
int valid=1;
FORE(k,j,i+1){
if(a[k]==0)continue;
if(a[k]!=len)valid=0;
}
if(valid)dp[i+1]+=dp[j];
}
}
return dp[n]==1 ? &#34;Sufficient&#34; : &#34;Insufficient&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 654 DIV1 Easy - SquareScores</title>
      <link>https://chaingng.github.io/post/srm-654-div1-easy---squarescores/</link>
      <pubDate>Sun, 12 Apr 2015 10:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-654-div1-easy---squarescores/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13694&amp;amp;rd=16318
・ある文字列が与えられる。
・文字列はaからzのアルファベット、もしくは?から成る。
・?の場合、aからzの任意の文字列が入る。
・また、ある文字列が与えられた時、そのスコアは連続する文字列の数となる。
（例）aaabaのスコア aが４つ,aaが２つ、aaaが1つ、bが１つで8
・このとき、与えられた文字列のスコアの期待値を求める。
解き方
スコアがabc・・ではなく、aaa,bbbなど連続した文字列だけでよいので、
実は全探索が可能。
各部分文字列の位置について、aからzのすべての文字列が連続するときの
期待値を求めてあげて足していけばよい。
計算量はO(10^3 * 10~3 * 26)=O(10^7*2.6)なので間に合う。
まずは全探索できないか考える原則にのっとる。
コード 
class SquareScores {
public: double calcexpectation(vector&amp;lt;int&amp;gt; p, string s) {
int n=s.size(),m=p.size();
double prob[m];
double ret=0.0;
FORE(i,0,n){
FORE(j,0,m)prob[j]=1.0;
FORE(j,i,n){
if(s[j]==&#39;?&#39;){
FORE(k,0,m)prob[k]*=p[k]*0.01;
}
else{
FORE(k,0,m)if(k!=s[j]-&#39;a&#39;)prob[k]=0.0;
}
FORE(k,0,m)ret+=prob[k];
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 655 DIV1 Easy - BichromePainting</title>
      <link>https://chaingng.github.io/post/srm-655-div1-easy---bichromepainting/</link>
      <pubDate>Sat, 11 Apr 2015 10:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-655-div1-easy---bichromepainting/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13709&amp;amp;rd=16415
・２次元のボードがあり、各セルは最初すべて白に塗られている。
・プレイヤーはK*Kの正方形のマスをすべて白か黒に上塗りすることができる。
・最終的なボードの状態が与えられるとき、そのボードの状態にすることができれば
Possible,そうでなければImpossibleを返す。
解き方 
状態遷移の問題。SRM 595に似ている。
違いとしては、２次元に拡張されているのと、順番が決まっていない、つまり好きに順番を選べるということ。
まずは最終の状態に着目する。
ここで、K*Kのすべて白か黒で塗られている正方形があった場合、
その前の状態が何であっても最後に上書きすることで、その状態にすることができる。
そのような状態を任意の状態&#39;*&#39;に変換して、最後に全て任意の状態にできれば、
その操作を逆にたどることで再現可能なのでPossibleとなる。
コード 
class BichromePainting {
public: string isThatPossible(vector&amp;lt;string&amp;gt; board, int k) {
int h=board.size(),w=board[0].size();
int update=1;
while(update){
update=0;
for(int r=0;r+k-1&amp;lt;h;r++)for(int c=0;c+k-1&amp;lt;w;c++){
int w=0,b=0;
FORE(dr,0,k)FORE(dc,0,k){
if(board[r+dr][c+dc]==&#39;W&#39;)w++;
else if(board[r+dr][c+dc]==&#39;B&#39;)b++;
}
if(w&amp;amp;&amp;amp;b)continue;
if(w==0&amp;amp;&amp;amp;b==0)continue;
update=1;
FORE(dr,0,k)FORE(dc,0,k)board[r+dr][c+dc]=&#39;*&#39;;
}
}
FORE(i,0,h)FORE(j,0,w)if(board[i][j]!=&#39;*&#39;)return &#34;Impossible&#34;;
return &#34;Possible&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 612 DIV2 Middle - EmoticonsDiv2 (○○)</title>
      <link>https://chaingng.github.io/post/srm-612-div2-middle---emoticonsdiv2-/</link>
      <pubDate>Thu, 19 Mar 2015 20:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-612-div2-middle---emoticonsdiv2-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13041
・笑顔のアイコンをsmiles数だけ送りたい。
・最初は１個のアイコンだけすでに送られており、クリップボードは空になっている。
・送り方としては次の２つの操作がある。
（１）クリップボードの数だけの笑顔を送る
（２）現在すでに送っているアイコン数だけクリップボードに張り付ける。
・このとき、最小の操作回数を求める。
解き方 
操作の方法について、単純にｄｐを適用してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[1001][1001];
class EmoticonsDiv2 {
public: int printSmiles(int smiles) {
FORE(i,0,smiles+1)FORE(j,0,smiles+1)dp[i][j]=1e+9;
dp[0][1]=0,dp[1][1]=1;
FORE(i,1,smiles+1)FORE(j,0,smiles+1){
if(i+j&amp;lt;=smiles)dp[i][i+j]=min(dp[i][i+j],dp[i][j]+1);
dp[j][j]=min(dp[j][j],dp[i][j]+1);
}
int ret=1e+9;
FORE(i,0,smiles+1)ret=min(ret,dp[i][smiles]);
return ret;</description>
    </item>
    
    <item>
      <title>SRM 619 DIV2 Middle - ChooseTheBestOne (×○)</title>
      <link>https://chaingng.github.io/post/srm-619-div2-middle---choosethebestone-/</link>
      <pubDate>Thu, 19 Mar 2015 20:07:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-619-div2-middle---choosethebestone-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13146
・N人が円になって並んでいる。
・そこから各ターンｔごとにｔ＾３番目にいる人を消し、その次の人へ移動する。
・このとき、最後に残る人の番号を求める。
解き方 ・各ターンごとに移動する数は、そのターンで残っている人でMODを取れば
計算量が間に合うので、あとはメモ化すれば解くことができる。
・MOD関連でシステムで一度落ちてしまったので、できるだけ実装はシンプルに。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ChooseTheBestOne {
public: int countNumber(int N) {
int dp[N];
memset(dp,0,sizeof(dp));
int s=0;
for(long long t=1;t&amp;lt;N;t++){
while(dp[s])s=(s+1)%N;
long long num=N-t+1;
int move=(((t*t*t)%num)+num-1)%num;</description>
    </item>
    
    <item>
      <title>SRM 596 DIV2 Middle - ColorfulRoad (○○)</title>
      <link>https://chaingng.github.io/post/srm-596-div2-middle---colorfulroad-/</link>
      <pubDate>Thu, 19 Mar 2015 19:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-596-div2-middle---colorfulroad-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12837
複数のタイルからなる１列の道路があり、各タイルは赤、緑、青のいずれかの色が塗られている。
また、最初のタイルは赤色である。
このタイルからスタートし、赤→緑→青→赤・・・の順で右側にあるタイルにジャンプできる。
ただし、ジャンプしたときにその距離の２乗のコストがかかる。
このとき、ゴールまで到達するのに最小のコストを求める。
ゴールまでたどり着けない場合は－1を返す。
解き方 
単純なｄｐで解ける。
道路の配列を文字列から０～２で現すようにしてあげれば
場合分けも簡単になる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ColorfulRoad {
public: int getMin(string road) {
int n=road.size();
int R[n];
memset(R,0,sizeof(R));
FORE(i,0,n){
if(road[i]==&#39;G&#39;)R[i]=1;
else if(road[i]==&#39;B&#39;)R[i]=2;
}</description>
    </item>
    
    <item>
      <title>SRM 621 DIV2 Middle - NumbersChallenge (○○)</title>
      <link>https://chaingng.github.io/post/srm-621-div2-middle---numberschallenge-/</link>
      <pubDate>Thu, 19 Mar 2015 19:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-621-div2-middle---numberschallenge-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13166
・整数の集合Sが与えられる。
・この整数の組み合わせで表わせないような、最小の正の整数を求める。
解き方 
・Sの数が２０、各要素が10^5から
計算量O（20*10^5=2*10^6）でメモリ、速度とも足りそうなのでｄｐで解ける。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[2000001];
class NumbersChallenge {
public: int MinNumber(vector&amp;lt;int&amp;gt; S) {
int n=S.size();
memset(dp,0,sizeof(dp));
dp[0]=1;
FORE(i,0,n)for(int j=2000000-S[i];j&amp;gt;=0;j--)dp[S[i]+j]+=dp[j];
FORE(i,1,2000001)if(dp[i]==0)return i;
return 2000001;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 648 DIV2 Middle - Fragile2 (○)</title>
      <link>https://chaingng.github.io/post/srm-648-div2-middle---fragile2-/</link>
      <pubDate>Mon, 16 Mar 2015 20:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-648-div2-middle---fragile2-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13648&amp;amp;rd=16312

・無向グラフの隣接行列のリストが与えられる。
・このうち２つの頂点を選び、グラフから消した時に木の集合が増える
頂点の選び方を全て求める。
解き方 
・頂点数は２０なので、頂点の選び方は２０C2となり全探索で解ける。
・２つの頂点を選んだときにできる木の集合の数を求め、頂点を消さないときよりも
集合の数が増えるかどうか判定すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int used[30],n;
vector&amp;lt;string&amp;gt; g;
class Fragile2 {
public:
void dfs(int x){
used[x]=1;
FORE(i,0,n)if(!used[i] &amp;amp;&amp;amp; g[x][i]==&#39;Y&#39;)dfs(i);
}
int countPairs(vector&amp;lt;string&amp;gt; graph) {</description>
    </item>
    
    <item>
      <title>SRM 650 DIV1 Easy - TaroFillingAStringDiv1 (○)</title>
      <link>https://chaingng.github.io/post/srm-650-div1-easy---tarofillingastringdiv1-/</link>
      <pubDate>Mon, 16 Mar 2015 20:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-650-div1-easy---tarofillingastringdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13669&amp;amp;rd=16314
・AとBから成る文字列を作りたい。
・ただし、i番目の文字はAかBか決まっており、最初にその情報が与えられる。
・また、できるだけAとBが連続しているようにはしたくない。
・上記の情報が与えられるとき、できるだけAとBが連続しないような文字列の場合の数を
求める。
解き方 
・まず、できるだけAとBが連続しないような文字列を求める。
与えられた情報の位置でソートし、それぞれの間について考える。
このとき、それぞれのスペースの数＋両端のAかBの一致か不一致かによって
AとBがひとつも連続しないか、そうでないかがわかる。
・次に、そのような場合の数を求める。
・AとBが連続しないようなケースの場合は1通りしか置き方はない。
・AとBが連続するようなケースは、スペースの数だけ場合の数が存在する。
・最後にそれぞれのスペースについての積をとってあげれば答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int MOD=1000000007;
class TaroFillingAStringDiv1 {
public: int getNumber(int N, vector&amp;lt;int&amp;gt; position, string value) {</description>
    </item>
    
    <item>
      <title>SRM 648 DIV1 Easy - AB (×)</title>
      <link>https://chaingng.github.io/post/srm-648-div1-easy---ab-/</link>
      <pubDate>Mon, 16 Mar 2015 20:03:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-648-div1-easy---ab-/</guid>
      <description>問題 
・文字の長さがNであり、’A’か’B’から成る文字列を作りたい。
・ただし、Aより後ろのどこかにBがあるペアをK個作りたい。
・そのような文字列を作れない場合は-1を、作れる場合はそのような文字列のうち一つを出力する。
解き方 
・最大のペア数はN/2 * (N-N/2)であるので、これよりもKが大きければそのような文字列を
作れない。
・作れる場合は実装するだけ。Aを出力するときに、それより右にあるべきBの数を保存してあげるように解いた。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AB {
public: string createString(int N, int K) {
string ret=&#34;&#34;;
for(int a=0;a&amp;lt;=N/2;a++){
int b=N-a;
if(a*b&amp;lt;K)continue;
vector&amp;lt;int&amp;gt; v;
FORE(i,0,a){</description>
    </item>
    
    <item>
      <title>SRM 639 DIV2 Middle - AliceGameEasy (○)</title>
      <link>https://chaingng.github.io/post/srm-639-div2-middle---alicegameeasy-/</link>
      <pubDate>Mon, 16 Mar 2015 19:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-639-div2-middle---alicegameeasy-/</guid>
      <description>問題 
・整数ｘとｙが与えられる。
・ｘ＝０、ｙ＝０からスタートし、１から順に数を増やしていき毎回ｘとｙのどちらかにその数を足す。
・与えられたｘとｙにすることができるなら、そのうちｘに数を足す最小の回数を求める。
・そのような足し方がない場合は-1を返す。
解き方 
・１から順番に和をとっていき、ｘ＋ｙ以上となったときちょうどｘ＋ｙとなればそのような
足し方は存在し、そうでなければ存在しない。
ｘ＋ｙ=2*10^12で、n*(n+1)/2がnまでの和なので最大でn=10^6なので間に合う。
・そのような足し方が存在した場合、今度は上で求めた最大のnから1ずつ引いていく。
そして毎回x以下であればxを引いていき、0になるまでの引いた数が
最終的な答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AliceGameEasy {
public: long long findMinimumValue(long long x, long long y) {
long long sum=0,n=0;
while(sum&amp;lt;x+y){
n++;</description>
    </item>
    
    <item>
      <title>SRM 645 DIV2 Middle - ConnectingCars (○)</title>
      <link>https://chaingng.github.io/post/srm-645-div2-middle---connectingcars-/</link>
      <pubDate>Mon, 16 Mar 2015 19:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-645-div2-middle---connectingcars-/</guid>
      <description>問題 
・一列の道路に車が複数あり、その車の先頭位置とその長さが与えられる。
・全ての車を連結したいとき、必要となる最小の移動距離を求める。
解き方 
・車を連結させるとき、そのうち一つの車の位置は固定となることがわかれば解ける。
・あとは実装の問題。
ある車を固定した時の移動距離を、左側にあるものの計算と右側にあるものの計算を分けて、
近い順に行っていけばシンプルに実装できる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ConnectingCars {
public: long long minimizeCost(vector&amp;lt;int&amp;gt; positions, vector&amp;lt;int&amp;gt; lengths) {
int n=positions.size();
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
FORE(i,0,n)p.push_back(make_pair(positions[i],lengths[i]));
sort(all(p));
long long ret=1e+18;
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 646 DIV1 Easy - TheConsecutiveIntegersDivOne x○</title>
      <link>https://chaingng.github.io/post/srm-646-div1-easy---theconsecutiveintegersdivone-x/</link>
      <pubDate>Sun, 15 Mar 2015 11:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-646-div1-easy---theconsecutiveintegersdivone-x/</guid>
      <description>問題 
・複数の数字が与えられる。
・ｋ個の数字が連続して並ぶようにしたい。
・数字を１つ動かすのにコストが１かかるとき、最小のコストを求める。
解き方 
・数字を連結させるための最小コストを求めるとき、
少なくともひとつの数字の場所は固定されていることがわかれば解ける。
・あとはｋ個の連続する数字の範囲全てについて、そのうち全ての数字を固定した場合の
最小コストを求めればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheConsecutiveIntegersDivOne {
public: int find(vector&amp;lt;int&amp;gt; numbers, int k) {
int n=numbers.size();
sort(all(numbers));
int ret=1e+9;
for(int i=0;i+k-1&amp;lt;n;i++){
for(int j=i;j&amp;lt;=i+k-1;j++){
int cost=0;</description>
    </item>
    
    <item>
      <title>SRM 647 DIV2 Middle - TravellingSalesmanEasy (○)</title>
      <link>https://chaingng.github.io/post/srm-647-div2-middle---travellingsalesmaneasy-/</link>
      <pubDate>Sun, 15 Mar 2015 11:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-647-div2-middle---travellingsalesmaneasy-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13631&amp;amp;rd=16279
・M個の都市があり、その訪問順が決まっている。
・複数のアイテムについて、そのアイテムを売った時の利益と、そのアイテムを売ることができる都市のペアが与えられる。
・アイテムについて、その都市を訪問するごとにひとつ売ることができる。
・このとき、得られる最大の利益を求める。
解き方 
・訪問順が決まっており、かつ一つのアイテムについて売ることのできる都市は１つであるので、
貪欲法で解くことができる。
計算量はO(１００＊２５００＝２．５＊１０＾５)なので間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TravellingSalesmanEasy {
public: int getMaxProfit(int M, vector&amp;lt;int&amp;gt; profit, vector&amp;lt;int&amp;gt; city, vector&amp;lt;int&amp;gt; visit) {
int ret=0;
int n=profit.size();
int used[n];</description>
    </item>
    
    <item>
      <title>SRM 642 DIV2 Middle - LightSwitchingPuzzle (○)</title>
      <link>https://chaingng.github.io/post/srm-642-div2-middle---lightswitchingpuzzle-/</link>
      <pubDate>Sun, 15 Mar 2015 10:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-642-div2-middle---lightswitchingpuzzle-/</guid>
      <description>問題 
・N個のスイッチがある。
・各スイッチはONかOFFの状態を持ち、その初期状態が与えられる。
・各スイッチはその位置の倍数のスイッチと連動しており、そのスイッチを押すと連動しているスイッチの状態も変化する。
・すべてのスイッチをOFFにしたいとき、最小の操作回数を求める。
・ただしそのような操作ができないときはー１を返す。
解き方 
・あるスイッチを操作するとき、それよりも左のスイッチの動作には影響しない。
・よって左からONのスイッチに対してOFFにしていけば、最小の操作ですべてのスイッチがOFFになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class LightSwitchingPuzzle {
public: int minFlips(string state) {
int n=state.size();
int p[n];
FORE(i,0,n)p[i]=(state[i]==&#39;Y&#39;);
int ret=0;
while(accumulate(p,p+n,int())!=0){
int idx=0;
while(p[idx]==0)idx++;
ret++;
for(int i=idx;i&amp;lt;n;i+=idx+1)p[i]=1-p[i];</description>
    </item>
    
    <item>
      <title>SRM 640 DIV1 Easy - ChristmasTreeDecoration (○)</title>
      <link>https://chaingng.github.io/post/srm-640-div1-easy---christmastreedecoration-/</link>
      <pubDate>Thu, 11 Dec 2014 08:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-640-div1-easy---christmastreedecoration-/</guid>
      <description>問題 http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13551&amp;amp;rd=16083
・クリスマスツリーをデコレーションするのに、N個の星とN-1個のリボンがある。
・星には色がついていて、全ての星をリボンで一つにつなげたい。
・ただし、できるだけリボンでつなげるときの星の色は異なるようにしたい。
・また、つなぐことのできる星のペアもわかっている。
・このとき、同じ色同士の星をつなげるリボンの最小数を求める。
解き方 
・ぱっと見て、ダイクストラ法に見える。
・ただし、ダイクストラでつなげていって最後に同じ色同士の星しかつなげられない場合、
つなげた星によって解が異なってしまう。
・よって、まずは部分的につながっていなくて、かつ異なる色の星をつなげていく。
・そのような星がなくなったら、同じ色の星をつなげる。
・集合を使おうかと思ったが、ワーシャルフロイドで計算量は
50*50*50*50=25*25*10000=625*10^4=6.25*10^6で間に合う。
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ChristmasTreeDecoration {
public: int solve(vector&amp;lt;int&amp;gt; col, vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
int n=col.size();</description>
    </item>
    
    <item>
      <title>SRM 595 DIV1 Easy - LittleElephantAndIntervalsDiv1 (×○)</title>
      <link>https://chaingng.github.io/post/srm-595-div1-easy---littleelephantandintervalsdiv1-/</link>
      <pubDate>Wed, 10 Dec 2014 21:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-595-div1-easy---littleelephantandintervalsdiv1-/</guid>
      <description>問題 http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12822&amp;amp;rd=15707
M個のボールがあり、１からMまで順番に番号がついている。
ボールの色は最初は白。
複数のステージが与えられ、各ステージiについてL[i]番目からR[i]番目までの色を
白か黒の好きな色どちらか一色に塗る。
このとき、色の塗り方は何通りあるか求める。
解き方 
・色の塗り方なので、ボールの区切りの数を求め、その２＾（区切り数）が
答えになりそう？
・サンプルを見るとこれでは失敗。
→他の人のコードをみる。
・順番に色を塗っていく、という問題文の条件を見落としていた。
・各ボールについて順番に色をぬっていくときのステージ数を上書きしていく。
・最後に残った、各ボールのステージ数の場合の数について２の累乗をとってあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class LittleElephantAndIntervalsDiv1 {
public: long long getNumber(int M, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R) {
int n=L.size();
int p[M+1];</description>
    </item>
    
    <item>
      <title>SRM 597 DIV1 Easy - LittleElephantAndString (○)</title>
      <link>https://chaingng.github.io/post/srm-597-div1-easy---littleelephantandstring-/</link>
      <pubDate>Wed, 10 Dec 2014 21:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-597-div1-easy---littleelephantandstring-/</guid>
      <description>問題 http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12854&amp;amp;rd=15709
文字列の長さが同じである、文字列Aと文字列Bが与えられる。
文字列Aの任意の文字を１つ選んで、先頭に持ってくる動作を繰り返して文字列Bにしたい。
このとき、必要な最小の操作回数を求める。
どうしても文字列Bにできないときは-1を返す。
解き方 
・文字列Aの先頭からｘ文字と、文字列Bの後ろからｘ文字のうち最長のｘを求め、
残りの文字列長が答えになる？
・サンプルをみると、Aの部分文字列のうち間の文字をとることで部分文字列Bにもできるので
そうではなさそう。
・間の文字を取れるということは、Aの部分文字列とBの最後からｘ文字の文字列のうち
最長のｘをとれればよさそう。
・最長部分文字列の問題なのでｄｐでｘを求める。
→System Passed
・AもBも部分文字列であればｄｐだが、Bは固定文字列なので貪欲法でもよかった。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class LittleElephantAndString {
public: int getNumber(string A, string B) {
int n=A.size();
int a[26]={},b[26]={};</description>
    </item>
    
    <item>
      <title>SRM 598 DIV1 Easy - BinPacking (○×)</title>
      <link>https://chaingng.github.io/post/srm-598-div1-easy---binpacking-/</link>
      <pubDate>Wed, 10 Dec 2014 21:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-598-div1-easy---binpacking-/</guid>
      <description>問題 http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12861&amp;amp;rd=15710
複数のアイテムが与えられ、それを瓶に格納したい。
１つの瓶には重さ３００までのアイテムしか入れられない。
各アイテムの重さがわかっているとき、最低でいくつ瓶が必要か求める。
解き方 
・問題文だけを考えると、かなりの数の組み合わせがありそう。
・条件をみると、ひとつのアイテムの重さは１００～３００．
・これから、１つの瓶に入るアイテムは１～３つ。
・アイテムの重さが２０１以上であれば１つの瓶には１つしか入らない。
・重さが１００であるアイテムが３つあれば１つの瓶に３つ入れられる。
・残りはソートして、一番大きいアイテムと小さいアイテムの合計が３００以下であれば
一つに入れて、そうでなければ大きいアイテム１つだけ瓶に入れる。
・上記の条件を貪欲法で、と思ったが
１００のアイテムを３つ入れるケースと一番大きいアイテムと
小さいアイテムの２つを入れるケースでは、どちらがよいかは選択できない。
・こういうときはｄｐに切り替える。
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[60][60];
vector&amp;lt;int&amp;gt; items;
class BinPacking {
public:
int rec(int l,int r){</description>
    </item>
    
    <item>
      <title>SRM 633 DIV1 Easy - PeriodicJumping (×××)</title>
      <link>https://chaingng.github.io/post/srm-633-div1-easy---periodicjumping-/</link>
      <pubDate>Mon, 24 Nov 2014 21:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-633-div1-easy---periodicjumping-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13234&amp;amp;rd=16076
・点（０，０）からスタートし、ゴール（ｘ、０）まで到達したい。
・ジャンプして移動することができ、ジャンプできる距離の配列が与えられる。
この順にジャンプして到達する必要がある。配列が終了したら最初の要素に戻る。
・このとき、ゴールまで到達するのに必要な最小のジャンプ回数を求める。
解き方 ・多角形を構成する問題であり、構成するには最大の辺＜その他の辺の合計である
必要がある。今回は直線でもよいので等号が成立する。
・配列の長さをｎ、配列の距離の合計をSとする。
・ｘ＜＝Sのとき
２＊ｎまでにゴールに到達することができる。
ｎ＝０～２ｎ－１まで順に調べていき、それまでの距離の合計がｘ以上であり
かつ最大の長さの辺が合計距離の半分以下であればそこが答えになる。
・それ以外（ｘ＞S）のとき
順に調べていき、距離の和がｘを超えた時が答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PeriodicJumping {
public: int minimalTime(int x, vector&amp;lt;int&amp;gt; jumpLengths) {
if(x==0)return 0;
if(x&amp;lt;0)x=-x;
int n=jumpLengths.size();</description>
    </item>
    
    <item>
      <title>SRM 609 DIV1 Easy - MagicalStringDiv1 (○)</title>
      <link>https://chaingng.github.io/post/srm-609-div1-easy---magicalstringdiv1-/</link>
      <pubDate>Sat, 22 Nov 2014 23:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-609-div1-easy---magicalstringdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13003&amp;amp;rd=15842
・’＜’と’＞’で表わされる配列が与えられる。
・この配列から、順序を保って任意の文字を抜き出したサブ文字列を考える。
・このサブ文字列が、＞が最初にｎ個続き、次に＜がｎ個続くようなもののうち最大の２＊ｎを
求める。
解き方 
・順序を保ったサブ文字列の生成であるので、ある位置を選び、そこから左側で作れる最大の＞の数と右側で作れる最大の＜の数のうち最小の数＊２がその位置での最大の２＊ｎとなる。
・上記について、全ての位置について試して最大のものを返してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MagicalStringDiv1 {
public: int getLongest(string S) {
int n=S.size();
int ret=0;
FORE(i,0,n){
int l=0,r=0;
FORE(j,0,i)if(S[j]==&#39;&amp;gt;&#39;)l++;
FORE(j,i,n)if(S[j]==&#39;&amp;lt;&#39;)r++;
ret=max(ret,min(l,r)*2);
}
return ret;</description>
    </item>
    
    <item>
      <title>SRM 605 DIV1 Easy - AlienAndHamburgers (○)</title>
      <link>https://chaingng.github.io/post/srm-605-div1-easy---alienandhamburgers-/</link>
      <pubDate>Sat, 22 Nov 2014 15:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-605-div1-easy---alienandhamburgers-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12948&amp;amp;rd=15838
・様々なハンバーガーがあり、そのタイプと大きさが与えられる。
・好きなだけハンバーガーを選んでよく、選んだ後のスコアは選んだタイプの種類×大きさの和
となる。
・このとき、取りうる最大のスコアを求める。
解き方 
・大きさがマイナスになるときは判定が必要になる
・とりあえず、大きさが０以上の時はスコアが下がることはないので必ず選ぶ
・ソートして、大きい順に判定
・大きさが０以上のときは必ず選び、マイナスのときはそのハンバーガーを選んだときにスコアが上がれば選び、そうでなければ選ばないのが最適解になりそう
・あるハンバーガーを選ばないとき、それより小さい大きさのときはスコアはそれ以上にならないので貪欲法で解ける
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AlienAndHamburgers {
public: int getNumber(vector&amp;lt;int&amp;gt; type, vector&amp;lt;int&amp;gt; taste) {
int n=type.size();
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
FORE(i,0,n)p.push_back(make_pair(taste[i],type[i]));</description>
    </item>
    
    <item>
      <title>SRM 610 DIV1 Easy - TheMatrix (×○)</title>
      <link>https://chaingng.github.io/post/srm-610-div1-easy---thematrix-/</link>
      <pubDate>Tue, 18 Nov 2014 08:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-610-div1-easy---thematrix-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13035&amp;amp;rd=15843
・白と黒で表わされる２次元のボードが与えられる。
・ここから任意の長方形を選び、それが交互に白と黒が現れる模様であればそれはチェスボードと呼ぶことができる。
・そのうち、最大の大きさとなるチェスボードの面積を求める。
解き方 
・ボードの大きさは最大１００＊１００
・ボードの長方形の選び方は１０＾８なのでギリギリそう。
・長方形を選んだときにそれがチェスボードとO(1)で判断できれば間に合うが・・・
→他の人のコードをみる
・あらかじめ各行について、どの長さまでチェスボードが成立するか事前計算しておく。
・長方形の左上の点のすべてについて、一つずつ下に拡大していき
左の点がチェスボードが続けば、その下の行の続くチェスボードの長さとの最小をとれば
そのときの最大のチェスボードを計算することができる。
・反省：ボードの計算方法をシミュレーションするのが不足していた。もっと紙に書くのが必要。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int d[101][101];
class TheMatrix {
public: int MaxArea(vector&amp;lt;string&amp;gt; board) {
int h=board.size(),w=board[0].size();
memset(d,0,sizeof(d));
FORE(i,0,h)FORE(j,0,w){
int len=1;</description>
    </item>
    
    <item>
      <title>SRM 612 DIV1 Easy - EmoticonsDiv1 (××○)</title>
      <link>https://chaingng.github.io/post/srm-612-div1-easy---emoticonsdiv1-/</link>
      <pubDate>Sat, 15 Nov 2014 21:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-612-div1-easy---emoticonsdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10543&amp;amp;rd=15845
・笑顔の顔文字をsmiles分送りたい。
・最初はsmiles１個分送っている。
・１回の操作で、現在の送っている数をクリップボードにコピーできる。
・１回の操作で、クリップボードにコピーしている分の顔文字を送ることができる。
・１回の操作で、現在送っている数を一つ減らすことができる。
・このときの最小の操作回数を求める。
解き方 
・dpで解けそう
・パラメータとしては、これまでに送っている顔文字の数、クリップボードにコピーされている顔文字の数で計算量も足りそう
・サンプルは通った
→System Failed
・削除はｄｐの順序が変わるんで単純なｄｐでは解けない
・なのでBFSで解く必要がある。距離が小さくなればキューに入れて、smiles数分送ったときの距離が答えになる。
・反省：ｄｐっぽいが、探索の順が一方向でないときは単純に適用できなく、BFSを用いるケースがある。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int d[3001][2001];
class EmoticonsDiv1 {
public: int printSmiles(int smiles) {
FORE(i,0,3001)FORE(j,0,2001)d[i][j]=1e+9;
d[1][0]=0;
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;</description>
    </item>
    
    <item>
      <title>SRM 611 DIV1 Easy - LCMSet (××)</title>
      <link>https://chaingng.github.io/post/srm-611-div1-easy---lcmset-/</link>
      <pubDate>Sat, 15 Nov 2014 20:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-611-div1-easy---lcmset-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12918&amp;amp;rd=15844
・数字のセットAとBが与えられる。
・与えられた数字のセットXに対し、その任意の組み合わせのLCMで作られる集合をLCM（X)とする。
・AとBについて、LCM(A)＝LCM(B)になるかどうか求める。
解き方 
・各セットすべてのLCMを求め、それが一致するかどうかでよいか
・しかしサンプルを見ると計算するとオーバーフローしそう
・片方のセットすべてのLCMを、もう片方のセットのすべてで割れたらよいか
・通らないサンプルがある
・片方のセットそれぞれの数について、もう片方のセットで作れたらよさそう
・とりあえず各数について割れたら割っていって、最後に１になればよいか。
・これも通らないサンプルがある。
・たしかに、４について２で割って４で割ろうとすると割れないが１になる組み合わせがある
・ここで行き詰ってしまう
→他の人のサンプルをみる
・片方のそれぞれの数について、もう片方のセットの任意のLCMで作れたらよかった
・確かに求めるのはLCMなので、割るのではなかった
・LCMで作れるかどうかは、どの数を選ぶかがキーとなる。
・選び方としてその数についてもう片方の要素で割り切れるならばLCMの要素とすれば
その要素は超えないのでOK
・反省：惜しいところまではいっていたがもう一歩。LCMとGCDの使いこなし方をまた学んだ。
(別解)
各集合Xのうち、LCM(X)を作れる最小の要素のみを抽出して、それが一致するか確かめてもよい。
ある集合の数aについてそれが必要な数かどうかは、その他の数yについて
aをyで割りきることができればそのLCMをとっていき、最後に一致するかどうかで判定できる。
（＝aを構成できる最大のLCM）
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class LCMSet {</description>
    </item>
    
    <item>
      <title>SRM 613 DIV1 Easy - TaroFriends (復習○)</title>
      <link>https://chaingng.github.io/post/srm-613-div1-easy---tarofriends-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 14 Nov 2014 19:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-613-div1-easy---tarofriends-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13005&amp;amp;rd=15846
・猫が一直線上に数匹存在する。
・それぞれの猫が１度移動し、その移動する距離はDであることがわかっている。
・ただし、左側もしくは右側のどちらに移動するかはわかっていない。
・移動した後に、最も左端と右端の猫の距離が最短になるときの値を求める。
解き方 
・とりあえずソートして考えるのがよさそう
・左端と右端は右と左に動けばよい？
・左と右をポイントし、そのうち差の距離が小さくなる方を採用していけばよいか
・サンプルは通った
→System Failed
・貪欲法で解こうとしたが、ソートしたのちに左に動く集合と、右に動く集合にわける場合の数は最大５１通りなので全探索できる。
・なんとなく思いついたが、貪欲法の方を実装してしまった。
・反省：トレースして思いついた貪欲法を実装してしまったが、今回のようにソートした後に全探索が可能なケースがあるので全探索の線を優先して考える。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TaroFriends {
public: int getNumber(vector&amp;lt;int&amp;gt; coordinates, int X) {
int n=coordinates.size();
sort(all(coordinates));
long long ret=1e+18;</description>
    </item>
    
    <item>
      <title>SRM 616 DIV1 Easy - WakingUp (○)</title>
      <link>https://chaingng.github.io/post/srm-616-div1-easy---wakingup-/</link>
      <pubDate>Thu, 13 Nov 2014 19:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-616-div1-easy---wakingup-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13124&amp;amp;rd=15849
・Alexは深く眠っており、どれだけ眠りが深いかはわかっていない。
・ただし、1秒ごとにDずつ眠りが深くなっていく。
・目覚まし時計が複数あり、最初にどの時刻でなり、１回鳴るごとにへる眠りの深さの値と、何秒周期で鳴るかの情報がわかっている。
・このとき、Alexがいつか起きるときの最大の眠りの深さの値を求める。
・ただし、どれだけ眠りが深くてもいつかは目覚めるときは-1を返す。
解き方 
・目覚まし時計の数は最大50、間隔は最大10なので全探索で解けそう。
・各時間において増減する眠さの値を記憶しておけば、いつが最小化がわかり、つまり眠りの最大の深さがわかる。
・ただし、これだけではいつか目覚めるかどうかはわからない。
・なので周期を見つけ、次の周期に必ず値が小さくなるなら-1、そうでなければ答えがあることがわかる。
・周期としては各periodの最小公倍数＋最初に鳴る最大の時刻をとればよさそう。
→System Passed
・周期は最小公倍数を計算したが、単に1*2*3...*10=2520と固定してもよさそうだった。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class WakingUp {
public:
int gcd(int x,int y){
return y ? gcd(y,x%y) : x;</description>
    </item>
    
    <item>
      <title>2012 TCO Algorithm Round 1C Easy - PasswordXGuessing　(×○)</title>
      <link>https://chaingng.github.io/post/2012-tco-algorithm-round-1c-easy---passwordxguessing/</link>
      <pubDate>Thu, 13 Nov 2014 18:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2012-tco-algorithm-round-1c-easy---passwordxguessing/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11867&amp;amp;rd=15092
・数字で表わされるあるパスワードがある。
・そのパスワードを忘れてしまったが、複数の人がどのパスワードであったか答えてくれる。
・ただし、そのパスワードは思い出したものであるため１文字だけ間違っている。
・このとき、元のパスワードとして考えられるものの数を求める。
解き方 
・ｄｐを利用する？
・各桁についてあっているか、間違っているか、どちらでもよいかの情報をもつ
・でもこれだと計算量が間に合わない・・・
→他の人のコードをみる
・パスワードは５０ケタであるので、最悪５０＊１０＝５００個しか存在しない
・よって全探索可能
・反省：全探索の検討が足りなかった。ぱっとｄｐ？と思ってしまったが解の候補、探索の候補どちらも全探索を検討するのが基本。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PasswordXGuessing {
public: long long howMany(vector&amp;lt;string&amp;gt; guesses) {
int n=guesses.size(),m=guesses[0].size();
set&amp;lt;string&amp;gt; s;
FORE(i,0,n){
set&amp;lt;string&amp;gt; tmp;</description>
    </item>
    
    <item>
      <title>SRM 615 DIV1 Easy - AmebaDiv1 (×○)</title>
      <link>https://chaingng.github.io/post/srm-615-div1-easy---amebadiv1-/</link>
      <pubDate>Wed, 12 Nov 2014 19:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-615-div1-easy---amebadiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13088&amp;amp;rd=15848
・アメーバがいて、同じ大きさのジェルがあればそれを吸収して２倍の大きさになる。
・アメーバの最初の大きさはわかっていない。
・アメーバがある道を通り、通る順番に置かれているそれぞれのジェルの大きさがわかっている。
・このとき、最終的にアメーバがどうしても取ることのできない大きさの場合の数を求める。
解き方 
・ジェルの大きさは10^9なので、すべての大きさに対して全探索はできなさそう
・大きさの場合の数を求めるので、重複するもの、
つまりある大きさに対してそれよりも後に同じ大きさが現れた際はノーカウントにする
・次にどのような大きさのものが取ることができないかチェックする
・取りうるジェルの大きさとして、最初に与えられているジェルの大きさ以外のものは必ず取ることができるので答えにならない。
・つまり、最初に与えられているジェルの大きさが解の候補となる。
・あとは変化によってその大きさにならないかをチェックする。　・つまり各大きさについて、最初に与えられているすべてのジェルの大きさについてシミュレーションし、その大きさにならなければよさそう
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AmebaDiv1 {
public: int count(vector&amp;lt;int&amp;gt; X) {
int ret=0;
int n=X.size();
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 618 DIV1 Easy - Family (復習○)</title>
      <link>https://chaingng.github.io/post/srm-618-div1-easy---family-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Nov 2014 19:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-618-div1-easy---family-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10541&amp;amp;rd=15851
・有効グラフが２つ与えられる。
・それぞれのグラフは親と子の関係を示しており、ｘ→ｙのときｘが親、ｙが子になる。
・子は親がいないか、２人の親がいるかのどちらかでなければならない。
・子のノード番号より、親のノード番号の方が小さくてはならない。
・２人親がいる場合は、１人が父親、１人が母親でなくてはならない。
・与えられたグラフが上記の条件を満たす場合は&#34;Possible&#34;、満たさない場合は
&#34;Impossible&#34;を返す。
解き方 
・まず、子について親が０もしくは２人でないかを判定する。
・次に、ノード番号について規則通りかを判定する。
・次に、母親と父親とペアになるべきノードについて無向グラフを作成する。
・最後に、そのグラフについて母親もしくは父親を埋めていき、条件を満たすかどうか判定する。
→System Failed
・母親もしくは父親の埋め方がまずかった。
・最初はすべてのノードを順番に埋めていったが、これでは最適な埋め方にならない。
・最初に埋めていないノードを選択して父親か母親としたとき、それに連結したノードをBFSで調べていけばよい。
・反省：自分の書いたコードが正しいかのトレース不足だった。思いつきだけではなく
きちんと検証する癖をつける。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Family {
public: string isFamily(vector&amp;lt;int&amp;gt; parent1, vector&amp;lt;int&amp;gt; parent2) {</description>
    </item>
    
    <item>
      <title>SRM 617 DIV1 Easy - MyLongCake (○)</title>
      <link>https://chaingng.github.io/post/srm-617-div1-easy---mylongcake-/</link>
      <pubDate>Mon, 10 Nov 2014 19:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-617-div1-easy---mylongcake-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13137&amp;amp;rd=15850
・ある長さｎのケーキがある。
・人が何人訪れるかわかっていないが、ｎの約数の人数だけ人が訪れる可能性がある。
・１人人が現れた時、あらかじめ分けられたケーキのうち残りの最初から好きな数だけ
分け与えることができる。
・このとき、何人訪れた場合でもすべての人に同じ長さだけ均等にケーキをわけられるような
ケーキの分割数を求める。
解き方 
・訪れる可能性のある人数全てに対し等分にケーキを切り、最後に残ったケーキの分割数が
答えになりそう。
・求め方として、すべての約数に対しケーキを分ける箇所すべてを答えに保存して
最後に重複なしの数を返せばよい。
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MyLongCake {
public:
int cut(int n) {
set&amp;lt;int&amp;gt; ans;
FORE(i,1,n)if(n%i==0){
int d=n/i;
for(int j=d;j&amp;lt;=n;j+=d)ans.insert(j);</description>
    </item>
    
    <item>
      <title>2011 TCO Online Round 1 - TripleStrings</title>
      <link>https://chaingng.github.io/post/2011-tco-online-round-1---triplestrings/</link>
      <pubDate>Mon, 10 Nov 2014 19:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2011-tco-online-round-1---triplestrings/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11374&amp;amp;rd=14560
・○とXからなる配列initがあらかじめ与えられる。
・この配列を操作して、最終的にはgoalで示される配列にしたい。
・可能な操作としては、最初に空の配列B,Cがあり、initをAとする。
・１操作で、Aの最初の１文字をBもしくはCの最後につけることが可能。
・もしくは１操作で、BもしくはCの最初１文字をAの最後につけることが可能。
・このとき、必要な最小の操作回数を求める。
解き方 
・まず、initの配列の一部を残した方法がありそう。
・この方法は残りの配列のうち○をすべてBに、×をすべてCに入れることで
残りの配列＊２が答えになる。
・他の方法としては、AをBにして・・・等いろいろ考えて行き詰ってしまった。
→他の人のコードをみる。
・他の方法は最初に考えた方法に含まれる、つまり最悪ケースで文字列長×２回となる。
・反省：問題文の読み方と紙に書いたトレースが悪かった。もっと整理が必要。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TripleStrings {
public: int getMinimumOperations(string init, string goal) {
int ret=1e+9;
int n=init.size();</description>
    </item>
    
    <item>
      <title>2011 TCO Qualification Round 3 - AllButOneDivisor (○)</title>
      <link>https://chaingng.github.io/post/2011-tco-qualification-round-3---allbutonedivisor-/</link>
      <pubDate>Sat, 08 Nov 2014 23:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2011-tco-qualification-round-3---allbutonedivisor-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11415&amp;amp;rd=14531
・ｎ個の数字が与えられる。
・このうち、n-1個の数字で割ることができ残りの数字で割ることのできない数のうち最小のものを求める。そのような数字がないときは-1を返す。
解き方 
・数字の数は最大６個なので全探索できそう。
・n-1個の数字で割ることができる数、つまりn-1個の数字の最小公倍数がこれを満たす。
この数字が残りの数字で割ることができなければ解の候補となる。
逆に残りの数字で割ることができればどのようにとっても割ることができてしまうため満たさない。
→System Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AllButOneDivisor {
public:
int gcd(int x,int y){
return y ? gcd(y,x%y) : x;
}
int getMinimum(vector&amp;lt;int&amp;gt; divisors) {</description>
    </item>
    
    <item>
      <title>SRM 637 DIV1 Easy - DivisorsPower (○)</title>
      <link>https://chaingng.github.io/post/srm-637-div1-easy---divisorspower-/</link>
      <pubDate>Sat, 08 Nov 2014 12:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-637-div1-easy---divisorspower-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13504&amp;amp;rd=16080
・1から2Nまで書かれた、2N枚のカードがあり、2人でゲームを行う。
・このカードが自分と相手それぞれ均等に配られる。
・2人が一枚ずつカードを出し、大きい数字の方が１ポイント得られる。
・自分のカードについては、何が配られたかわかっている。
・相手のカードについては自分のカードから推測できるが、カードを出す順番もわかっている。
ただし、-1で示されているときは何が出されるかわかっていない。
・このとき、自分が得ることのできるスコアの最大の期待値を求める。
解き方 
・まず、自分のカードから相手のカードを推測し配列に保存する。
・相手のカードについて、出すものがわかっているものに対しては最適な戦略を取る。
・つまり、ある相手のわかっているカードについてそれより大きい数のカードがある場合は
そのうち最小のものを出す。
・大きい数のカードがない場合は一番小さいカードを出す。
・残りのカードについては総当たりで計算して期待値を足していけばよい。
→System Passed
・もっとシンプルな解き方があるのか他のコードをみてみたが、この方法が一番シンプルそう。
紙に書いて手順を整理すれば着実に解ける。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class GreaterGame {
public: double calc(vector&amp;lt;int&amp;gt; hand, vector&amp;lt;int&amp;gt; sothe) {</description>
    </item>
    
    <item>
      <title>2013 TCO Round 1C Easy - TheArray (×○)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-1c-easy---thearray-/</link>
      <pubDate>Sat, 08 Nov 2014 11:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-1c-easy---thearray-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12455&amp;amp;rd=15585
・最初のスタート位置firstと最後の位置last、移動できる回数nと一度に移動できる最大数dが与えられる。
・スタート位置からn回移動し、最後に最後の位置に到達している必要があるとき、
途中で到達しうる最大の高さを求める。
解き方 
・問題として２分探索が使えそう。
・ある位置を考えた時、スタート位置から到達するために必要なターン数と、そこから最後の位置に到達するためのターン数の和がｎ以下であればよさそう。
・２分探索の最小値はスタート位置もしくは最後の位置のうち小さいもの、最後に得られた値と小喜一のうち最大のものが答えになる。
→System Passed
・他の解き方、というか一番わかりやすい解き方として、nは10^6で全探索できるので
各ターンにおいて最初の位置から到達しうる高さ、最後の位置から到達しうる高さのうち最小の　ものを取り、そのうち最大のものを求めれば簡単。
・反省：全探索できる変数、探索を考えてみる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheArray {
public: int find(int n, int d, int first, int last) {
if(d==0)return max(first,last);</description>
    </item>
    
    <item>
      <title>SRM 628 DIV1 Easy - DivisorsPower (×)</title>
      <link>https://chaingng.github.io/post/srm-628-div1-easy---divisorspower-/</link>
      <pubDate>Fri, 07 Nov 2014 21:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-628-div1-easy---divisorspower-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13241&amp;amp;rd=16009
・ある正の整数nを考えた時、その約数の数である関数d(n)とh(n)=n*d(n)を考える。
・nが与えられた時、h(x)を満たす最も小さいxを求める。そのようなxがなければ-1を返す。
解き方 
・nは10^18のため工夫が必要そう。
・与えられたnを素因数分解して、その階乗で考えればよいか。
・でも素因数分解が間に合わなさそう。
・ではｎから平方根、３乗根・・・としていき探索すればよいか。
・３乗根以上はベースの数を求めるのが難しそう。２分探索も無理がある。
→他の人のコードをみる
・２乗の場合を除けば、３乗以上になるのでベースの数は10^6までになるので
全探索できる。
・２乗の場合は平方根をとれば簡単に確かめられる。
・反省：階乗の問題は２乗と３乗以上を別に考えて探索範囲を狭めることで全探索ができる、
という視点は勉強になった。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class DivisorsPower {
public:
long long calc(long long x){
long long ret=0;
for(long long i=1;i*i&amp;lt;=x;i++)if(x%i==0)ret+=1+(i*i!</description>
    </item>
    
    <item>
      <title>SRM 627 DIV1 Easy -  HappyLetterDiv1 (××)</title>
      <link>https://chaingng.github.io/post/srm-627-div1-easy----happyletterdiv1-/</link>
      <pubDate>Thu, 06 Nov 2014 22:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-627-div1-easy----happyletterdiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13274&amp;amp;rd=16008
・ある文字列が与えられる。
・２つ異なる文字を選んで消す操作を繰り返し、最後に残るアルファベットがひとつもしくは
すべて同じアルファベットであるなら、そのアルファベットは答えとなる。
・複数そのようなアルファベットがある際は、連結して昇順に並べたものを返す。
解き方 
・各アルファベットの出現回数を調べる。
・すべてのアルファベットに対し、そのアルファベットを除いたものすべてに対しペアを求め
あまりがそのアルファベット-1以上であれば答えを満たす。
・ペアの消し方については、昇順にソートし１番最後と２番目に最後を引いていきソートを繰り返す。
・サンプル通った。提出。
→System Failed.
・ペアの消し方がまずそう。１番最後と２番目に最後の文字を一つずつ引いていけば最適となる。
・システム通った。
・別解として、一番多く出現するアルファベットが過半数を超えなく、かつ合計が偶数であればすべて消すことができる。この方法は知っていたのに引き出せなかった。
・反省：計算量が間に合うのであれば一番確実な方法を採用する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class HappyLetterDiv1 {
public: string getHappyLetters(string letters) {
int n=letters.size();
int num[26];</description>
    </item>
    
    <item>
      <title>SRM 626 DIV1 Easy - FixedDiceGameDiv1 (×)</title>
      <link>https://chaingng.github.io/post/srm-626-div1-easy---fixeddicegamediv1-/</link>
      <pubDate>Wed, 05 Nov 2014 18:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-626-div1-easy---fixeddicegamediv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13239&amp;amp;rd=15859
・AliceとBobでゲームを行う。
・Aliceはa個b面あるサイコロを投げ、Bobはc個d面あるサイコロを投げる。
・b面あるサイコロは1～bの数字が書かれており、d面あるサイコロは1～dの数字が書かれている。
・Aliceが勝った時、出た目の期待値を求める。
・Aliceが勝つケースがないときは-1を返す。
解き方 
・まずAliceが勝つかどうか判定する。
・Bobの一番小さい数はcであるので、c+1以上の面が出るときに勝つことができる。
・次にAliceの勝つ面について、どれだけの確率があるか計算する。
・dpを用いればできそう。
・現在までに使ったサイコロの数、現在までの合計のスコアを持つdpを作れば
場合の数は計算できる。
・確率として、勝つ面が出た時のすべての場合の数の和を取り、最後に割ってあげる。
・サンプルはすべて通った。
→System Failed
・Aliceだけの面をみていたが、Bobの面も見る必要がある。
・つまり、Aliceの勝つ数についての場合の数＊Bobがそれに負けるときの場合の数を足してあげ、
その和を全てとり最後に割ってあげる必要がある。
・反省：確率の問題に弱い・・・。基礎が足りないのを実感。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class FixedDiceGameDiv1 {
public: double getExpectation(int a, int b, int c, int d) {</description>
    </item>
    
    <item>
      <title>SRM 625 DIV1 Easy - PalindromePermutations (×)</title>
      <link>https://chaingng.github.io/post/srm-625-div1-easy---palindromepermutations-/</link>
      <pubDate>Wed, 05 Nov 2014 10:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-625-div1-easy---palindromepermutations-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11856&amp;amp;rd=15858
・ある文字列が与えられる。
・この文字をシャッフルした時に、回文となる確率を求める。
解き方 
・まず与えられた文字列が回文となるかどうか判定する必要がある。
・すべてのアルファベットについて出現回数を調べる。
・このとき、すべてのアルファベットの出現回数が偶数回なら回文となる。
また、奇数回出現するアルファベットが１つだけなら回文となる。
それ以外は回文とならない。
・次に、回文となるときの確率を求める。

→System Failed
・まず奇数回出現するアルファベットがある場合、その中央にそのアルファベットを
置く必要がある。その確率はその出現回数／文字列長。
そこから出現回数と文字列長をデクリメントする。
・あとはすべてのアルファベットが偶数回の出現回数となる。
あるアルファベット２つ置く時、それが回文となるのはひとつアルファベットを置いたときに
一意に定まる。
よって、ひとつアルファベットを置かれたとき、そのあと残りのアルファベットを指定の場所に置く　ので(出現回数-1)/(L-1)となる。
&amp;nbsp; （例）
L(文字列長)=4 ,アルファベットaのcnt(出現回数)=2のとき
すべての並び：aaxx, axax, axxa, xaax, xaxa, xxaa
うち回文のもの：axxa, xaax
&amp;nbsp; つまり(cnt-1)/(L-1)となる。
・反省：確率の計算の基本が・・・。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i !</description>
    </item>
    
    <item>
      <title>SRM 624 DIV1 Easy - BuildingHeights (×)</title>
      <link>https://chaingng.github.io/post/srm-624-div1-easy---buildingheights-/</link>
      <pubDate>Tue, 04 Nov 2014 19:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-624-div1-easy---buildingheights-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13211&amp;amp;rd=15857
・様々な高さを持つ建物が与えられる。
・建物の高さを１変えるのにコストが１かかる。
・同じ建物がｍ個必ずあるようにしたい。
・建物の数をｎとしたとき、ｍは１～ｎすべての値としてそれぞれの最小コストのXORを求める。
解き方 
・ｍを１～ｎそれぞれについて調べることとし、各建物の長さについて答えを求める。
・求め方として２分探索？でも最小値を求めるので使えなさそう。
・全探索では4000*4000*4000かかりそう。
→他の人のコードをみてみる
・ｍを固定した時、どの長さにするかは各建物の元々の長さにすればよい、、ことを単純ながら見落としてしまった。
・あとは各建物の長さに固定した時のコスト計算をO(１)とするために、累積和をとっておけばよい。
・反省：最適解探索の検討がまだまだ足りない。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BuildingHeights {
public:
int minimum(vector&amp;lt;int&amp;gt; heights) {
int n=heights.size();
sort(all(heights));
int sum[n+1];
sum[0]=0;
FORE(i,1,n+1)sum[i]=sum[i-1]+heights[i-1];
int ret=0;</description>
    </item>
    
    <item>
      <title>2013 TCO Round 2B Easy - FruitTrees (×)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-2b-easy---fruittrees-/</link>
      <pubDate>Sun, 02 Nov 2014 22:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-2b-easy---fruittrees-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12520&amp;amp;rd=15633
・appleとkiwi、grapeがあり、それぞれ与えられた間隔で一定に置いていく。
・このとき、２つの果物間の最短距離が最も大きくなるような並べ方のときの
&amp;nbsp;最短距離を求める。
解き方 
・３つ果実があると複雑そう。
・appleの距離が４、kiwiの距離が３のとき、と考えるとどう置いても重なる・・うまく見つからない。
→他の人のコードをみてみる
・もう少し洞察してみると、２つの果実の距離のgcdのMODが最短距離となる。
・よって、appleを固定し、kiwiとgrapeを変化させそのときの最短距離を求めればよい。
・反省：紙に書いてもっと検討・試行錯誤してみることが必要。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class FruitTrees {
public:
int gcd(int x,int y){
return y ? gcd(y,x%y) : x;
}
int maxDist(int apple, int kiwi, int grape) {</description>
    </item>
    
    <item>
      <title>SRM 622 DIV1 Easy - BuildingRoutes ××○</title>
      <link>https://chaingng.github.io/post/srm-622-div1-easy---buildingroutes-/</link>
      <pubDate>Sun, 02 Nov 2014 21:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-622-div1-easy---buildingroutes-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13193&amp;amp;rd=15855
・有向グラフとエッジの距離が与えられる。
・ある点からある点に行くまでに通る最短の経路を考えるとき、
すべての点から点までの最短経路で通る数がT以上であれば、その経路の距離の和を求める。
解き方 ・最短距離といえばワーシャルフロイドだが、途中の経路を知る必要がある。
・それではダイクストラ？でも途中の経路を知るのは難しい・・・で断念。
→他の人のコードをみる
・ワーシャルフロイドを適用したあと、ある最短経路のうちあるエッジを通るかは、
そのエッジを含めた距離が最短経路と一致していればよい。
・反省：最短経路と途中の経路の関係を応用できるようにすべき。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BuildingRoutes {
public: int build(vector&amp;lt;string&amp;gt; dist, int T) {
int n=dist.size();
int d[n][n],cnt[n][n];
memset(cnt,0,sizeof(cnt));
FORE(i,0,n)FORE(j,0,n)d[i][j]=dist[i][j]-&#39;0&#39;;
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
FORE(i,0,n)FORE(j,0,n)if(i!=j){
FORE(k,0,n)FORE(l,0,n)if(k!=l &amp;amp;&amp;amp; d[i][k]+dist[k][l]-&#39;0&#39;+d[l][j]==d[i][j])cnt[k][l]++;</description>
    </item>
    
    <item>
      <title>SRM 623 DIV1 Easy - UniformBoard （○）</title>
      <link>https://chaingng.github.io/post/srm-623-div1-easy---uniformboard-/</link>
      <pubDate>Sun, 02 Nov 2014 10:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-623-div1-easy---uniformboard-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13209&amp;amp;rd=15856
・N×Nのボードが与えられる。
・ボードの各セルには空白、apple,pearいずれかが置かれている。
・また、１回の操作でappleかpearを空白に移すことができる。
・最大の操作回数はKで、任意の長方形の中のセルがすべてappleであるようなときの
最大の長方形の面積を求める。
解き方 
・すべての長方形で検索すればよさそう。
・長方形を作ったとき、そもそも全体のappleより大きいセルは作れないので
最初にすべてのappleの数を調べる必要がある。
・長方形を作ったときにpearが含まれているとき、空白が一つもないと移せないので
最初に空白があるかどうかを調べる必要がある。
・空白は１回の操作でappleを置くことができるが、pearは一回どかしてからappleを置く必要が
あるので２回の操作が必要。
・よって任意の長方形を考えた時、セルの数が全体のapple以下かつ、
pearもしくは空白が含まれていないか、空白の数＋pearの数×２＜＝Kかつ空白が全体に
存在するときはその長方形をすべてappleにできる。
→System Passed.
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class UniformBoard {
public: int getBoard(vector&amp;lt;string&amp;gt; board, int K) {</description>
    </item>
    
    <item>
      <title>2014 TCO Round 2C Easy - SubstringReversal (復習×)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-2c-easy---substringreversal-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Nov 2014 20:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-2c-easy---substringreversal-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12516&amp;amp;rd=16016
・ある文字列が与えられる。
・この文字列の２つの場所を選んで、その間の文字列を順番を逆にすることができる。
・順番を入れ替えた後最も辞書順に小さくすることのできる、入れ替える場所（ｘ、ｙ）を
求める。
・ただし同じ文字列が得られるときはｙが小さい方、さらにｙが小さい時はｘが小さい方の場所を
求める。
解き方 
・単純に入れ替えるｘを小さい方から見ていき、より小さくできる場所があればそこが
最適になりそう。
・入れ替える先に同じアルファベットが複数存在するときは、一番手前にあれば一番手前の
場所になるので最適。
→System Failed.
・選んだところの文字列をすべて逆順、という一番基本のところを軽くスルーしてしまった。
・入れ替える先に同じアルファベットが存在するときは、
入れ替えた後の文字列が小さいものを選ばなければいけない。
・入れ替えたアルファベットすべてに対して探索しても計算量は
2.5*10^3*(1250+2500)=2.5*10^3*3.7*10^3=10^7まではいかないので十分に間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SubstringReversal {
public: vector&amp;lt;int&amp;gt; solve(string S) {
int n=S.size();</description>
    </item>
    
    <item>
      <title>SRM 619 DIV1 Easy - SplitStoneGame (××)</title>
      <link>https://chaingng.github.io/post/srm-619-div1-easy---splitstonegame-/</link>
      <pubDate>Sat, 01 Nov 2014 09:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-619-div1-easy---splitstonegame-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13113&amp;amp;rd=15852
・積み重ねられた石の山が複数存在する。
・それぞれの山について、あらかじめいくつ石が積み重ねられているかわかっている。
・現在の石の山から１つ選んで２つに分け、また別の山を２つ選んで振り分ける。
・２つに分ける方法として、片方が０にならなければどのように分けてもよい。
・上記のゲームを2人で交互に行い、分けられなくなった場合は負けになる。
・このとき、最初のプレイヤーが勝つときはWIN,、負けるときはLOSEを返す。
解き方 
・サンプルと問題文からダメなパターンをみてみる。
・まず、石の山が２つ以下の場合は必ず負ける。
・また、全ての石の山が１のときは動かせないので必ず負ける。
・それ以外のときとして、山が３つの時は必ず２つにできるので勝つ。
・山が４つのときは必ず３つ→２つになるので負けてしまう。
・よって、最初が全て１でなければ山を一つずつ必ず減らすことができる。
・まとめると、石の山が２つ以下またはすべて１のときは負け、
そうでないときは山の数が奇数のときは勝ち、偶数のときは負ける。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SplitStoneGame {
public: string winOrLose(vector&amp;lt;int&amp;gt; number) {
int n=number.size();
int flag=1;
FORE(i,0,n)if(number[i]!=1)flag=0;</description>
    </item>
    
    <item>
      <title>Windowsのプロキシ</title>
      <link>https://chaingng.github.io/post/windows%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/</link>
      <pubDate>Fri, 31 Oct 2014 22:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/windows%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/</guid>
      <description>Windowsのプロキシには２種類存在する。
１つめはInternetExplorerのプロキシサーバー設定、もう一つは主にWindows Updateに使用されるWinhttpのプロキシ設定。
InternetExplorerはIEのインターネットオプションから設定できるが、
Winhttpはnetshコマンドにて設定する。
設定方法としては、直接設定するものとIEの設定をコピーする方法の２つ。
直接設定する方法
netsh winhttp set proxy proxy-server=&#34;myProxyServer:8080&#34; bypass-list=&#34;&amp;lt;local&amp;gt;;*.microsoft.com;*.foo.ne&#34;
IEの設定をコピーする方法
netsh winhttp import proxy source=ie
現在の設定は、以下のコマンドで確認できる。
netsh winhttp show proxy
また、以下のコマンドで設定をリセット（プロキシなしに）できる。
netsh winhttp reset proxy
WindowsUpdateは手動での更新時はIEの設定が利用されるが、
自動更新時はWinhttpのプロキシ設定が適用されるため、プロキシ環境下で自動更新を行いたいときは必要な設定となる。
（参考）公式ページ
http://support.microsoft.com/kb/2894304/ja
 </description>
    </item>
    
    <item>
      <title>SRM 620 DIV1 Easy - PairGame (××)</title>
      <link>https://chaingng.github.io/post/srm-620-div1-easy---pairgame-/</link>
      <pubDate>Fri, 31 Oct 2014 19:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-620-div1-easy---pairgame-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13142&amp;amp;rd=15853
・(x,y)のペアを考える。
・このペアは(x+y,y)もしくは（x,x+y）のペアに変換することができる。
・(a,b),(c,d)のペアが与えられたとき、どちらのペアも作ることのできるペア(x,y)のうち
もっともx+yが大きくなるときのx+yの値を求める。
解き方 
・全探索は難しそう。
・なにか法則を見つける必要がありそうだが。。
・サンプルをみたとき、(15,4)→(11,4)→(7,4)となるのでなにかありそうだが
&amp;nbsp;うまく見つからなく断念。
→他の人のコードをみてみる。
・サンプルから、(a,b)でa&amp;gt;=bのときは(a-b,b)から遷移しなく、
a&amp;lt;bのときは(a,b-a)からしか遷移しないことがわかる。
・よって、答えである(a,b),(c,d)をそれぞれ遷移させ、共通するもののうち
最大となるペアの和が答えになる。
反省：問題文からもっといろいろ紙に整理してみるのが足りていないと実感。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PairGame {
public: int maxSum(int a, int b, int c, int d) {
set&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p1,p2;</description>
    </item>
    
    <item>
      <title>makeの種類</title>
      <link>https://chaingng.github.io/post/make%E3%81%AE%E7%A8%AE%E9%A1%9E/</link>
      <pubDate>Fri, 31 Oct 2014 19:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/make%E3%81%AE%E7%A8%AE%E9%A1%9E/</guid>
      <description>makeにはいくつかの種類がある。
・GNU make
&amp;nbsp;gmakeとかいわれる。
&amp;nbsp;UNIX系で標準的に使われるもので、Windows系ではcygwinとかでも使われている。
・Microsoft Program Maintenance Utility
&amp;nbsp;nmakeともいわれる。
&amp;nbsp;Visual Studio C++などを使うときはこちらでmakeする必要あり。
・BSD make
&amp;nbsp;pmakeとも言われる。
&amp;nbsp;BSD系のUnixではこちらを使う必要がある。
そのため、利用する環境に応じてmakeする必要があるので注意。
 </description>
    </item>
    
    <item>
      <title>2011 TCO Qualification Round 2 - BlackWhiteMagic</title>
      <link>https://chaingng.github.io/post/2011-tco-qualification-round-2---blackwhitemagic/</link>
      <pubDate>Fri, 31 Oct 2014 18:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2011-tco-qualification-round-2---blackwhitemagic/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11418&amp;amp;rd=14530
・黒と白の石が並べられている配列が与えられる。
・その石をswapすることで、白白・・白黒黒・・黒としたい。
・ただし、swapできる距離１つごとに１回のswapしかできない。
・このとき、必要な最小の操作回数を求める。
解き方 
・swapの距離によらず、各１回の操作で白と黒を入れ替えることができそう。
・白と黒が分かれるようにswapする。
→system failed
・問題文を見落としてしまった。
・まず問題文は白→黒の順と決まっていることと、白と黒の数は任意であること。
・問題文をきちんと読んで条件を整理する基本を徹底せねば。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BlackWhiteMagic {
public: int count(string creatures) {
int n=creatures.size();
int w=0,ret=0;
FORE(i,0,n)if(creatures[i]==&#39;W&#39;)w++;
FORE(i,0,w)if(creatures[i]==&#39;B&#39;)ret++;
return ret;</description>
    </item>
    
    <item>
      <title>サービスの自動起動</title>
      <link>https://chaingng.github.io/post/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E8%87%AA%E5%8B%95%E8%B5%B7%E5%8B%95/</link>
      <pubDate>Thu, 30 Oct 2014 12:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E8%87%AA%E5%8B%95%E8%B5%B7%E5%8B%95/</guid>
      <description>chkconfigを使う。
ランレベル２～５での自動起動
chkconfig httpd on
起動レベルを指定（ランレベル３，５で起動）
chkconfig httpd on --level 35
自動起動しているサービス一覧の表示
chkconfig --list
ランレベルとはOSが起動するときのシステムの状態。
現在どのランレベルで起動しているか、以下のコマンドで知ることができる。
/sbin/runlevel
 </description>
    </item>
    
    <item>
      <title>2013 TCO Round 2A Easy - TheLargestString (××)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-2a-easy---thelargeststring-/</link>
      <pubDate>Thu, 30 Oct 2014 11:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-2a-easy---thelargeststring-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12494&amp;amp;rd=15594
・文字列sと、文字列tが与えられる。
・sとtは同じ長さ。
・好きな位置を選択し、そこから構成されるsとtのサブ文字列を作り、sとtを結合する。
・このとき、最も辞書順に大きくなるような結合後の文字列を求める。
解き方 
・一見、貪欲法で解けそう
・まずはsの大きくなる選び方で試してみる
・最後のサンプルがエラー。sの選び方に加え、選ばずにs+tの方が辞書順に大きくなる可能性が　あるため貪欲法では解けない。
・よってｄｐで解く必要がある。
・最初からｄｐを適用していくと、選び方を全探索しないといけないが、
後ろから適用していけば、現在の文字列をつなげるかどうかを判断すればよいので
計算量も間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheLargestString {
public: string find(string s, string t) {
int n=s.size();
pair&amp;lt;string,string&amp;gt; dp[60][60];
FORE(i,0,60)FORE(j,0,60)dp[i][j]=make_pair(&#34;&#34;,&#34;&#34;);</description>
    </item>
    
    <item>
      <title>2012 TCO Round 1A Easy - EllysJuice (×)</title>
      <link>https://chaingng.github.io/post/2012-tco-round-1a-easy---ellysjuice-/</link>
      <pubDate>Thu, 30 Oct 2014 11:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2012-tco-round-1a-easy---ellysjuice-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11843&amp;amp;rd=15090
・アップルジュースとオレンジジュースが１ガロンずつある。
・プレイヤーは順番に交互のジュースを半分ずつ飲んでいく。
・ここで、プレイヤーの集合が与えられる。ただし、実際に飲んだ順番はわかっていない。
・このとき、存在しうる一番ジュースを飲んだプレイヤーを求める。
・ただし、一番ジュースを飲んだ量が同じであるプレイヤーが複数存在した場合は
勝者は存在しない。
解き方 
・プレイヤー数は８なので、全探索ができそう。
・ただし、実装が若干大変。
・そこで問題文から、複数名前が存在するプレイヤー、もしくはプレイヤーの数が１人のとき
そのプレイヤーが勝者になることがわかる。
・これがわかれば、実装するだけ。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EllysJuice {
public: vector&amp;lt;string&amp;gt; getWinners(vector&amp;lt;string&amp;gt; players) {
int n=players.size();
int maxn=0;
map&amp;lt;string,int&amp;gt; m;
FORE(i,0,n){
m[players[i]]++;</description>
    </item>
    
    <item>
      <title>2010 TCO Qualification Round 2 -  JingleRingle</title>
      <link>https://chaingng.github.io/post/2010-tco-qualification-round-2----jingleringle/</link>
      <pubDate>Thu, 30 Oct 2014 09:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2010-tco-qualification-round-2----jingleringle/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10896&amp;amp;rd=14277
・１つの硬貨Jingleをある硬貨Ringleで売るsellerが複数人と、
１つの硬貨Jingleをある硬貨Ringleで買うbuyerが複数人いる。
また、buyerに売るときは売るときの硬貨floor(X*tax/100)の税金がかかる。
・１人のsellerからは１回、１人のbuyerからは１回の取引しかできないとき、
得られる最大のprofitを求める。
解き方 
・貪欲法で解くことができそう。
・ソートし、一番安いsellerと一番高く売れるbuyerについて税金も含めて利益が出るときは取引し、そうでないときは取引しなければよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class JingleRingle {
public: int profit(vector&amp;lt;int&amp;gt; buyOffers, vector&amp;lt;int&amp;gt; sellOffers, int tax) {
int n=buyOffers.size();
int m=sellOffers.size();
if(n==0||m==0)return 0;
sort(all(buyOffers));
sort(all(sellOffers));</description>
    </item>
    
    <item>
      <title>2012 TCO Round 1B Easy - FoxAndKgram (○)</title>
      <link>https://chaingng.github.io/post/2012-tco-round-1b-easy---foxandkgram-/</link>
      <pubDate>Wed, 29 Oct 2014 19:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2012-tco-round-1b-easy---foxandkgram-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11809&amp;amp;rd=15091
・複数の長さの棒が与えられ、ここからK-gramを作りたい。
・K-gramとはK個からなる集合で、
各要素は長さKの棒もしくは2つの棒を組み合わせて長さK-1のものとなる。
・与えられた棒から作ることのできるK-gramのうち、最も大きいKのものを求める。
解き方 
・棒の個数は最大５０個、長さも最大５０なので全探索ができそう。
・すべてのKに対してK-gramが作ることができるか判定すればよい。
・判定の方法としては、棒の長さでソートし１個の棒で成り立つものをカウント後、
それ以下の長さのペアを左側と右側双方から探索すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class FoxAndKgram {
public: int maxK(vector&amp;lt;int&amp;gt; len) {
int n=len.size();
sort(all(len));
int ret=0;
FORE(i,1,n+1){
int l=0,r=n-1,cnt=0;
while(r&amp;gt;=0 &amp;amp;&amp;amp; len[r]&amp;gt;=i){</description>
    </item>
    
    <item>
      <title>2011 TCO Qualification Round 1 - MinimumLiars</title>
      <link>https://chaingng.github.io/post/2011-tco-qualification-round-1---minimumliars/</link>
      <pubDate>Wed, 29 Oct 2014 18:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2011-tco-qualification-round-1---minimumliars/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11414&amp;amp;rd=14524
・複数の人が存在し、それぞれそのグループに何人以上嘘つきがいるかと言っているかの
&amp;nbsp;liarの値がわかっている。
・誰が嘘つきかはわからないが、矛盾しないように嘘つきが何人いるかを求める。
複数の可能性がある場合は、そのうち最小の人数を求める。
また、あらゆるケースで矛盾する場合は-1を返す。
解き方 
・liarの値は最大で100、人数の最大は50であるため全探索ができそう。
・よって嘘つきの人数を0～100人までと固定し、その時の嘘つきの数を数えて
一致するものが矛盾しないケースとなる。
そのうち、最小のものを返してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MinimumLiars {
public: int getMinimum(vector&amp;lt;int&amp;gt; claim) {
int n=claim.size();
int ret=1e+9;
FORE(i,0,101){
int tmp=0;
FORE(j,0,n)if(claim[j]&amp;gt;i)tmp++;
if(i==tmp)ret=min(ret,i);
}</description>
    </item>
    
    <item>
      <title>linuxで複数のファイルを結合</title>
      <link>https://chaingng.github.io/post/linux%E3%81%A7%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88/</link>
      <pubDate>Wed, 29 Oct 2014 18:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%A7%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88/</guid>
      <description>catコマンドを使う。
下記のコマンドで指定したディレクトリ以下の全てのファイルを結合し、
newfilename.txtにその結果を保存できる。
cat targetdir/* &amp;gt; newfilename.txt&amp;nbsp;
ちなみにmanコマンドは以下の通り。
Concatenate　filesなのでcatコマンド。
CAT(1) &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; User Commands &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CAT(1)
NAME
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;cat - concatenate files and print on the standard output
SYNOPSIS
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;cat [OPTION]... [FILE]...
DESCRIPTION
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Concatenate FILE(s), or standard input, to standard output.</description>
    </item>
    
    <item>
      <title>2010 TCO Qualification Round 1 - GirlsAndBoys</title>
      <link>https://chaingng.github.io/post/2010-tco-qualification-round-1---girlsandboys/</link>
      <pubDate>Wed, 29 Oct 2014 18:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2010-tco-qualification-round-1---girlsandboys/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7794&amp;amp;rd=14294
・男の子と女の子が並んでいる。
・このうち、男の子と女の子が隣に並んでいる並びをできるだけ少なくしたい。
・並びを変えるには、一回の操作で任意の２人を入れ替えることができる。
・このときの、最小の操作回数を求める。
解き方 
・最小の並べ方はBBBGGGもしくはGGGBBBとなる並べ方になる。
・よって、上の２つの並べ方のうち操作回数が小さいものが答えになる。
コード 
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class GirlsAndBoys {
public: int sortThem(string row) {
int INF=1e+8,n=row.size();
int cost=INF;
int tmpcost=0,pos=0;
for(int letter=0;letter&amp;lt;n;letter++){
if(row[letter]!=&#39;B&#39;)continue;
tmpcost+=abs(letter-pos);
pos++;
}
cost=min(cost,tmpcost);
tmpcost=0,pos=0;
for(int letter=0;letter&amp;lt;n;letter++){</description>
    </item>
    
    <item>
      <title>2014 TCO Round 2A Easy - SixteenBricks (×)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-2a-easy---sixteenbricks-/</link>
      <pubDate>Wed, 29 Oct 2014 18:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-2a-easy---sixteenbricks-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13110&amp;amp;rd=15996
・正方形に並べられた１６個のマスがある。
・各マスに、高さheightが分かっているタワーを置く。
・このとき、見えている表面積が最も高くなるようにタワーを置く時の面積を求める。
解き方 
・下側は見えないので無視してよさそう。
・上側は常に１６となる。
・あとはどう横に置くか。
→思いつかなかったため、他の人のコードをみてみる。
・サンプルの一つにあるように、互い違いに置くことで（#の場所）８つ分はheight×４を足す。
*#*#
&amp;nbsp; #*#*
&amp;nbsp; *#*#
&amp;nbsp; #*#*
・残りのうち、置く場所によって見えなくなる面の数が異なる。
0#2#
&amp;nbsp; #4#2
&amp;nbsp; 2#4#
&amp;nbsp; #2#0
・よってheightでソートし、大きいうちから8つはheight×4を足し、
小さい方から2つはheight×4を引き、次の4つはheight×2を引けばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SixteenBricks {</description>
    </item>
    
    <item>
      <title>2013 TCO Round 1B Easy - EllysPairs (○)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-1b-easy---ellyspairs-/</link>
      <pubDate>Wed, 29 Oct 2014 16:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-1b-easy---ellyspairs-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12450&amp;amp;rd=15580
・生徒が複数存在し、それぞれの生徒のknowledgeの値がわかっている。
・生徒が２人ずつのペアを作る。このとき、ペアのknowledgeは各生徒のknowledgeの和となる。
・各ペアのknowledgeの差をできるだけ小さくした時の、最小の差を求める。
解き方 
・小さいknowledgeであるほど大きいknowledgeと組み合わせるのが最適解。
・よってknowledgeの順にソートし、一番左と一番右をペア、といったように
順に組み合わせていき、ペアの最大と最小の差が答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EllysPairs {
public: int getDifference(vector&amp;lt;int&amp;gt; knowledge) {
int n=knowledge.size();
sort(all(knowledge));
int maxp=knowledge[0]+knowledge[n-1];
int minp=knowledge[0]+knowledge[n-1];
FORE(i,0,n/2){
maxp=max(maxp,knowledge[i]+knowledge[n-1-i]);
minp=min(minp,knowledge[i]+knowledge[n-1-i]);
}
return maxp-minp;</description>
    </item>
    
    <item>
      <title>2013 TCO Round 1A Easy - HouseBuilding (○)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-1a-easy---housebuilding-/</link>
      <pubDate>Wed, 29 Oct 2014 16:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-1a-easy---housebuilding-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12396&amp;amp;rd=15571
・与えられた長方形の地面を平らにしたい。
・地面はセルで区別されており、それぞれのセルの現在の高さがわかっている。
・高さを変化させるには、変化させた高さの分の労力がかかる。
・全てのセルの高さをそれぞれが高々１以下の差にしたいとき、
必要な最小の労力を求める。
解き方 
・高さは０～９の９通り。
・このうち、高さの差が高々１になる場合は、
ならした後の高さは（０，１）、（１，２）・・・（８，９）の８通り。
・よって、それぞれの高さにするときに必要な労力をそれぞれ求め、そのうち最小のものが
答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class HouseBuilding {
public: int getMinimum(vector&amp;lt;string&amp;gt; area) {
int ret=1e+9;
int h=area.size(),w=area[0].size();
FORE(i,0,9){
int tmp=0;
FORE(j,0,h)FORE(k,0,w){
tmp+=min(abs(area[j][k]-&#39;0&#39;-i),abs(area[j][k]-&#39;0&#39;-(i+1)));</description>
    </item>
    
    <item>
      <title>2013 TCO Round 2C Easy - DancingFoxes (×)</title>
      <link>https://chaingng.github.io/post/2013-tco-round-2c-easy---dancingfoxes-/</link>
      <pubDate>Wed, 29 Oct 2014 15:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2013-tco-round-2c-easy---dancingfoxes-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12548&amp;amp;rd=15656
・友達が複数存在し、互いに誰と誰が友達であるかがわかっている。
・パーティにて、ダンスが任意の回数行われる。ダンスは２人ペアで行われる。
・ペアとなれるのは友達同士か、もしくは共通の友達がいる必要がある。
・一度ダンスを行えば、そのペアは友達となる。
・このとき、０番目の人と１番目の人が友達になるまでに必要な
最小のダンス回数を求める。
解き方 
・最短経路を求める問題なので、ワーシャルフロイドが使えそう。
・サンプルを見ると、０と１との最短経路－１が答え？
・サンプルは通ったので提出。
→SystemFailed.
・問題文を良く見ると、毎回のダンスで複数の友達がペアになるので、
初期状態の距離だけでは答えは求まらない。
・具体的には「0-A-B-C-D-1」のときは１回のダンスで「0-B-C-1」となる。
・つまり、最初の距離dから(d+1)/3ずつ引いていき、１以下になるまでのダンス回数が
答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class DancingFoxes {
public: int minimalDays(vector&amp;lt;string&amp;gt; friendship) {
int n=friendship.size();
int d[n][n];</description>
    </item>
    
    <item>
      <title>2014 TCO Round 2B Easy - SwitchingGame (○)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-2b-easy---switchinggame-/</link>
      <pubDate>Tue, 28 Oct 2014 22:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-2b-easy---switchinggame-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13110&amp;amp;rd=15996
・ONとOFFができるスイッチが複数与えられる。
・最初は全てOFFの状態。
・複数スイッチの状態が与えられ、順番にその状態に変化させていく。
・スイッチの状態はON,OFF,？の３つであり、？はON/OFFどちらでもよい。
・スイッチの状態変化は、好きなだけ＋に変化させる動作が１動作、
好きなだけ－に変化させる動作が１動作、
状態を一緒に合わせたあとボタンを押すのに１動作かかる。
・このとき、必要な動作回数の最小値を求める。
解き方 
・前のスイッチの状態を持っておき、毎回変化数を記録しておけばよさそう。
・？については好きな状態でよい。
・つまり、そのあとに出てくるのが＋でプラスの動作が行われるのであれば＋にしてしまい、
逆に出てくるのが－でマイナスの動作が行われるのであれば－にしてしまうのが
最適な動作になる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SwitchingGame {
public: int timeToWin(vector&amp;lt;string&amp;gt; states) {
int m=states[0].size();
int n=states.size();
int ret=n;</description>
    </item>
    
    <item>
      <title>2014 TCO Round 1B Easy - SpamChecker (○)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-1b-easy---spamchecker-/</link>
      <pubDate>Tue, 28 Oct 2014 20:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-1b-easy---spamchecker-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13119&amp;amp;rd=15950
・与えられたe-mailがスパムかどうかチェックしたい。
・e-mailの各行のうち、スパムな文字列でないときは○、スパムなときは×であるという
情報が与えられる。
・○が現れたら○のときのスコアを足し、×のときは×のときのスコアを引く。
・最初のスコアは０であり１行目から順にスコアを計算していき、１度でもスコアが
マイナスになったらそのe-mailはスパムとなる。
・このとき、与えられたe-mailがスパムであるかどうかを求める。
解き方 
単純に実装するだけ。
スコアを順に計算して毎回マイナスかどうかを判定すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SpamChecker {
public: string spamCheck(string judgeLog, int good, int bad) {
int n=judgeLog.size();
int score=0;
FORE(i,0,n){
if(judgeLog[i]==&#39;o&#39;)score+=good;</description>
    </item>
    
    <item>
      <title>2014 TCO Round 1C Easy - Unique (○)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-1c-easy---unique-/</link>
      <pubDate>Tue, 28 Oct 2014 20:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-1c-easy---unique-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13067&amp;amp;rd=15958
・ある文字列が与えられる。
・そのうち、同じアルファベットは一度しか使わないようにしたい。
・同じアルファベットが出現する場合、最初のアルファベットのみ残すようにしたときに
最後に残る文字列を求める。
解き方 
単に実装するだけ。
アルファベットの出現回数を保持する配列を持っておき、
初めて出現するアルファベットのみ答えに足していけばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Unique {
public: string removeDuplicates(string S) {
string ret=&#34;&#34;;
int n=S.size();
int ch[26];
memset(ch,0,sizeof(ch));
FORE(i,0,n){
if(ch[S[i]-&#39;a&#39;]==0){
ret+=S[i];
ch[S[i]-&#39;a&#39;]++;
}</description>
    </item>
    
    <item>
      <title>2014 TCO Round 1A Easy - EllysSortingTrimmer (○)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-1a-easy---ellyssortingtrimmer-/</link>
      <pubDate>Tue, 28 Oct 2014 20:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-1a-easy---ellyssortingtrimmer-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12971&amp;amp;rd=15942
・ある文字列Sが与えられる。
・パラメータLが与えられ、Sから長さL分の文字列を選んで順番をひっくり返すことができる。
また、操作後選んだサブ文字列以降の文字列は消えてしまう。
（例）S=”ESPRIT”、L=3のとき
”ES[PRI]T”の選択後 ”ESIRP”
・操作は何回行ってもよいとき、得られる最も辞書順の小さい文字列を求める。
解き方 
・基本はSのうち辞書順に小さいアルファベットL個分。
・ただし、最初の文字は削除することができない。
・よって、ソートして最初からL-1個分のアルファベットと、Sの最初の文字をソートした
ものが答えになる。
・別解として全探索、つまり後ろからソートを繰り返して行き、最後に残ったものが答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EllysSortingTrimmer {
public: string getMin(string S, int L) {
int n=S.size();
char ch[n];
FORE(i,0,n)ch[i]=S[i];</description>
    </item>
    
    <item>
      <title>2014 TCO Round 3A Easy - BrightLamps (×)</title>
      <link>https://chaingng.github.io/post/2014-tco-round-3a-easy---brightlamps-/</link>
      <pubDate>Mon, 20 Oct 2014 20:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-3a-easy---brightlamps-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13343&amp;amp;rd=16050
・複数のランプがあり、現在ついているかどうかの情報が与えられる。
・各ランプについて、ついているときの明るさの値が与えられる。
・連続K個のランプの状態を変化させることができ、何回でも変化させてよいとき、得られる最大の明るさの値を求める。
解き方 
・ランプの数は２５００個のため、全探索は厳しい。
・ｄｐができないか考えてみるが、前の状態を持つことも難しいためできなさそう
他のコードを見てみる。
・状態を良く見てみると、あるランプからK個離れたランプは他のランプの状態を変化させずに
それぞれ反転することが可能。
・例えば、ABCDEというランプがありK＝４、A＝０、E＝０とする。
このとき、ABCDを反転し、BCDEを反転させることで他をかえずにA=1、E=1とすることができる。
・よって、K個ずつ離れた集合をそれぞれ考え、一番最適な反転を考える。
つまり、０の数が偶数個のときはすべて１にすることができ、奇数個の時は一番小さいものだけを
０にして残りを１にすることができる。
・ただし、状態によっては集合を奇数回反転した場合がよいことがある。
よって、すべて偶数回反転させる場合と、奇数回反転させるときのうち大きい値が答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BrightLamps {
public: int maxBrightness(string init, vector&amp;lt;int&amp;gt; a, int K) {</description>
    </item>
    
    <item>
      <title>数学Aの順列（１）</title>
      <link>https://chaingng.github.io/post/%E6%95%B0%E5%AD%A6a%E3%81%AE%E9%A0%86%E5%88%97%EF%BC%91/</link>
      <pubDate>Sat, 18 Oct 2014 21:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%95%B0%E5%AD%A6a%E3%81%AE%E9%A0%86%E5%88%97%EF%BC%91/</guid>
      <description>プログラムで場合の数の問題がしばしば出てくるので
数学の順列の問題の解き方整理。
（１）ある場合の数からある条件を含まない場合を求めたいときは
それぞれの場合の数をもとめて集合の排他を計算する。
（例）０，１，２，４を並べて４ケタの数をつくる　＝４！－３！
（２）a&amp;lt;b&amp;lt;c&amp;lt;dからa,b,c,dを選ぶ場合の数はC,組み合わせ順列に帰着できる。
逆にこの形に変換できれば組み合わせ順列の適用が可能。
（例）１～９の数字から重複を許して４回数字を選び、
その数字がa&amp;lt;b&amp;lt;c&amp;lt;dとなるようにする
（３）人を一列に並べるなど、人を扱う順列の場合は区別するのでPで計算する。
（例）男子５人、女子３人を一列に並べる
（４）隣り合う場合はそのパターンを一つとみなす、
隣り合わない場合はその他の要素の間に入れる
（例）AさんとBさんは隣り合う→「AB」を一人とみなす
（例）男子が隣り合わない→女子の間に入れる
（５）単純な順列計算ができないときは場合分けを行う。
かつ、その中で重複がないようにする。
（例）１～４の数字から重複を許して５回数字を選び５ケタの数字を作る。
このうち１２の並びとなる場合の数を求める。
 </description>
    </item>
    
    <item>
      <title>SRM 636 DIV1 Easy - ChocolateDividingEasy (×)</title>
      <link>https://chaingng.github.io/post/srm-636-div1-easy---chocolatedividingeasy-/</link>
      <pubDate>Sat, 18 Oct 2014 13:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-636-div1-easy---chocolatedividingeasy-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13497&amp;amp;rd=16079
１＊１のセルが組み合わされた長方形のチョコレートケーキがある。
各セルごとにおいしさの値が与えられる。
このケーキを横に２つ、縦に２つ切って９つにわける。
このとき、分けたかけらのうちの最小のおいしさの値が最大となる値を求める。
解き方 
・計算量の見積もりを誤ってしまった。
・縦に２つ、横に２つなので50C2*50C2＝1.5*10^6ぐらい。
・分けたときの各かけらの値を累積和の差として求めれば間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int b[100][100];
int f[100][100];
class ChocolateDividingEasy {
public: int findBest(vector&amp;lt;string&amp;gt; chocolate) {
int n=chocolate.size();
int m=chocolate[0].size();
FORE(i,1,n+1)FORE(j,1,m+1)b[i][j]=chocolate[i-1][j-1]-&#39;0&#39;;
FORE(i,0,n+1)FORE(j,0,m+1){
if(i==0||j==0)f[i][j]=0;
else{</description>
    </item>
    
    <item>
      <title>RISCとCISC</title>
      <link>https://chaingng.github.io/post/risc%E3%81%A8cisc/</link>
      <pubDate>Fri, 17 Oct 2014 23:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/risc%E3%81%A8cisc/</guid>
      <description>プロセッサを支える技術から、RISCとCISCについて整理。
RISC（Reduced Instruction Set Computer）は固定長の単純な命令を実行する方式のコンピュータ。
CISC(Complex Instruction Set Computer)は可変長で命令体型が複雑なコンピュータ。
RISCの命令は４バイト固定長。
メモリアクセスはロード命令、ストア命令という専用の命令を使う。
演算命令のオペランドはレジスタに限る。
CISCはレジスタでもメモリでもオペランドとして使用できる。
複雑な命令の処理はパイプライン処理は難しく、高機能の命令はコンパイラで有効に利用できない、等の問題点から固定長の命令を高速で実行できるプロセッサの方が高性能。
ARM等のプロセッサはRISC方式の命令アーキテクチャを使用している。
Intel、AMDのx86プロセッサはCISC命令をRISCのような内部命令に変換してパイプライン実行を行っている。 </description>
    </item>
    
    <item>
      <title>wgetをプロキシ経由で利用</title>
      <link>https://chaingng.github.io/post/wget%E3%82%92%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</link>
      <pubDate>Thu, 16 Oct 2014 20:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/wget%E3%82%92%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</guid>
      <description>/etc/wgetrcに、以下の設定を追加してあげればよい。
use_proxy = on
proxy_user = user
proxy_password = passwordhttps_proxy = http://proxy.yoyodyne.com:18023/http_proxy = http://proxy.yoyodyne.com:18023/ftp_proxy = http://proxy.yoyodyne.com:18023/
ちなみに、ユーザ名とパスワードの設定はwgetrc中に書いていないが、
&#34;info wget&#34;で以下のように書いてある。
&amp;nbsp; &amp;nbsp;You may specify your username and password either through the proxy
URL or through the command-line options. &amp;nbsp;Assuming that the company&#39;s
proxy is located at &#39;proxy.company.com&#39; at port 8001, a proxy URL
location containing authorization data might look like this:
&amp;nbsp; &amp;nbsp; &amp;nbsp;http://hniksic:mypassword@proxy.company.com:8001/
&amp;nbsp; &amp;nbsp;Alternatively, you may use the &#39;proxy-user&#39; and &#39;proxy-password&#39;</description>
    </item>
    
    <item>
      <title>cygwin&#43;mintty&#43;apt-cygのインストール</title>
      <link>https://chaingng.github.io/post/cygwinminttyapt-cyg%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Wed, 15 Oct 2014 22:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/cygwinminttyapt-cyg%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>windowsでlinuxコマンド等を使うためのcygwin+minttyのインストールメモ。
Cygwinのインストールまで
Cygwinのインストールのために以下からsetup.exeをダウンロードして実行。
https://www.cygwin.com/
ダウンロードサイトは「ftp://～.jp」のサイトを指定しないとものすごくインストールが遅くなるので
注意。
必要なパッケージとして、後述するapt-cygのインストールのために以下は追加しておく。
Search欄でパッケージ名を入力してチェックすればOK。
・wget
・bzip2
・git
・gawk
・tar
Cygwin+minttyのセットアップ
インストールが終わったらc\://binの下にmintty.exeが存在するので
Cygwinの起動は今後こちらから行う。
ショートカットを作成して、右クリック＞プロパティから以下の設定を行う。
・管理者で実行するにチェック
これを行わないと、bin以下のファイルのwrite権限がないなど困ってしまう。
・ショートカットのリンク先に以下を追加
これでPATHが通ったりhomeが/usr/binではなくwindowsのhomeとなる。
-i /Cygwin-Terminal.ico -
・minttyを起動し、Option&amp;gt;TransparencyをHighにすると見やすい
・minttyを起動し、Option&amp;gt;TextからLocaleja_JP、文字コードをUTF-8に設定
apt-cygのインストール
Cygwinで追加でパッケージをインストールしたい場合には、
インストール時に使ったsetup.exeを使うことになる。
これをlinuxのyumのようにCLIでパッケージの追加を行うことができるのがapt-cyg。
以下のコマンドを実行することでインスール完了。
$ wget&amp;nbsp;https://raw.githubusercontent.com/kou1okada/apt-cyg/master/apt-cyg
$ chmod +x apt-cyg
$ mv apt-cyg /usr/bin/$ apt-cyg -X install gnupg
毎回の更新確認を不要にするために、以下のエイリアスを設定すると使いやすくなる。
$ alias apt-cyg=&#39;apt-cyg -u &#39;
ちなみに、apt-cygはwgetを利用しているので
プロキシ設定されたネットワークでの利用するときはwgetのプロキシ設定が必要なことに注意。
 </description>
    </item>
    
    <item>
      <title>androidのコードリーディング</title>
      <link>https://chaingng.github.io/post/android%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/</link>
      <pubDate>Tue, 14 Oct 2014 21:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/</guid>
      <description>業務でandroidのソースコードを読まなければならなかったときに学んだ、
効率的なソースコードの読み方のメモ。
動的な解析と静的な解析
ソースコードの解析には、動的な解析と静的な解析がある。
動的な解析とはデバッガなどでプログラムを実行させながら流れを解析する方法で、
静的な解析とは実際のソースコードを読んでいく方法。
最初は動的な解析からはじめると効率的に読むことができる。
androidではlogcatと呼ばれるログ出力関数が用意されていて、
プログラムを実行するとソースコードに埋め込まれたログが出力される。
また、開発環境ではなく実際の端末で実行されたログであれば、
以下のadbコマンドでlogcatを取得することができる。
$adb logcat -v time &amp;gt; logcat.txt
ただこのlogcatには読みたいプログラム以外にも端末で動いているものの全ての
ログが出力されるので、grepなどで必要な箇所だけ切り出してあげると見やすくなる。
まとめると
まずはプログラムを動かしてみて、出力されるlogcatからそのログが出力されている
コードの箇所を探していって、流れを組み立てるとよい。
その後、組み立てられたクラスの流れができるので、そこから静的解析として
クラスごとにソースを読んでいけば大まかに内容をつかむことができる。 </description>
    </item>
    
    <item>
      <title>ボタンを押すとテキストが変わるandroidアプリ</title>
      <link>https://chaingng.github.io/post/%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E6%8A%BC%E3%81%99%E3%81%A8%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8C%E5%A4%89%E3%82%8F%E3%82%8Bandroid%E3%82%A2%E3%83%97%E3%83%AA/</link>
      <pubDate>Mon, 13 Oct 2014 22:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E6%8A%BC%E3%81%99%E3%81%A8%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8C%E5%A4%89%E3%82%8F%E3%82%8Bandroid%E3%82%A2%E3%83%97%E3%83%AA/</guid>
      <description>ドットインストールで学んだ、ボタンを押すとテキストが変わるサンプルアプリの
作り方を整理。
http://dotinstall.com/lessons/basic_android
部品にIDをつける
レイアウト画面から、ボタンをドラッグ＆ドロップして設置。
次に、テキストとボタンをダブルクリックして、IDをつける。
ここではテキストのIDはmyLabel、ボタンのIDはmyButtonとする。
部品のプロパティにメソッド名を紐づけ
今回はボタンを押したときの動作なので
右下のプロパティからonClickを選択し、クリックしたときに起動するメソッド名を入力。
ここではchangeLabelとする。
MyActivity.javaにメソッドを書く
先ほど名前をつけたchangeLabelメソッドをMyActivity.javaの中に書く。
今回は引数にViewクラスを設定。
ここでのLog.vはlogcatに出力されるメッセージ。
第一引数はタグ、第二引数が出力したいメッセージになる。
今回はテキストのビューを変更したいので、Viewクラスの拡張である
TextViewクラスを用い、
変えたいテキストのIDを持つビューを探す。
そしてそのビューに対し、クリック後のテキストをセットすればよい。
public class MyActivity extends Activity {
&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; protected void onCreate(Bundle savedInstanceState) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; super.onCreate(savedInstanceState);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; setContentView(R.layout.activity_my);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; public void changeLabel(View view){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Log.v(&#34;TEST&#34;,&#34;Clicked&#34;);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TextView tv = (TextView)findViewById(R.id.myLabel);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tv.</description>
    </item>
    
    <item>
      <title>SRM 634 DIV1 Easy - ShoppingSurveyDiv1 (×)</title>
      <link>https://chaingng.github.io/post/srm-634-div1-easy---shoppingsurveydiv1-/</link>
      <pubDate>Mon, 13 Oct 2014 13:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-634-div1-easy---shoppingsurveydiv1-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13455&amp;amp;rd=16077
・N人の客がいて、各商品を多くて１つ買うことができる。
・また、K種類以上の商品を買うBig Shopperがいる。
・商品iを買った人数s[i]がわかっているとき、Big Shopperは最低何人いるか求める。
解き方 
・問題文をミスリードしてしまった。
・貪欲法で、Big Shopperが０人から増やしていきその場合に条件が成立するか
確かめればよい。
・確かめ方は、Big Shopperが存在するとき
買う種類はK以上であればよいので全部の商品を買うことにする。
このとき、残った値が（N-Big Shopperの数）×（K-1）以下であればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ShoppingSurveyDiv1 {
public: int minValue(int N, int K, vector&amp;lt;int&amp;gt; s) {
int n=s.</description>
    </item>
    
    <item>
      <title>androidにおけるaction／Activity／レイアウト</title>
      <link>https://chaingng.github.io/post/android%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Bactionactivity%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88/</link>
      <pubDate>Sun, 12 Oct 2014 21:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Bactionactivity%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88/</guid>
      <description>ドットインストールで学んだ、androidアプリの基礎を整理。
http://dotinstall.com/lessons/basic_android
AndroidManifest.xml
app&amp;gt;src&amp;gt;mainの下にあるファイル。
activityタグにあるaction.MAINがアプリケーションが起動したときの最初のアクションとなる。
そして、action.MAINに紐づけられたアクティビティ「MyActivity」が起動する。
&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&amp;gt;
&amp;lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
&amp;nbsp; &amp;nbsp; package=&#34;com.example.takatomo.myapp01&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;lt;application
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:allowBackup=&#34;true&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:icon=&#34;@drawable/ic_launcher&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:label=&#34;@string/app_name&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:theme=&#34;@style/AppTheme&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;activity
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:name=&#34;.MyActivity&#34;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; android:label=&#34;@string/app_name&#34; &amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;intent-filter&amp;gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;action android:name=&#34;</description>
    </item>
    
    <item>
      <title>短縮URLの仕組み</title>
      <link>https://chaingng.github.io/post/%E7%9F%AD%E7%B8%AEurl%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/</link>
      <pubDate>Fri, 10 Oct 2014 22:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E7%9F%AD%E7%B8%AEurl%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/</guid>
      <description>整理用にメモ。
短縮URLでアクセスできる仕組みは、要はリダイレクトを利用しているだけ。
サンプルとして、こちらのページで短縮URLを作成してみる。
https://goo.gl/
まずhttp://www.yahoo.co.jp/を入力すると、
http://goo.gl/0wXWlPという短縮URLが作成される。
この短縮URLにアクセスすると、
つまりhttp://goo.gl/にある0wXWlPという名前のファイルにアクセスすることになる。
そして、このファイルにアクセスした場合は
http://www.yahoo.co.jp/にリダイレクトするという命令を以下のように.htaccessファイルに書いてあげればリダイレクトにより短縮URLによるアクセスが実現できる。
Redirect /0wXWP http://www.yahoo.co.jp/&amp;nbsp; </description>
    </item>
    
    <item>
      <title>地上デジタル放送を録画したメディアと再生方法</title>
      <link>https://chaingng.github.io/post/%E5%9C%B0%E4%B8%8A%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E6%94%BE%E9%80%81%E3%82%92%E9%8C%B2%E7%94%BB%E3%81%97%E3%81%9F%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E3%81%A8%E5%86%8D%E7%94%9F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 09 Oct 2014 18:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E5%9C%B0%E4%B8%8A%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E6%94%BE%E9%80%81%E3%82%92%E9%8C%B2%E7%94%BB%E3%81%97%E3%81%9F%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E3%81%A8%E5%86%8D%E7%94%9F%E6%96%B9%E6%B3%95/</guid>
      <description>DVD-VR
地上デジタル放送を家庭のDVDレコーダーで録画した時は「VRモード」となる。
これはDVD-VR(Video Recording Format)と呼ばれるDVDフォーラムが策定した
日本の家電メーカー独自のフォーマットとなる。
地上デジタル放送はコピー制御情報が付加されて放送されており、
コピー制御情報が付加された放送を録画するためには
CPRM(Content Protection for Recordable Media)に対応している必要がある。
録画するためにはCPRMに対応した録画モードが必要であり、DVDではDVD-VRモードしか
CPRMに対応していないためにこのフォーマットが使用される。
再生方法
DVD-VRモードで録画されたDVDをPCのレコーダーで視聴するには
CPRMに対応したレコーダーソフトウェアが必要だが、解除ライセンス料がかかるため
フリーソフトでは現在存在しない模様。
（win-dvdの試用期間であれば使えるかもしれないが）
ただ、CPRMがかかっていない放送であればvroファイルを直接メディアプレイヤーで
指定することで再生可能。

そうでない場合は、家庭にあるDVDレコーダーで再生が必要。 </description>
    </item>
    
    <item>
      <title>android studioのプロキシ設定</title>
      <link>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Wed, 08 Oct 2014 20:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E8%A8%AD%E5%AE%9A/</guid>
      <description>android studioのプロキシ設定のメモ。
HTTP Proxy
File&amp;gt;Setting&amp;gt;HTTP Proxyから
Manual Proxy Settingを選んで設定。
設定後、「Check Connection」ボタンで正しく設定されているか確認できる。
Gradle
Gradleを使用するとき、proxy設定が必要な場合は以下のエラーが出る。
Failed to refresh Gradle project &#39;dummy Application&#39;
Could not GET &#39;http://repo1.maven.org/maven2/com/android/tools/build/gradle/&#39;.
Received status code 407 from server:
Proxy Authentication Required ( Forefront TMG requires authorization to fulfill the request. Access to the Web Proxy filter is denied. )
Enable Gradle &#39;offline mode&#39; and sync project
この際、File&amp;gt;Setting&amp;gt;Gradleから
Global Gradle Settingsのオプションにて以下の設定が必要。
（dummyHost, dummyPort, dummyUser, dummyPasswordにそれぞれ必要な設定を入れる）
-Dhttp.proxyHost=dummyHost -Dhttp.proxyPort=dummyPort -Dhttp.proxyUser=dummyUser -Dhttp.proxyPassword=dummyPassword </description>
    </item>
    
    <item>
      <title>GigabitEthernet規格の簡単なまとめ</title>
      <link>https://chaingng.github.io/post/gigabitethernet%E8%A6%8F%E6%A0%BC%E3%81%AE%E7%B0%A1%E5%8D%98%E3%81%AA%E3%81%BE%E3%81%A8%E3%82%81/</link>
      <pubDate>Tue, 07 Oct 2014 21:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/gigabitethernet%E8%A6%8F%E6%A0%BC%E3%81%AE%E7%B0%A1%E5%8D%98%E3%81%AA%E3%81%BE%E3%81%A8%E3%82%81/</guid>
      <description>GigabitEthernet規格の簡単なまとめ。
GigabitEthernet系の規格
GigabitEthernet系の規格はIEEE802.3abとIEEE802.3zの２つがある。
IEEE802.3ab
IEEE802.3abはUTPケーブルに関するもので、
1000BASE-Tと1000BASE-TXがある。
1000BASE-Tは4対8線のケーブルのうち各対250Mbps×4=1Gbpsを実現する。
ハイブリッド回路によるエコーキャンセル処理を行うことで、１つの対で送受信の全二重通信を実現。
1000BASE-TXは4対8線のケーブルのうち2対を送信用、2対を受信用に利用。
各対500Mbps×2=1Gbpsを実現。
IEEE802.3z
IEEE802.3zは光ファイバーケーブルに関するもので、
1000BASE-SX、1000BASE-LX、1000BASE-CXがある。
1000BASE-SXはマルチモード光ファイバーを使用するので
波長850nm、最大伝送距離は550mとなる。
1000BASE-LXはマルチモード光ファイバーに加えてシングルモード光ファイバーも使用可能。
シングルモード光ファイバーの場合、波長1300nm、最大伝送距離は5kmとなる。

1000BASE-CXは同軸ケーブル（STP）を使用する。
 </description>
    </item>
    
    <item>
      <title>android studioのインストール</title>
      <link>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Mon, 06 Oct 2014 19:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/android-studio%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>android studioのインストールメモ。
まずはここから本体をダウンロード。
https://developer.android.com/sdk/installing/studio.html
後はこちらのページの内容に沿ってインストール。
https://developer.android.com/sdk/installing/index.html?pkg=studio
まずはandroid studioの起動にあたってはJDKとJAVA_HOMEのPATH設定が必要なのであらかじめ済ませておく。
インストール後、必要なsdkをインストールする。
Configure＞sdk managerと移動すればインストール可能。
このとき、管理者権限でandroid studioを起動していなければsdkのインストール時に
「Nothing was installed」とエラーが出てしまう。
そのときはandroid studioのアイコンを右クリック＞プロパティから
管理者権限で実行するをチェックする。
これで次回からは常に管理者権限で実行され、sdkのインストール時にもエラーは出なくなる。
必要なsdkパッケージは以下の通り。
＜メインパッケージ＞
・sdk tools
・sdk platform tools
・sdk build tools
＜androidのバージョンごと＞
・sdk platform
・intel系のsystem image（インテルのエミュレータを用いる場合）
＜extra＞
・android support repository
・android support library
・google usb driver
・intel x86 emulator（インテルのエミュレータを用いる場合） </description>
    </item>
    
    <item>
      <title>SRM 635 DIV1 Easy - SimilarRatingGraph (×)</title>
      <link>https://chaingng.github.io/post/srm-635-div1-easy---similarratinggraph-/</link>
      <pubDate>Sun, 05 Oct 2014 22:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-635-div1-easy---similarratinggraph-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13485&amp;amp;rd=16078
日付とその日付に行われたコンテストの後のレーティングが時系列で与えられる。
そのグラフのうち２つの似通ったサブグラフを探し、最大の長さのサブグラフを求める。
サブグラフは各点が連続していなければならない。
似通ったサブグラフ同士は、同じ長さで片方に係数をかけるもしくはスライドすると同一になるものを言う。
解き方 
問題文を正確に読めてなかったのが反省点。
・サンプルを見ると、同じ傾きのサブグラフを求めることになりそう。
・同じ傾きのサブグラフのうち、切片が異なるサブグラフの集合の有無で答えが異なりそう。
・上記の条件ではコードに落とし込むのが複雑そう
ここで解き方に困ってしまい、他の人のコードをみる。
コードをみてから問題文を改めてみると、似通ったグラフとは同じ長さでなければならないこと、さらに連続するという条件がわかれば簡単に求められる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SimilarRatingGraph {
public: double maxLength(vector&amp;lt;int&amp;gt; date, vector&amp;lt;int&amp;gt; rating) {
double ans=0;
int n=date.size();
FORE(a,0,n-1)FORE(b,0,n-1)if(a!=b){
double l=0;</description>
    </item>
    
    <item>
      <title>yumをローカルで使う場合のレポジトリ設定</title>
      <link>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88%E3%81%AE%E3%83%AC%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Sun, 05 Oct 2014 22:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88%E3%81%AE%E3%83%AC%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E8%A8%AD%E5%AE%9A/</guid>
      <description>最初にCDをマウントして、ローカルにデータをコピー。
mkdir -p /mnt/cdrom
mount /dev/cdrom /mnt/cdrom
mkdir /opt/redhat
cp -rp /mnt/cdrom/* /opt/redhat/
umount /mnt/cdrom
次に、必要なrpmパッケージをインストール。
rpm -ivh /opt/redhat/Packages/*.rpm
レポジトリを作成するディレクトリを指定。
createrepo /opt/redhat/
yum clean all
最後に、適当な名前（ここではfile.repo）でレポジトリを作成すれば完了。
vi /etc/yum.repos.d/file.repo
[rhel-redhat]
name = Red Hat Enterprise Linux $releasever - $basearch
baseurl=file:///opt/redhat
enabled=1
gpgcheck=0 </description>
    </item>
    
    <item>
      <title>JDKのインストール</title>
      <link>https://chaingng.github.io/post/jdk%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Sat, 04 Oct 2014 20:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/jdk%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>こちらのページから対応するOSのJDKをインストール。
http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html
あとは、JAVAHOMEのパスを設定するだけ。
 </description>
    </item>
    
    <item>
      <title>gitのインストール</title>
      <link>https://chaingng.github.io/post/git%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</link>
      <pubDate>Fri, 03 Oct 2014 21:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/git%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/</guid>
      <description>gitのインストールメモ。
GIT EXTENTIONがCUIもGUIも同時にインストールできるのでスグレモノ。
以下のURLのDownloadからmsiをダウンロード。
https://code.google.com/p/gitextensions/
・同梱ツールはMsysGITとKdiff3の両方ともインストール。
・Kdiff3は「GIT bash here」「GIT gui here」の両方を選択。
これでCUIライクな操作もGUI操作も可能になる。
・PATH環境変数は「Run Git from the Windows Command Prompt」を選択。
これでコマンドプロンプトからも操作可能になる。
・改行コードは「Checkout Windows-style, commit Unix-style endings」を選択。
これで通常はwindowsの改行コードに沿って、コミット時のみunixスタイルに変換してくれる。
・インストール後、デスクトップを右クリックしてGit Extentions&amp;gt;Settingsを選択。
グローバル設定を選択し、ユーザ名とメールアドレスを登録。
・lsの文字化けを防ぐにはデスクトップを右クリックして「GIT bash here」を選択し、
ホームディレクトリから「.bashrc」という名前のファイルを作成、以下のエイリアスを追加する。
alias ls=&#39;ls --show-control-chars&#39;
alias dir=&#39;ls --show-control-chars&#39;
・合わせてホームディレクトリから以下のコマンドを設定すれば完了。
git config --global core.quotepath off </description>
    </item>
    
    <item>
      <title>yumをローカルで使用する場合のエイリアス</title>
      <link>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AE%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9/</link>
      <pubDate>Thu, 02 Oct 2014 18:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/yum%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AE%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9/</guid>
      <description>yumをインターネット経由ではなくローカルで使用したい場合のエイリアス設定。
/etc/bashrcもしくは~/.bashrcについて、以下を設定してあげればよい。
(rhel-redhatはrepoの名前)
alias yum=&#39;yum --disablerepo=\* --enablerepo=rhel-redhat&#39;
 </description>
    </item>
    
    <item>
      <title>adbをWi-Fi経由で利用</title>
      <link>https://chaingng.github.io/post/adb%E3%82%92wi-fi%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</link>
      <pubDate>Wed, 01 Oct 2014 19:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/adb%E3%82%92wi-fi%E7%B5%8C%E7%94%B1%E3%81%A7%E5%88%A9%E7%94%A8/</guid>
      <description>端末が増えてくるとそれぞれusb接続してadbコマンドを打つと大変になった。
そこで、usbに接続しなくとも無線LAN経由にてadbを利用する方法があったので整理しておく。
１．下準備として、端末にusb接続してtcpポートを解放。
$adb tcpip 5555
２．usbを外して、adb connectにて端末のIPアドレス(ここでは仮に10.10.10.10)にアクセス。
このとき、操作元の端末と操作したい端末は同じWi-Fiネットワーク下にあること。
$adb kill-server
$adb connect 10.10.10.10:5555
これだけで無線LAN経由でadbコマンドを打つことが可能になる。
ちなみに、公式ページを下の方にも解説がある。
http://developer.android.com/tools/help/adb.html </description>
    </item>
    
    <item>
      <title>2014 TCO Round 3B - IntoTheMatrix</title>
      <link>https://chaingng.github.io/post/2014-tco-round-3b---intothematrix/</link>
      <pubDate>Sat, 20 Sep 2014 08:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/2014-tco-round-3b---intothematrix/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13066&amp;amp;rd=16058
N種類のピルがあり、どれがマジックピルかを判別したい。
判別するのに友人に協力してもらうことができ、マジックピルを飲んだ友人は消えてしまう。
協力してもらうターン数turnsが与えられた時、最低限必要な友人の数を求める。
解き方 
・問題文から、ターンと友人の数により判別できるピルの数を列挙してみる
・問題文の誘導からか、なんとなくはまってしまう。
・他の人のコードを読む
・要は、人数とターンにより表わされる状態数が判別できるピルの数
・例えば１ターンでA,Bがいるときは、{ABが残る}、{Aだけ残る}、{Bだけ残る}、{両方消える}の４通り
・友人の数を固定すると、１人のとき1ターンで２通り、２ターンで３通り・・・Tターンで（T+1）通り
・よって、友人の数を０から増やしていき、（T+1)＾友人の数がN以上となるところが答え
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class IntoTheMatrix {
public: int takePills(int turns, int N) {
int F=0;
long long x=1;
while(x&amp;lt;(long long)N){</description>
    </item>
    
    <item>
      <title>SRM 629 DIV1 Easy - RectangleCovering (×)</title>
      <link>https://chaingng.github.io/post/srm-629-div1-easy---rectanglecovering-/</link>
      <pubDate>Fri, 19 Sep 2014 15:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-629-div1-easy---rectanglecovering-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13344&amp;amp;rd=16060
長方形のホールがあり、縦と横の長さがわかっている。
また複数の長方形のボードが与えられ、それぞれのボードの縦と横の長さもわかっている。
ホールを覆うように複数のボードをつなげるとき、必要な最小のボードの数を求める。
ただし、ボードは重ねるようにしてつなげてもよいが、ホールにボードの角が覆われないようにする。
解き方 
・普通に考えるとかなりの場合の数がありそう。
・なにか制約がないか例をあげてみる。
・あるボードが使えるかどうかは、そのうち小さい１辺がボードのどちらか１辺よりも大きくないといけない。
・これで使えるボードが選別できそう。
・ただ、それでも色々なつなげ方がありそう。
・角が覆われないようにする条件を満たすためには、ボードは縦一列、横一列のどちらかしか並べられない。
・これであとは上記を満たす長さのうち降順に並べればよさそう。
・System Failed
・ホールについて、縦に並べるか横に並べるか、両方の場合の検討が必要だった
・さらにボードについて、例外条件を見落としていた。
ボードの縦横両方が１辺よりも大きければ大きい方を取る。
そうでないとき、小さい方の辺が1辺より小さければ大きい方ととる。
そのうえでつなげる方の辺以上の長さになればよい。
・System　Passed
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class RectangleCovering {
public:
int minimumNumber(int holeH, int holeW, vector&amp;lt;int&amp;gt; boardH, vector&amp;lt;int&amp;gt; boardW) {</description>
    </item>
    
    <item>
      <title>SRM 630 DIV1 Easy - Egalitarianism3 (××)</title>
      <link>https://chaingng.github.io/post/srm-630-div1-easy---egalitarianism3-/</link>
      <pubDate>Fri, 19 Sep 2014 12:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-630-div1-easy---egalitarianism3-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13284&amp;amp;rd=16061
エッジのコストがわかっている、無向グラフが与えられる。
このとき、ノード間のコストが全て等しいサブグラフのうち、最も多いノード数を求める。
解き方 
・エッジの数＝ノード数N-1
・ノードA－ノードB－ノードCを考えた時、ノードA-ノードCとなるペアは存在しない。
・同じ距離の集合を考えた時、必ずハブとなるノードBが存在する。
・全てのノードをハブと考えた時、ノードA-ノードBの距離をｄとすると
ノードA-ノードCの距離が２ｄとなる集合のうち最大のものを求めればよい
・ｎ＝１のときの答えは１
・ｎ＝２のときの答えは２
・ｎ＞＝２のとき答えは必ず２以上となる
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Egalitarianism3 {
public: int maxCities(int n, vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, vector&amp;lt;int&amp;gt; len) {
if(n&amp;lt;=2)return n;
int g[n][n];</description>
    </item>
    
    <item>
      <title>SRM 631 DIV1 Easy - TaroJiroGrid (復習×)</title>
      <link>https://chaingng.github.io/post/srm-631-div1-easy---tarojirogrid-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 19 Sep 2014 11:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-631-div1-easy---tarojirogrid-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13393&amp;amp;rd=16062
N*Nのボードがあり、WかBの色が塗られている。
１回の操作で１つの行の色をWかB一色にすることができる。
このとき、全ての列について、同じ色がN/2より多く連続しないようにするための
最小の操作回数を求める。
解き方 
同じ色がN/2より多く連続しない、というのがポイント。
最悪のケースでは、N/2行とN/2+1行を別の色にすれば条件を満たすのでよいので２回で済む。
よって、操作回数０回と１回の場合を全探索すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TaroJiroGrid {
public:
bool check(vector&amp;lt;string&amp;gt; g){
int n=g.size();
FORE(j,0,n){
char prev=g[0][j];
int cnt=1;
FORE(i,1,n){
if(g[i][j]==prev)cnt++;
else{
if(cnt&amp;gt;n/2)return false;
prev=g[i][j];</description>
    </item>
    
    <item>
      <title>SRM 632 DIV1 Easy - PotentialArithmeticSequence (×)</title>
      <link>https://chaingng.github.io/post/srm-632-div1-easy---potentialarithmeticsequence-/</link>
      <pubDate>Fri, 19 Sep 2014 10:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-632-div1-easy---potentialarithmeticsequence-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13389&amp;amp;rd=16075
数字の数列があり、その数字を２進数にしたときの末尾の０の数のリストが与えられる。
このとき、与えられた数列のうち１ずつ増加するサブ数列の数を求める。
解き方 
数列に法則がないか列挙してみる。
すると、以下のように再帰の法則があるとわかる。
１が現れるとき：０１０
２が現れるとき：０１０２０１０
３が現れるとき：０１０２０１０３０１０２０１０
よって、与えられた数列の全てのサブ数列に対し、以下の法則が成り立つか
再帰を用いてチェックすればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PotentialArithmeticSequence {
public:
bool can(vector&amp;lt;int&amp;gt; d){
if(d.size()==1)return true;
int p= d[0]==0 ? 0 : 1;
int n=d.size();</description>
    </item>
    
    <item>
      <title>SRM 585 DIV1 Middle - LISNumber （復習x）</title>
      <link>https://chaingng.github.io/post/srm-585-div1-middle---lisnumber-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Wed, 04 Jun 2014 08:07:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-585-div1-middle---lisnumber-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
０からiまでの数字のカードが与えられる。
各数字のカードは、cardsnum[i]枚だけ与えられる。
このとき、カードを並べた時に左からみて増加列になっているサブ集合がＫだけ存在するようにしたい。
サブ集合がＫとなるときの場合の数を求める。
解き方 
いくつか例を出して考えてみる。
あるカードが並べられているとき、増加列が増えないときはその数字より小さいところに
カードを加えたときになる。
つまりカードの大きさを小さい順に走査したとき、増加列の数Ｌだけ、増加列が増えない置き方が存在する。
現在のカードの枚数をＸとすると、組み合わせでＬ（Ｃ）Ｘ通りの置き方が存在する。
このうちＫ枚だけ増加列が増えないように置くとすると、Ｌ（Ｃ)Ｋとなる。
また増加列が増えるときは、現在置かれているカード枚数をＳＵＭとしたとき、置き方はＳＵＭ＋１通り、
そこから上記の置き方を引くとＳＵＭ+1－（Ｌ－Ｘ）通りとなる。
こちらは重複組み合わせになるので、ＳＵＭ＋１－（Ｌ－Ｘ）（Ｈ）（Ｘ－Ｋ）通りとなる。
上記をｄｐにて実装する。
また、重複組み合わせはpCq=p+q-1Cqに変換でき、
組み合わせも以下の式よりｄｐで求めることができる。
xCy=x-1Cy-1+x-1Cy
例えば5C3のとき、5枚から3枚を選ぶ組み合わせになる。
4C3は4枚から3枚選ぶ組み合わせになり、
さらに残りで選ばれていない1枚＋4枚から2枚選ぶ組み合わせの合計に分解できる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int MOD=1000000007;
int dp[40][1300];
long long C[1300][1300];
class LISNumber {</description>
    </item>
    
    <item>
      <title>SRM 605 DIV1 Middle - AlienAndSetDiv1 （復習○）</title>
      <link>https://chaingng.github.io/post/srm-605-div1-middle---alienandsetdiv1-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 02 Jun 2014 07:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-605-div1-middle---alienandsetdiv1-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
1から2Nまでの数字を、２つの集合に分けたい。
各集合にはＮ個の数字が入るようにし、それぞれ昇順でi番目の数字の差がＫ－１以下になるようにしたい。
このとき、何通りの集合の分け方があるか求める。
解き方 
TopCoder SRM 605 Div1 Medium AlienAndSetDiv1を参考にさせていただきました。
全ての数字がＡに使ったかＢに使ったか保存することはできないが、小さい順に処理をしていくということ、さらにその場合に現在の数からＫ－１まで小さい数までの情報を持っていればよい。
Ｋは最大１０なので情報を持つことができる。
あとはＤＦＳにして問題を解く。
ｄｐの状態として「いままで選んだＡの数」「いままで選んだＢの数」「Ｋ－１まででＡを選んだ数」を持ち、値は場合の数とする。
ＡはＮを超えた際に０を返すようにしてＡは無条件に足していく。
Ｂは直前のＫ－１がＡである数が今まで選んだＡ－Ｂ個以上だと差がＫ以上になってしまうので、
この条件を満たさないときにＢを足していけばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int N,K,mask;
int dp[60][60][(1&amp;lt;&amp;lt;10)+1];
class AlienAndSetDiv1 {
public:
int rec(int x,int y,int bits){</description>
    </item>
    
    <item>
      <title>SRM 606 DIV1 Middle - EllysPairing （復習○）</title>
      <link>https://chaingng.github.io/post/srm-606-div1-middle---ellyspairing-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 02 Jun 2014 07:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-606-div1-middle---ellyspairing-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 ペアプログラミングのコンテストを開催する。
各大学から複数の参加者がおり、２人組みのペアを作る。
ペアを作るにあたってどの大学のペアかは関係ないが、同じ名前のもの同士がペアを組まないようにしたい。
各大学iについて、参加者がcount[i]、一人目の名前がfirst[i]、
二人目以降の名前は(first[i]+mult[i]+add[i])%Mとなる。
このとき、最大となるペア数を求める。
解き方 
名前の数は10^9となり配列に保存できない。
参加者数は5*10^7となりこちらも配列に保存できないので、メモリを確保できない。
そのため、うまくメモリを使う方法を考える必要がある。
今回、同じ名前が過半数を超えなければ、参加者数／２がペア数になることがわかる。
そのため、過半数となる名前が存在するかどうかを判定するとよい。
過半数となる人が存在する可能性があるかどうかを判定するアルゴリズムは、ボイヤー・ムーア法を参考にさせていただきました。
一度回しただけではその人が過半数となる可能性があるだけで必ず過半数をとっているわけではないので、一度判定し、その後数を数えて確かめる必要がある。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EllysPairing {
public: int getMax(int M, vector&amp;lt;int&amp;gt; count, vector&amp;lt;int&amp;gt; first, vector&amp;lt;int&amp;gt; mult, vector&amp;lt;int&amp;gt; add) {</description>
    </item>
    
    <item>
      <title>SRM 608 DIV1 Middle - BigO （復習x）</title>
      <link>https://chaingng.github.io/post/srm-608-div1-middle---bigo-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sat, 31 May 2014 13:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-608-div1-middle---bigo-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
有向グラフが与えられる。
このうち、巨大な経路長Ｌを考え、そのＬの場合の数がＯ（Ｌ＾Ｋ）となるかを知りたい。
Ｏ（Ｌ＾Ｋ）となるときはＫを、そうでないときは-1を返す。
解き方 
ある閉路に対して途中で分岐があるのであれば、経路長は２＾Ｌに増え続けるため-1となる。
逆に、そうでない閉路が存在すれば答えは存在する。
ただし、閉路でない場合はＬが巨大になりえないので、答えは０となる。
ある閉路からある閉路まで移動することができるとき、
最初の閉路でＬのうちいくつかの道を作り、次の経路で残りの数を選べるのでＬ＾１となる。
つまり、閉路間の最大距離がＫとなることがわかる。
同じ閉路に属するノードはＵＮＩＯＮ－ＦＩＮＤ木を用いて同じ集合とし、最後にＵＮＩON同士の最大距離を求めればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int un=1000;
int urank[1000],uparent[1000];
int d[60][60],d2[60][60];
class BigO {
public:
void union_init(){
FORE(i,0,un){
uparent[i]=i;
urank[i]=0;
}
}
int union_find(int x){</description>
    </item>
    
    <item>
      <title>SRM 611 DIV1 Middle - Egalitarianism2 （復習x）</title>
      <link>https://chaingng.github.io/post/srm-611-div1-middle---egalitarianism2-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sat, 31 May 2014 10:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-611-div1-middle---egalitarianism2-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
Ｎ個の都市があり、すべての都市についてある都市からある都市までいけるようにしたい。
ただし、そのために引くエッジの距離はできるだけ差がないようにしたく、その標準偏差を最小になるようにしたい。
このとき、最小となる標準偏差を求める。
解き方 
標準偏差は全ての辺のコストの平均をave、一つの辺のコストをAiとすると、
sqrt( Σ(ave-Ai)^2 /(N-1))で求められる。
このとき、aveの値によってどの辺を用いたらよいかの優先度が変化する。
そのため、すべての考えられる優先度に対して標準偏差を計算し、そのうちの最小となるものを求めればよい。
それでは、すべての考えられる優先度を考える。
このとき、２辺間の優先度はその平均に対して大小があるときに変化する。
そのため、aveをすべての２辺間の平均＋αに仮に設定し、そのときの標準偏差をすべて求めればよい。
このとき優先度が決定したときのグラフの作成は最小全域木を求めることと等しい。
よって、プリム法を適用して最小全域木を求める。
最後に、標準偏差は計算にあたって以下のように変形する。
sqrt( Σ(ave-Ai)^2 /(N-1))
=sqrt( Σ(ave^2) -2*Σ(Ai)*ave+Σ(Ai)^2 /(N-1))
=sqrt( (n-1)ave^2-2*Σ(Ai)*ave+Σ(Ai)^2/(N-1))
数列の和の公式でΣの変数にかからない項は項数の積となる。
コード 
double d[30][30],d2[30][30];
int n;
class Egalitarianism2 {
public:
void prim(double m,double &amp;amp;sum,long long &amp;amp;sum2){
int used[n],prev[n];
double mind[n];
FORE(i,0,n)mind[i]=1e+18;
memset(used,0,sizeof(used));
used[0]=1;
FORE(i,0,n){
mind[i]=fabs(d[0][i]-m);
prev[i]=0;
}
FORE(t,1,n){
double cost=1e+18;
int add=-1;
FORE(i,0,n){
if(!used[i]&amp;amp;&amp;amp;cost&amp;gt;mind[i]){
cost=mind[i];
add=i;
}
}
sum+=d[prev[add]][add];
sum2+=d2[prev[add]][add];
used[add]=1;</description>
    </item>
    
    <item>
      <title>SRM 609 DIV1 Middle - PackingBallsDiv1 （復習○）</title>
      <link>https://chaingng.github.io/post/srm-609-div1-middle---packingballsdiv1-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 31 May 2014 07:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-609-div1-middle---packingballsdiv1-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
Ｋ種類のボールがそれぞれX[i]個存在する。
各X[i]は、あらかじめ与えられるA,B,C,Dを用いて以下の式で求められる。
X[0]=A;
X[i]=(X[i-1]*B+C)%D+1
ここで、全てのボールをできるだけ少ない箱にまとめたい。
それぞれの箱は最大Ｋ個のボールが入り、１つの箱に入っているボールはすべて同じ色か、すべて異なる色でなくてはならない。
このとき、できるだけ少ない箱にまとめたときの箱の個数を求める。
解き方 
X[i]はlong long型を用いることで容易に求めることができる。
箱の詰め方だが、各色のボールは10^9のため単純なｄｐでは解くことができない。
そこで詰め方に対して貪欲法で解くことができないか考える。
各色に対してＫ個以上のボールがある際には、Ｋ個未満になるまで同じ色のボールを詰めた方がよいのではないかと考える。
反例について考えてみる。
反例は、各色に対してＫ個以上のボールがあるとき、すべて異なる色で詰める方がよいとする。
このとき色の数がｘ＜Ｋであるとき、各箱の個数はｘ個、つまりＫ個未満である。
このときはｘ種類それぞれに対してＫ個のボールをつめると箱の数はｘ個、つまりＫ個未満になりよりい解があるので成り立たない。
よって、Ｋ個以上のボールがあるときには同色で詰めた方がよい。
上記の処理を行うことで各色に残っている数はＫ個未満になるため、あとは全探索を用いてあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PackingBallsDiv1 {
public: int minPacks(int K, int A, int B, int C, int D) {</description>
    </item>
    
    <item>
      <title>SRM 613 DIV1 Middle - RandomGCD (復習x)</title>
      <link>https://chaingng.github.io/post/srm-613-div1-middle---randomgcd-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Thu, 29 May 2014 22:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-613-div1-middle---randomgcd-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
lowからhighまでの数字のうち、最大公約数がKとなるようにN個の数字の集合を作る。
このとき、同じ数字を何回選んでもよい。
このとき、数字の選び方が何通りあるか求める。
解き方 
最大公約数がＫということは、lowからhighまでのうちKの倍数であるものだけを考えたらよい。
そしてそのうち、それぞれが約数を持たないような全ての場合の数を求めればよい。
このときの効率的な求め方が思い浮かばなくEditorialを読む。
Ｋの倍数だけを考えたらよいということは、lowからhighまでの数字をKで割ったものについて考えれば単純化できる。
さらにその中でｄｐを利用することで約数を持たないような数を求めることができる。
最初にＫで割ったときにlowが１となったときは、すべて１を選んだときの場合の数１通りを足すことに注意。
ＭＯＤを使う際は、ＭＯＤする前にオーバーフローすることがあるのでlong long型に変換する。
オーバーフローしないよう、毎回の計算をＭＯＤすることにも注意。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[100010];
int MOD=1000000007;
class RandomGCD {
public:
int f(int a,int b){
int ret=1,cur=a;
while(b){
if(b&amp;amp;1)ret=(long long)ret*cur%MOD;</description>
    </item>
    
    <item>
      <title>SRM 615 DIV1 Middle - LongLongTripDiv1　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-615-div1-middle---longlongtripdiv1%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 29 May 2014 08:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-615-div1-middle---longlongtripdiv1%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
Ｎ個の都市が存在する。
ある都市A[i]とB[i]を結ぶコストD[i]があらかじめわかっている。
このとき、都市0から都市N-1までちょうどコストTで移動できれば&#34;Possible&#34;、移動できなければ&#34;Impossible&#34;を返す。
解き方 
D[i]は最大10000、Tは10^18のため単純な全探索はできない。
都市0からN-1まではどの経路を重複してもよいので、それぞれの場合を求めなければいけない。
このあたりで引っかかってしまったのでEditorialを読む。
ｄｐとしてTはそのまま扱えないが、０から直接つながる経路は最初に何回往復してもよいので、
その経路の往復分の距離ｄを考える。
ここで各都市について「都市番号」、「現在までのコスト%d」の状態を持つｄｐを考えることができる。
ここでｄｐの値はトータルのコストとなる。
最後に、dp[n-1][T%d]の値がＴ以下であれば、
都市Ｎ－１にＴ％ｄのコストで到達できることがわかるので、
ｄを足りない分だけ最初に往復すればちょうどＴで到達できるかを判定できる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
long long dist[60][20001];
class LongLongTripDiv1 {
public: string isAble(int N, vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B, vector&amp;lt;int&amp;gt; D, long long T) {</description>
    </item>
    
    <item>
      <title>SRM 616 DIV1 Middle - ColorfulCoins　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-616-div1-middle---colorfulcoins%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 25 May 2014 19:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-616-div1-middle---colorfulcoins%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
硬貨が複数種類存在し、１枚当たりの価値value[i]があらかじめわかっている。
それぞれの硬貨は異なる色をしている。
またＡＴＭが存在し、好きな回数だけ好きな金額を引き出すことができる。
引きだされる金額は、もっとも硬貨が少ないように引きだされる。
このとき、すべての硬貨の色の価値を判定するために必要な最小の引き出し回数を求める。
考えたこと
サンプルより１度に引き出せないときは、ある硬貨の価値の半分の硬貨があり、かつ倍の価値の硬貨があるときに存在しそう。
また各硬貨について他の硬貨にならないように一度に引き出せる枚数は、その次の硬貨の価値から割りだせそう。
では１度の引き出しについて枚数が異なるように選び、その組み合わせの最大化で解けるか。
サンプルと照らし合わせると合わないので、もっと最小となる考え方がありそう。
ここでEditorialを読む。
基本的には、２進数で表せる数とビット数の関係を用いる。
全てのコインが２枚まで引き出せると、２回の判定で９通りまで判定できる。
（例）引き出されたコインの枚数
１回目：０　０　０　１　１　１　２　２　２
２回目：０　１　２　０　１　２　０　１　２
ただしすべてのコインが2回引き出せなくとも、１枚まで引き出せるコインが４枚までなら
上記の判定に含むことができる。
４枚というのは、２回の引き出しにおける０と１の組み合わせ数。
つまり引き出す回数がｎ回とすると、各コインの引き出せる最大の数ｘのコインがx^2までで
あればよい。
ただしExampleから、どのコインも少なくても１回は引き出さないといけない。
これは引き出せる最大のコインの枚数でソートすると何枚目かの情報もわかるので、
各配列のi番目にある最大数xのコインについて x^2&amp;gt;=i+2であるような最小のnを求めればよい。
最後に、long longの割り算でint型に代入しようとするとintを超える、またはマイナスになるケースがあるので同じ型で取り扱う必要がある。
コード 
class ColorfulCoins {
public: int minQueries(vector&amp;lt;long long&amp;gt; values) {
vector&amp;lt;long long&amp;gt; num;
int n=values.size();
FORE(i,0,n-1)num.push_back( min(100LL,(long long)(values[i+1]/values[i])) );
sort(all(num));
FORE(count,1,7){
int ok=1;
FORE(i,0,num.size()){</description>
    </item>
    
    <item>
      <title>SRM 618 DIV1 Middle - LongWordsDiv1 (復習x)</title>
      <link>https://chaingng.github.io/post/srm-618-div1-middle---longwordsdiv1-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Fri, 23 May 2014 13:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-618-div1-middle---longwordsdiv1-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
ｎ種類の文字が与えられる。
これを、以下の条件にあてはまらないようにできるだけ長い文字列を作成する。
（１）同じ文字が２つ連続しないこと
（２）ｘｙｘｙとなるような部分文字列が存在しないこと
このとき、最長の文字列は何通りあるか求める。
解き方 
文字列に法則がないか考える。
今回は最長の文字数は、以下のパターンになるので2n-1であることがわかる。
（１）aXYZYXa
aは一つのアルファベット、XYZYXはaを除いたアルファベットの種類数n-1における最長の文字列 (n-1)+(n-2)=2n-3
（２）aMNaXYa　aは一つのアルファベット、MN、XYはaを除いた、お互いに同じアルファベットを含まない種類数
&amp;nbsp; &amp;nbsp; で構成される。MNに含まれる種類をＰ,ＸＹに含まれる種類をQとすると
MNの長さは2P-1,XYの長さは2Q-1, P+Q=n-1から
2P-1+2Q-1=2(P+Q)-2=2(n-1)-2=2x-4
&amp;nbsp; &amp;nbsp; よって全体の長さは2n-1となる。
上記について長さが1のときからnの時までdpで回してあげ、
最後にアルファベットの種類数分だけの順列が生じるのでn!をかけてあげればよい。
最初は最長の文字列が一意に決まると考え着かなかったので、もっと問題を洞察する必要があった。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
long long dp[5010];
int MOD=1000000007;</description>
    </item>
    
    <item>
      <title>SRM 430 DIV1 Middle - TwinTowns （復習x）</title>
      <link>https://chaingng.github.io/post/srm-430-div1-middle---twintowns-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Tue, 20 May 2014 21:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-430-div1-middle---twintowns-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
複数の（ｘ、ｙ）で表わされる点が与えられる。
各点について、maxPartners以下の次数で結びたい。
また、各点について結ぶ時はminDistance以上の距離がないといけない。
２点間の距離は|x1-x2|+|y1-y2|で表わされる。
このとき、できるだけ多くの点で結びたいときの最終的な結ばれた数と、そのときの最小となる距離の合計を求める。
解き方 
点の数は最大１０とのことで、なんとなくビットｄｐが利用できそう。
ただしmaxPartnersは３以下とのことなので単純なビットではいけない。
今回、各点ｄｘの値を次数とした、ｆ（ｄ１、ｄ２、ｄ３）という関数を考える。
この値を減らしていきＤＦＳで探索することで最終的な答えを求めることができる。
ｄｘは最大３となる数であるため、各点ごとに２桁で表わされるビットｄｐを利用する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int v[1&amp;lt;&amp;lt;(2*10)],m[1&amp;lt;&amp;lt;(2*10)];
class TwinTowns {
public: vector&amp;lt;int&amp;gt; optimalTwinTowns(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int maxPartners, int minDistance) {
int n=x.size();</description>
    </item>
    
    <item>
      <title>SRM 509 DIV1 Middle - PalindromizationDiv1　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-509-div1-middle---palindromizationdiv1%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 19 May 2014 21:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-509-div1-middle---palindromizationdiv1%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
ある文字列が与えられ、それを回文にしたい。
回文にするために複数のアルファベットの追加、削除、変換式が与えられ、各変換式について必要なコストも与えられる。
このとき、回文にするために必要な最小のコストを求める。回文にできないときはー１を返す。
解き方 
Editorialを読みました。
通常の回文の解き方をベースに、それを応用できるか。
通常の回文の解き方は以下の通り。
左端と右端の場所が一致、もしくは残り１文字になれば終了。
そうでなければいずれかの操作を行う。
１）回分の左端と右端(a,b-1)のアルファベットがことなれば一致するように変換し、
変換コストを足して(a+1,b-2)を調べる。
２）左端を削除し、削除コストを足して(a+1,b-1)を調べる。
３）右端を削除し、削除コストを足して（a,b-2）を調べる。
今回はコストの考え方について応用する。
削除については、アルファベットを空白に変換と考えれば変換と同様に操作できる。
同様に追加についても、空白をアルファベットに変換と考えることができる。
上記の操作によって、変換のコストだけをコードに落とせればよい。
変換のコストは問題で与えられるので、配列に保存してからワーシャルフロイドを回して任意の２つのアルファベットの最小の変換コストを求める。
ただし今回は、変換できればよいことから
あるアルファベットa→c とb→cのコストの和が最小であれば上記に置き換える必要がある。
また、例外の判定については定義したＩＮＦの和が発生しうるため、
オーバーフローしないように値の判定と更新を行うことに注意。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
const int INF=1000000000;
string word;
int d[27][27],m[27][27],dp[51][51];</description>
    </item>
    
    <item>
      <title>SRM 578 DIV1 Middle - WolfInZooDivOne （復習x）</title>
      <link>https://chaingng.github.io/post/srm-578-div1-middle---wolfinzoodivone-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sun, 18 May 2014 15:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-578-div1-middle---wolfinzoodivone-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
Ｎ個のセクションに区切られた道路を渡りたい。
ただし、各セクションには多くて１匹の狼がいるので注意して歩かなくてはいけない。
今回上記に加えて、狼の存在について追加の情報が与えられる。
複数のleft[i]、right[i]が与えられ、この区間中に最大で２匹の狼が存在する。
このとき、各セクションの狼の存在についてすべての場合の数を求める。
解き方 
ｄｐで解けそうな問題なので、どのようにｄｐを設計するか。
現在の状態を考えた時に、最後に狼がいたセクションと現在いるセクションを考える。
この状態のすべての場合の数は、以下の２通りになる。
（１）現在のセクションに狼を追加せずに次のセクションに移る場合
（２）現在のセクションに狼を追加して次のセクションに移る場合
ただし（２）の場合は、与えられた条件の制約から次に移ることのできるセッションは限られる。
具体的には、前に狼がいたセクションと今回追加するセクションが両方含まれるセクションは
狼が２匹以上となりこれ以上狼は追加できないので、その次の場所から検索することになる。
あとは上記の条件をＤＦＳで実装すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int N,n,dp[305][305];
vector&amp;lt;int&amp;gt; s,t;
class WolfInZooDivOne {
public:
vector&amp;lt;int&amp;gt; parse(vector&amp;lt;string&amp;gt; str){
string s=&#34;&#34;;
FORE(i,0,str.size())s+=str[i];</description>
    </item>
    
    <item>
      <title>SRM 367 DIV1 Middle - DeviceProgramming （復習x）</title>
      <link>https://chaingng.github.io/post/srm-367-div1-middle---deviceprogramming-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sat, 17 May 2014 13:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-367-div1-middle---deviceprogramming-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
複数のデータをメモリに格納したい。
格納したいデータごとに、置きたいメモリ番地とデータサイズが与えられる。
このデータをパケットで伝送して届ける。
パケットについては、パケットの最大サイズとヘッダのサイズが与えられ、この差が１つのパケットごとに実際に送ることのできるデータサイズとなる。
送られたパケットは任意の番地からサイズ分メモリに書きこまれる。
メモリ番地については、データに関係ない部分は空白にしても他のデータを埋めてもよい。
このとき、すべてのデータを格納するために送らなければいけない合計パケットサイズを求める。
解き方 
dpで解けそうな問題。
最初は直前のデータのみを考え、ぴったりのサイズ分送るか、送ることのできる最大分のパケットを送るかの２通りで考えたが、ベストな送り方は貪欲ではなく、どのデータからスタートするかに依存する。
そのため、あるデータからあるデータまでのパケットを送るときの最小のパケットサイズを最初に求めてあげ、最後にｄｐで最小値を更新すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class DeviceProgramming {
public: long long minBytes(vector&amp;lt;int&amp;gt; offset, vector&amp;lt;int&amp;gt; size, int maxPacketSize, int overhead) {
int n=offset.size();
long long payload=maxPacketSize-overhead;</description>
    </item>
    
    <item>
      <title>SRM 434 DIV1 Middle - HexatridecimalSum （復習x）</title>
      <link>https://chaingng.github.io/post/srm-434-div1-middle---hexatridecimalsum-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sat, 17 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-434-div1-middle---hexatridecimalsum-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 0～9、A～Zの36種類のアルファベットで表わされる36進数の数字を考える。
最初に、複数の36進数の数字が与えられる。
このうち、任意のk個のアルファベットをZに変換する。
このとき、与えられた数字の和が最大となるように変換し、その最大の数字を36進数で求める。
解き方 
問題としては貪欲法で解けそう。
ただし与えられる数字は50個、文字列長も50個であることから単純な変換ではオーバーフローしてしまう。
そこで、36進数のままで足し算と大小比較を行うことにする。
今回は元の数字を最初に足してしまってもよい。
それから各アルファベットについての差分を計算し、その計算した差分を降順にソートして順にｋ個足して解いた。
最初にオーバーフローまで踏まえてコーディングしないと後戻りは難しいので、
最初にあらかじめオーバーフローと計算量を忘れずに見積もる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class HexatridecimalSum {
public:
int getint(char ch){
if(&#39;0&#39;&amp;lt;=ch&amp;amp;&amp;amp;ch&amp;lt;=&#39;9&#39;)return ch-&#39;0&#39;;
return ch-&#39;A&#39;+10;
}
char getch(int x){
if(0&amp;lt;=x&amp;amp;&amp;amp;x&amp;lt;=9)return (char)(&#39;0&#39;+x);
return (char)(x-10)+&#39;A&#39;;</description>
    </item>
    
    <item>
      <title>SRM 339 DIV1 Middle - TestBettingStrategy　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-339-div1-middle---testbettingstrategy%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 15 May 2014 22:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-339-div1-middle---testbettingstrategy%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
最初にコインをinitSum個持っており、goalSum個まで増やしたい。
rounds回のラウンドがあり、最初のラウンドはコインを１個かけ、勝ったら１個もらえる。
負けるとそのコインは失い、次は２倍のコインをかけなければいけない。
勝った場合は賭けた分のコインはもらえる。
またあらかじめ、勝つ確率はprobになるとわかっている。
goalSum個までコインが増えたら辞めてもよいが、賭ける分のコインが無くなったらゲームを終えなければならない。
このとき、コインがgoalSum個になる確率を求める。
解き方 
ｄｐの問題。
状態に「ラウンド数」、「連続で負けた数」、「現在のコインの数」を持ち、
値に「確率」を持たせればよい。
ｄｐの更新のさせ方が最大・最小をとるのか、加算していくのかで途中つまづいた。
また問題文のスコアの条件を正しく読みとれなくつまずいてしまったので、
きちんと問題文を読むことが大事。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
double dp[51][10][1001];
class TestBettingStrategy {
public: double winProbability(int initSum, int goalSum, int rounds, int prob) {</description>
    </item>
    
    <item>
      <title>SRM 381 DIV1 Middle - TheHomework　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-381-div1-middle---thehomework%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 15 May 2014 08:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-381-div1-middle---thehomework%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
数字の配列が与えられ、最初の配列からもう一つの配列へ変換したい。
可能な操作は以下の３通り。
・追加：最大で元の配列の分だけ、好きな数字を追加
・削除：最大で元の配列の半分を超えないよう、好きな数字を削除
・変更：最大で元の配列の半分を超えないよう、好きな数字を変換
このとき、必要な最小操作回数を求める。
解き方 
数字を変換するのでコードで扱うのは大変そうだが、要は数字が何個一致しているか、何個一致していないかだけわかればよいので、数字自身は無視して良い。
変換する法則を考えていかに分岐が少なくシンプルに実装するかを考えるが、この場合は場合分けが大変になってしまう。
そのため、全探索で解けないかを考えてみる。
状態として「現在までに一致している数字の数」、「異なる数字の数」、「追加で一致しなければならない数字の数」をもつｄｐを考え、ＤＦＳを用いれば全探索で解くことが可能。
法則を考える方法もあるが、まずは確実でかつシンプルに解ける全探索で解けないかを考えてみるのが大事。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[51][51][51];
class TheHomework {
public:
int rec(int sames,int diff,int missing){
if(diff==0&amp;amp;&amp;amp;missing==0)return 0;
if(dp[sames][diff][missing]!=-1)return dp[sames][diff][missing];
int n=sames+diff;</description>
    </item>
    
    <item>
      <title>SRM 548 DIV1 Middle - KingdomAndDice　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-548-div1-middle---kingdomanddice%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 13 May 2014 23:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-548-div1-middle---kingdomanddice%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
サイコロが２つあり、２人のプレイヤーがそれぞれ１つのサイコロを振って出た目が大きい方が勝つゲームを行う。
ゲームはできるだけ公平にしたいので、勝つ確率は５０％になるのが望ましい。
ここで、サイコロ２つに対して各面の目がいくつか与えられる。
ただしそのうち一つのサイコロはいくつかの面がとれてしまい、代わりに０としている。
この目をすでに使っていない数字かつ最大の数字Ｘ以下の数字を埋めることで、
各確率を５０％に可能な限り近づけた際の確率を求める。
ただし数字は必ずしも埋めずに０を使ってもよい。
解き方 
出る目の数字は１０＾９であるので単純に考えると計算量は間に合わない。
ここで問題文に着目してみると、求めるのは勝つ確率だけであるので、相手の目に対して埋める目の勝つ数は５０個以下であることがわかる。
つまり勝つ回数０～５０まで考えればよいことがわかる。
次に、それぞれの勝つ回数について、何個まで使うことができるかを求める。
今回はvector型のint変数を用意し、勝つ回数を配列に用意する。それぞれの勝つ回数は最大で埋めることのできる数、つまり最初のサイコロの０の数なのですべて用意してもオーバーフローしない。
求めたvector配列を用いて、勝つことのできる回数を全て求める。
単純に考えると組み合わせ５０Ｃ２５で間に合わないが、ｄｐを用いて
状態を勝つ回数、値を利用する目の数とすることで求めることができる。
ｄｐを回す際には、配列がオーバーフローしないように判定することに注意。
最後に求めたｄｐの中からできるだけ答えが０．５に近くなるものを求める。
この時にｎ＊ｎで割ると誤差が出てしまうので式を変形して、
勝つ回数をxとすると
x/(n*n)=0.5
x=0.5*n*n
2x=n*n
2x-n*n=0
つまり2x-n*nの絶対値が一番０に近いものが最終的な答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class KingdomAndDice {
public: double newFairness(vector&amp;lt;int&amp;gt; firstDie, vector&amp;lt;int&amp;gt; secondDie, int X) {</description>
    </item>
    
    <item>
      <title>SRM 375 DIV1 Middle - DateFieldCorrection　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-375-div1-middle---datefieldcorrection%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 12 May 2014 23:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-375-div1-middle---datefieldcorrection%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
キーボードで「”月”　”日”」を打ちたいが、タイプミスをしばしば起こしてしまう。
タイプミスはキーボードの隣り合う文字についてはコスト１、スペースとの間は３のコストで定義される。
タイプ後の文字が与えられるとき、最もコストの少ない、つまり打とうとしていた「”月”　”日”」を求める。ただし同じコストの場合は最も早い月日を返す。
解き方 
実装の問題なので、いかにシンプルに考えて、シンプルに実装するか。
まず問題文にキーボード間のコストが図で載っているが、
これを以下に簡単に定義できるかが課題。
キーボードをみてみると、キーボードの行単位で考えることができそう。
各行に対し、隣り合う文字とのコストは１となる。
各行に対し、真下の行の文字とのコストは１となる。
各行に対し、真下の行の左下の文字とのコストは１となる。
一番下の行について、スペースとのコストは３となる。
また英数字は８ビットで表わせるので、int型の配列d[256][256]を定義し
配列番号はアルファベット、値は距離としてあげればコストをグラフで定義できる。
最後にワーシャルフロイドを回せば各文字間の最短距離が求められる。
最後にすべての月、日に対してアウトプット「”月”、”日”」の文字列を用意し
与えられた文字inputと文字列長が同じであればコストを計算すればよい。
最後に大文字と小文字の区別をなくすように、tolower関数を使うことに注意。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int d[256][256];
class DateFieldCorrection {
public:
int rec(string str1,string str2){</description>
    </item>
    
    <item>
      <title>SRM 298 DIV1 Middle - OrderDoesMatter　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-298-div1-middle---orderdoesmatter%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 12 May 2014 08:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-298-div1-middle---orderdoesmatter%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
複数のN[i]とM[i]の行列が与えられ、積の計算を行う。
行列計算はAxB、CxDにおいてB=CであればAxDの値と等しくなる。
また、計算結果の要素数はAxDの値となる。
このとき、行列の計算順序を入れ替えることですべての積をひとつにまとめることができるのであれば、そのうち計算結果が最大の要素となる要素数を求める。
まとめることができない場合はー１を返す。
解き方 
行列をひとつにまとめることができるか、ということなので
つまり一筆書きができるか、オイラー路があるかと考えることができる。
オイラー路があるかどうか、あるときにそのルートを求める方法は以下に解説されています。
http://nya3.jp/libicpc/?%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%2F%E3%82%B0%E3%83%A9%E3%83%95%2F%E5%B7%A1%E5%9B%9E%E8%B7%AF%2F%E6%9C%89%E5%90%91%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E8%B7%AF
今回は始点と終点を求められるようにコーディングする。
まずは各数に対して出次数と入次数を計算し、その差の次数が２以上であれば一筆書きできない。
また差の入次数１のノードが１つ、差の出次数１のノードが１つでなければ一筆書きできない。
次に全てのノードをたどっていったとき、たどっていないノードがあれば一筆書きできない。
最後に入次数１のノードが１つ、出次数１のノードが１つであればそのノードの積が答えになり、すべての次数が０であればどこからでもスタートできるので最大のＮ＊Ｎが答えになる。
コーディングの際、配列の数は十分か注意する。
（p[x][y]は実際の要素数を表わすので、p[60][60]ではなくp[1001][1001]）
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int p[1001][1001];
int deg[1001],used[1001];
class OrderDoesMatter {
public:
void f(int x){
used[x]=1;</description>
    </item>
    
    <item>
      <title>SRM 387 DIV1 Middle - IntervalSubsets　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-387-div1-middle---intervalsubsets%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 03 May 2014 10:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-387-div1-middle---intervalsubsets%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
複数の区間が与えられ、始まりの数字start[i]と終わりの数字finish[i]がわかっている。
この区間を、サブセット集合にまとめたい。
以下の条件を満たしたときにサブセット集合と呼ぶ。
・集合中の各区間に重複がないこと
・その集合に他の要素を足すと重複が出てしまうこと
このとき、サブセット集合が何通りあるか求める。
解き方 
ｄｐの問題そうなのは読みとれる。
ｄｐの設計方法について考える。
区間をできるだけくっつけていき、もうくっつけることができなければその集合を答えに加えるのがよさそう。
区間をくっつけていくには、区間の初めから考えていくｄｐになりそう。
なので区間をはじめの方から走査し、前の区間がなければ最初の区間なのでｄｐに加える方法にする。
ｄｐの状態は「区間の終わりの数字」、値は「その区間の場合の数」とする。

区間の始まりの数字を０から１００まで走査し、対象となる区間について、前の区間がなければ区間に加えていく。
加えていくときにそれまでの区間が存在するかはすでに判定しているので、そのような区間が存在していれば場合の数の和になっていく。

最後につなげるのに使われた途中の区間はカウントしてはいけないので、
最大のstart区間より大きい数字のｄｐを足していく。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class IntervalSubsets {
public: int numberOfSubsets(vector&amp;lt;int&amp;gt; start, vector&amp;lt;int&amp;gt; finish) {</description>
    </item>
    
    <item>
      <title>SRM 610 DIV1 Middle - AlbertoTheAviator　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-610-div1-middle---albertotheaviator%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 02 May 2014 20:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-610-div1-middle---albertotheaviator%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
車を運転しており、最初に持っている燃料Fが与えられる。
また、複数の給油ポイントがあり、そこまでにいくのに必要な燃料durationと給油できる燃料refuelが与えられる。
好きな給油ポイントを選んで行ってよいとき、たどりつくことのできる最大の給油ポイントの数を求める。
解き方 
給油ポイントの数が５０であるため、Ｏ（５０！）と全探索では解けない。
そのため、順番を考慮しないとｄｐで解くことはできない。
では、どのようにたどる順番があるかを考える。
問題文より、必要な燃料の順では解けないことがわかる。
証明として、refuelの降順にたどることができないかを反例を用いて考える。
仮に、ある給油ポイントがduration[i]、refuel[i]、
それよりもrefuelが少ない給油ポイントduration[j]、refuel[j]を考える。
refuelが少ない給油ポイントから多いポイントに行けて、
多い給油ポイントから少ない給油ポイントに行けないとすると、
F-duration[j]+refuel[j]&amp;gt;=duration[i]
F-duration[i]+refuel[i]&amp;lt;duration[j]
式を変形すると、
F+refuel[j]&amp;gt;=duration[i]+duration[j]
F+refuel[i]&amp;lt;duration[i]+duration[j]
refuel[i]&amp;gt;refuel[j]より上記は成立しないので、
少ない給油ポイントから多い給油ポイントに行けるときは、
必ず多い給油ポイントから少ない給油ポイントに行けることがわかる。
よって、refuelの降順にｄｐを適用していけばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[51][5001];
class AlbertoTheAviator {
public: int MaximumFlights(int F, vector&amp;lt;int&amp;gt; duration, vector&amp;lt;int&amp;gt; refuel) {</description>
    </item>
    
    <item>
      <title>SRM 383 DIV1 Middle - FloorBoards　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-383-div1-middle---floorboards%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 02 May 2014 08:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-383-div1-middle---floorboards%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
２次元のセルで示される天井が存在し、すべてにすきまなく屋根を作りたい。
屋根を作るのに必要な板は幅が１であり、高さは好きに決めてもよい。
また、天井にはでこぼこが存在し、そこには板を置くことができない。
このとき、屋根を作るのに必要な板の最小枚数を求める。
解き方 
他の方のコードを参考に復習しました。
ｄｐの考え方として、
一つ上の行のすべての棒が縦か横かわかっていれば、現在の行に棒を加えたらよいかどうかわかる。
そのため、「現在の行番号」「現在列番号」「現在列の一つ前の行までの縦横の情報＆一つ上の行の縦横の情報」を状態にもち、「現在の行列番号のひとつ前までのコスト」を値に持つｄｐを考える。
走査としては、現在の行列に「縦の棒を入れた時」と「横の棒を入れた時」のコストの変化を更新する。
縦の棒にしたとき、横の棒にしたときそれぞれ縦横の情報が変わるので状態を変更してｄｐを更新する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[11][11][1&amp;lt;&amp;lt;10];
class FloorBoards {
public: int layout(vector&amp;lt;string&amp;gt; room) {
int h=room.size(),w=room[0].size();
FORE(i,0,h+1)FORE(j,0,w+1)FORE(k,0,(1&amp;lt;&amp;lt;w))dp[i][j][k]=1e+9;
dp[0][0][0]=0;
FORE(i,0,h){
FORE(j,0,w)FORE(k,0,(1&amp;lt;&amp;lt;w))FORE(l,0,2){
int cost=dp[i][j][k]+1;</description>
    </item>
    
    <item>
      <title>SRM 469 DIV1 Middle - TheMoviesLevelTwoDivOne　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-469-div1-middle---themoviesleveltwodivone%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 01 May 2014 21:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-469-div1-middle---themoviesleveltwodivone%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
プレイヤーは複数存在するホラー映画を観る。
各ホラー映画について、映画の長さlengthと恐いシーンが出現するときの映画開始からの長さscaryが与えられる。
長さscaryまで起きて入れば恐さの値が47加算される。
プレイヤーは最初に恐さの値を74持つ。
１分ごとに恐さの値が１ずつ減っていき、－１になると寝てしまい他の映画は見れなくなる。

このとき、できるだけ多くの映画を観ることができる順番を求める。
複数存在するときは辞書順に小さいものを返す。
解き方 
映画の数は20なので、ビット列ｄｐがなんとなく使えそう。
ただし順番を求めるため、ｄｐの値に配列を持つとメモリが足りなくなってしまう。
そこで、「映画を観た本数」の配列と「そのうち辞書順で最小の映画の順番」の配列を用意し、状態として「これまでに観た映画のビット列」を持たせる。
最後に逆順にたどることで、順番を復元することができる。
ｄｐで求めたい値が２つある場合は、今回のように最小の「映画の順番」、「映画を観た本数」の２つのｄｐを用意して解く。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int c[(1&amp;lt;&amp;lt;20)+1],first[(1&amp;lt;&amp;lt;20)+1];
class TheMoviesLevelTwoDivOne {
public:
vector&amp;lt;int&amp;gt; find(vector&amp;lt;int&amp;gt; length, vector&amp;lt;int&amp;gt; scary) {
int n=length.size();
memset(c,0,sizeof(c));</description>
    </item>
    
    <item>
      <title>SRM 273 DIV1 Middle - SnakeTurbo　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-273-div1-middle---snaketurbo%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 29 Apr 2014 22:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-273-div1-middle---snaketurbo%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
１次元の座標をヘビが歩く。
startLocationからスタートし、左か右に移動することができる。
endLocationまでたどり着けばゴールになる。
途中に複数のorbsで示される座標が与えられ、そこにたどり着くと速度が２倍になる。
このとき、ゴールにたどり着くまでの最小の時間を求める。
解き方 
制約は座標数＝５０。
これまでにたどり着いた一番左の座標と右の座標、現在左と右のどちらにいるかの状態を持ち、コストを値に持つｄｐを考えればよい。
上記の状態だけあれば、その時のスピードは簡単に計算できるのでスピードの状態を持つ必要はない。
座標にスタートとゴールの位置を足すので、それを踏まえた配列の確保が必要。
グローバル変数の更新に、ローカルでも間違って宣言すると更新されないので注意。
(global int n; local int n=orbs.size() → n=orbs.size();)
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int e,n;
double dp[53][53][2];
vector&amp;lt;int&amp;gt; orb;
class SnakeTurbo {
public:</description>
    </item>
    
    <item>
      <title>SRM 399 DIV1 Middle - BinarySum （復習x）</title>
      <link>https://chaingng.github.io/post/srm-399-div1-middle---binarysum-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sun, 27 Apr 2014 13:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-399-div1-middle---binarysum-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
整数a,b,cが与えられる。
a,b,cを２進数に変換し、a+b=cとなるように２進数の1の位置を変化させる。
このとき、式が成立する最小のcの値を求める。
そのような値が存在しない場合は-1を返す。
解き方 
他の方のコードを読ませていただきました。
前の状態がわかれば現在の状態は簡単に求められるので、ｄｐが適用可能。
では、どのようにｄｐを適用したらよいかを考える。
まず、前の桁からの桁上がりと、ｘ、ｙの増分がわかれば
その桁においてｃの１の数がいくらまで可能か求められる。
よって、「aの１の数」「bの1の数」「cの1の数」「桁上がりがあるかどうか」「桁数」を引数にもち、「結果のｃの値」を値に持つｄｐを用いればよい。
計算量はO(2*30^4)となる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[32][32][32][32][2];
class BinarySum {
public: int rearrange(int a, int b, int c) {
int x=0,y=0,z=0,n=0;
for(;a||b||c;n++){</description>
    </item>
    
    <item>
      <title>SRM 617 DIV1 Middle - PieOrDolphin　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-617-div1-middle---pieordolphin%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 26 Apr 2014 23:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-617-div1-middle---pieordolphin%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
５０人のプレイヤーが存在する。
毎日コンテストを行い、その勝者２名にイルカ１つとパイ１つをプレゼントする。
どちらにイルカ、どちらにパイをプレゼントしてもよい。
コンテストが終わったとき、各プレイヤーが受け取ったイルカとパイの数の絶対値をできるだけ小さくしたい。
毎日行われるコンテストの勝者２名がわかっているとき、上記を満たすようなプレゼントの仕方を求める。
解き方 
問題をグラフに落とすことで単純化できる。
今回はノードを各プレイヤーとする。
エッジは各コンテストの勝者２名を有向グラフで結び、入りをイルカ、出をパイとみなすことでグラフに落とし込むことができる。
このとき、各ノードの入次数と出次数の差を最小化する問題とみなすことができる。
次に、エッジの向きをどのように最適化していけばよいか考える。
あるノードからのエッジについて向きをを入れ替えた際、
つながっているノードの絶対値が増える場合がある。
ここでもう少し考えると、さらにそのノードからエッジが伸びている場合、
中間のノードは±０なので絶対値が変わらないことがわかる。
よって同じノードに戻ってこないようなパスを考えて、それをひっくり返せばよい。
ただし、同じパスの更新のループにならないようにしなければらない。
そこで、終了のノードをどこに持ってくればよいかを考える。
ひとつめの条件は、同じノードに戻ってこないようなパス。
もう一つは、入次数の方が多い場合はより最適化できるので、そこで終わればよいことがわかる。そのノードで終わることで、次にそのノードから同じパスは再現されないので同じ更新は繰り返されない。
よって、同じノードに戻ってこないようなパス、もしくは入次数の方が多いノードで終わるパスを考えて、それを全てひっくり返せばよいことがわかる。
最後に、各ノードは絶対値をいくつまで収束させたらよいかを決めるために、絶対値の最小値はいくつであるか考える。
０が最適な値であるのは自明。
また、奇数のときは最小で１になってしまう。
では、２の場合はどうかを考える。
そのノードから上記のパスの更新を行ったとき、途中のノードの絶対値は大きくならないことがわかる。よって、２の場合は１または０に更新することができる。
よって、各ノードの絶対値は１以下になるように収束させる。
最後に、以上で証明した手順をコードに落とせばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PieOrDolphin {</description>
    </item>
    
    <item>
      <title>SRM 588 DIV1 Middle - KeyDungeonDiv1　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-588-div1-middle---keydungeondiv1%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 16 Apr 2014 23:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-588-div1-middle---keydungeondiv1%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
最初に赤い鍵をkey[0]個、緑の鍵をkey[1]個、白い鍵をkey[2]個与えられる。
ドアが複数存在し、ドアごとに空けるために必要な赤い鍵の数、緑の鍵の数がわかっている。また、ドアを開けた時に得られる各色の鍵の数が与えられる。
ドアを空けるためには必要な赤い鍵の数、緑の鍵の数を持っていないといけないが、
白い鍵は赤い鍵もしくは緑の鍵として代用できる。
ドアを開けたら使った鍵はなくなってしまう。
またプレイヤーは好きなところでドアを開けるのをやめてもよい。
このとき、持っている鍵の数が最大となるときの鍵の合計数を求める。
解き方 
最初に白い鍵はできるだけ消費しないように貪欲に解けると思ったが、
空けるドアの順番によって白い鍵の数が変わってしまうため貪欲法では解けない。
そのため、すでに空けたドアを状態に持つＤＰでは解けない。
そこで、白い鍵を赤とみなすか、緑とみなすか全ての場合を考えれば全ての鍵の使い方を探索することができる。
つまり、すでに空けたドアに加え、白い鍵を赤とみなす数を状態に持つＤＰを用いれば解くことができる。
今回は鍵の数を返り値にもつＤＦＳではなく、グローバルで答えを更新した方が単純なコードになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int n,dp[(1&amp;lt;&amp;lt;12)][131],best;
vector&amp;lt;int&amp;gt; doorR,doorG,roomR,roomG,roomW,keys;
class KeyDungeonDiv1 {
public:
void dfs(int mask,int w){
if(dp[mask][w])return;
dp[mask][w]=1;
int r=keys[0]+w,g=keys[1]+keys[2]-w;</description>
    </item>
    
    <item>
      <title>SRM 238 DIV1 Middle - SequenceSync　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-238-div1-middle---sequencesync%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 15 Apr 2014 08:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-238-div1-middle---sequencesync%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
オートマトン図が与えられ、各状態について１～４までの数字が与えられた時に遷移する状態が与えられる。
例）　１行目：１　２　２　３　状態０が１～４を与えられた時に遷移する状態
すべての要素の初期状態についてわかっていないとき、
すべての要素が同じ状態になるために必要な最小の遷移回数を求める。
解き方 
すべての状態の初期状態が不明なので、最悪の場合、つまり各要素が異なる状態を持っていることを考える。
要素数は２０なので、各要素の状態数は全探索可能。
よってメモ化を用いて、ＢＦＳにて答えを求める。
ＤＦＳの場合は深さ優先探索にて最小の長さを求められないケースも発生しうるので、
うまくいかない。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[1300000],p[30][4],n,ans;
class SequenceSync {
public:
bool ispossible(int x){
int cnt=0;
FORE(i,0,n)if(x&amp;amp;(1&amp;lt;&amp;lt;i))cnt++;
return cnt==1;</description>
    </item>
    
    <item>
      <title>SRM 511 DIV1 Middle - FiveHundredEleven　（復習×）</title>
      <link>https://chaingng.github.io/post/srm-511-div1-middle---fivehundredeleven%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 14 Apr 2014 23:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-511-div1-middle---fivehundredeleven%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
０～５１１の間である数字の配列が与えられ、2人でゲームを行う。
最初はFoxの番から始まり、次はToastmanの番になる。
ゲームは配列から好きな数字を選び、現在までの数字とのORを取る。
ORをとったときに５１１になるか、選ぶ数字がなくなった方の負けになる。
数字の配列が与えられた時、どちらが勝つかを求める。
解き方 
配列数は５０なので全探索しようとすると50!で間に合わない。
ORをした後は現在まで選んだ数字の順番は関係なくなるので、50C25としても間に合わない。
そこで、終了条件について考える。
終了条件は残りのどの配列を選んでも５１１になるか、選ぶものはないかなので、最後にＯＲとなった数の配列数が奇数ならFOX、偶数ならToastmanの勝ちになる。
ＯＲとなった数の配列数は簡単に求められる。
また、FOXはORとなった数が奇数になるように、Toastmanは偶数になるように選んでいくのが最適な戦略であるので、これをdpと再帰で書いてあげれば答えは求まる。
コード 
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[512][2],score[512];
vector&amp;lt;int&amp;gt; cards;
class FiveHundredEleven {
public:
int dfs(int x,int turn){
if(dp[x][turn]!=-1)return dp[x][turn];
int win=0,cnt=0;
FORE(i,0,cards.size()){
if(x!=(x|cards[i]) &amp;amp;&amp;amp; (x|cards[i])!=511 ){</description>
    </item>
    
    <item>
      <title>SRM 196 DIV1 Middle - Assemble　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-196-div1-middle---assemble%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 11 Apr 2014 21:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-196-div1-middle---assemble%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=209
複数の電力源が与えられて、エネルギーの値があらかじめわかっている。
隣り合う２つの電力源について、左側が入力値、右側が出力値をあらわす。
このとき、隣り合う２つの電力源を融合することができる。
融合するのに必要なコストは
左側の電力源をinpA、右側の電力源をconnection、その右側の電力源をoutBとすると、
cost=(inpA+sizeA)*connection*(outB+sizeB)
で表わされる。
sizeは最初は全て１であり、融合するとsizeA+sizeBが新しいサイズになる。
このとき、全ての電力源を融合するために必要な最小のコストを求める。
解き方 
電力源の数は５０個なので、全探索しようとすると50!で間に合わない。
そのためｄｐを利用する。
まず、距離がlenにある電力源aとbをつなげるときの最小のコストを考える。
このときの最小のコストは、aとbを全ての場所で区切ったときのコストのうち最小、
つまりaとbの間で1~len-1で区切ったときのコストのうち最小のものになる。
上記について、lenを1からnまでの長さについて求めてあげれば
最終的に0からn-1までの最小のコストが求められる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[51][51];
class Assemble {
public: int minCost(vector&amp;lt;int&amp;gt; connect) {
int n=connect.</description>
    </item>
    
    <item>
      <title>SRM 427 DIV1 Middle - LocateTreasure　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-427-div1-middle---locatetreasure%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 10 Apr 2014 07:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-427-div1-middle---locatetreasure%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9984
関数dig(x)が与えられ、x&amp;lt;10のときはx、そうでないときは各桁の和が返される。
プレイヤーはｘｙ座標の(0,0)にいる。
最初は北にdig(１)歩進む。
９０度右に転換する。
次に与えられたmultiを進む数にかける。
このステップをＫ回繰り返した時、最後にいる位置を答える。
解き方 
dig(x)はある値に収束しそう。
繰り返してみると、ある配列に収束することがわかる。
もう少し踏み込んでみると、各桁の和をとるということは、各桁を９で割ったあまりを足すことと同義となる。
よって、xが10以上の場合は10未満になるまで9を引いてあげればよい。
次に、配列は最大でも長さ12になることがわかる。
よってKが12より大きい場合は12で割った余りに、安全に24を足してあげれば同じ座標に収束する。
最後に、収束する座標は初期値の繰り返しにならないことに注意。
(0, 0), (0, 1), [(6, 1), (6, -8), (-3, -8), (-3, 1)]
[]が繰り返し部分であり、(0,1)は一回しか現れないことに注意する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class LocateTreasure {</description>
    </item>
    
    <item>
      <title>SRM 486 DIV1 Middle - QuickSort　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-486-div1-middle---quicksort%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 03 Apr 2014 08:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-486-div1-middle---quicksort%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=2702
クイックソートは、配列をサブ集合に分けるときのピボットの選び方によりソートまでのスワップ回数が異なる。
ある配列が与えられた時、その配列をソートするまでに必要なスワップ回数の期待値を求める。
解き方 
すべてのサブ集合のコストを洗い出す、と考えると計算量はオーバーしてしまう。
ソート済みの配列を考え、その配列の各長さのサブ集合を考える。
そのサブ集合については、元の配列の要素の順番を守った配列をソートしたスワップ回数と等しくなる。
これを利用して、サブ集合の長さを２～ｎまでｄｐによって求めればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class QuickSort {
public: double getEval(vector&amp;lt;int&amp;gt; L) {
int n=L.size();
double dp[n+1][n+1];
memset(dp,0,sizeof(dp));
vector&amp;lt;int&amp;gt; sorted=L;
sort(all(sorted));
FORE(len,2,n+1){
for(int s=0;s+len&amp;lt;=n;s++){
int e=s+len;</description>
    </item>
    
    <item>
      <title>SRM 390 DIV1 Middle - PaintingBoards　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-390-div1-middle---paintingboards%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 02 Apr 2014 20:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-390-div1-middle---paintingboards%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8516&amp;amp;rd=11124
それぞれ長さの違うボードが連続して並んでおり、すべてのボードにペンキを塗りたい。
各ボードの長さはあらかじめわかっている。
また、ペンキを塗るペインターが複数おり、各ペインターが長さ１のボードを塗る速さもわかっている。
一人のペインターは複数のボードを塗ることができるが、塗るボードは連続していないといけない。
ボードを塗るペインターの数に制限はなく同時に作業することができるとき、
すべてのボードを塗るのに必要な最小時間を求める。
解き方 
時間を固定することでその条件を満たすかどうか決められそうなので、二分探索が使えそう。
ただし時間は10^13刻みで探索が必要になる。
ここで、今回長さの取りうる数はあらかじめわかっているので、
全ての長さの値と全てのペインターで割った数が今回とりうる値になる。
そうすると数はn(ボードの数)*n*m(ペインターの数)で5*10^4ほどに削減できる。
次に長さが決まったとき、ペインターの全ての塗る順番を調べなければいけない。
Ｏ（2^16）なので計算量は間に合いそう。
ペインターの数mの全てのビット列を操作し、各ビットが０のペインターから順に選んでいきビット列のｄｐを更新していけば、全てのペインターの塗る順番を調べることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int sum[100],memo[16][60],n,m,cnt;
double times[1&amp;lt;&amp;lt;16];
int dp[1000000];
vector&amp;lt;int&amp;gt; painter;
class PaintingBoards {
public:
int f(int x,int start,double len){</description>
    </item>
    
    <item>
      <title>SRM 250 DIV1 Middle - TVWatching　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-250-div1-middle---tvwatching%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 30 Mar 2014 21:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-250-div1-middle---tvwatching%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=927
テレビの番組表があり、各番組ごとに開始時間と終了時間が与えられる。
できるだけ多くのテレビ番組をみたいが、放送時間が重複しているときは同時にみることができない。
このとき、できるだけ多くのテレビ番組をみたときのテレビの視聴時間を求める。
解き方 
開始時間と終了時間は２４時間単位でループしているので、単純に終了時間のみをみるだけでは正確な答えが求まらない。
そこでｄｐを用いて、一番最初に見たプログラムと一番最後に見たプログラムを状態数に持つ。まだみていないプログラムについて、最後にみたプログラムの終了時間以降にはじまり、ループして最初にみたプログラムよりも前の時間に終わることができるものについて全ての場合を調べる。
メモ化しても５０＊５０なので計算量とメモリ量も足りる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[51][51],from[51],to[51],n;
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
class TVWatching {
public:
int calc(string str){
int ret=(str[0]-&#39;0&#39;)*600+(str[1]-&#39;0&#39;)*60+(str[3]-&#39;0&#39;)*10+(str[4]-&#39;0&#39;);
if(ret&amp;gt;=720)ret-=720;
return str.substr(5,2)==&#34;PM&#34; ? ret+720 : ret;</description>
    </item>
    
    <item>
      <title>SRM 173 DIV1 Middle - TreasureHunt　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-173-div1-middle---treasurehunt%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 30 Mar 2014 16:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-173-div1-middle---treasurehunt%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=416
ある島にある宝を探しにいきたい。
島のマップが与えられ、陸地の場所と宝の場所がしめされている。
宝の場所はあいまいであり必ずしも正確ではないが、
スタート地点からどのように移動すれば宝の位置にたどり着けるかがわかっている。
スタート地点は海から島にたどり着くため、海に隣接していないといけない。
このとき、宝の場所がどこにあるかを求める。
宝の場所が複数存在する場合は、地図の宝の位置とのユークリッド距離が最も近いものになる。ユークリッド距離も同じ場合はもっとも北にあるもの、北の位置も一緒であればもっとも西にあるものになる。
解き方 
問題文が長く、スタート位置が海に隣接していなければいけないことを読み落としてしまった。これがわかれば単純に実装するだけ。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
vector&amp;lt;string&amp;gt; island;
int w,h;
class TreasureHunt {
public:
bool inside(int x,int y){
return (0&amp;lt;=x&amp;amp;&amp;amp;x&amp;lt;h &amp;amp;&amp;amp; 0&amp;lt;=y&amp;amp;&amp;amp;y&amp;lt;w &amp;amp;&amp;amp; island[x][y]!=&#39;.&#39;);
}</description>
    </item>
    
    <item>
      <title>SRM 311 DIV1 Middle - SumThemAll （復習xx）</title>
      <link>https://chaingng.github.io/post/srm-311-div1-middle---sumthemall-%E5%BE%A9%E7%BF%92xx/</link>
      <pubDate>Sun, 30 Mar 2014 10:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-311-div1-middle---sumthemall-%E5%BE%A9%E7%BF%92xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6430
０以上の整数lowerBoundとupperBoundが与えられる。
ここである数字xのスコアについては、xの各桁の数字の和で表わされる。
このときlowerBoundからupperBoundまでの全ての数字のスコアの和求める。
解き方 
数字は2*10^9であるため全探索では解けない。
例として、２けたの数字10*x+yを考える。
ここでyが9のとき、数字のスコアは以下の和であることがわかる。
１桁目：45(0~9の和)*(x+1)
２桁目：(1~xの各数字*10の和）
次に桁数がnのときは(1~xの各数字)について、上記の再帰関数で求めればよいことが分かる。
またyが8以下のときは、例えば18のときは19のスコアから1+9（各数字の和）を引けばよいので、yが9の場合に変換することができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SumThemAll {
public:
long long sum(long long x){
if(x&amp;lt;10)return x;
return sum(x/10)+x%10;
}
long long calc(long long x){</description>
    </item>
    
    <item>
      <title>SRM 614 DIV1 Easy - MinimumSquare　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-614-div1-easy---minimumsquare%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 30 Mar 2014 08:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-614-div1-easy---minimumsquare%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12976
座標上に複数の点が与えられる。
座標上に正方形を描き、その正方形の中に少なくともＫ個以上与えられた点が入っているようににしたい。
このとき、描くことのできる最小の正方形の面積を求める。
解き方 
点の数は１００個なので、単純にすべての点の選び方を全探索しようとすると１００Ｃ５０で間に合わないので違う方法を考える。
今回ｘ座標は１００個、ｙ座標は１００個とするとすべての始点の選び方は１０＾４となる。
また、その選んだ始点に対してすべての座標を加えた場合の長さを調べ、
Ｋ個以上となったときにその中のＫ個目の長さが最小の長さであるので、毎回その長さの正方形の面積と比較して答えを更新する。
これで計算量は１０＾６となり間に合う。
始点の選び方は与えられた座標ではなく、ｘ、ｙ座標それぞれの点に対して行うのがポイント。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MinimumSquare {
public: long long minArea(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int K) {
long long ret=9.2e+18;
int n=x.size();</description>
    </item>
    
    <item>
      <title>SRM 420 DIV1 Middle - RedIsGood　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-420-div1-middle---redisgood%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 30 Mar 2014 00:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-420-div1-middle---redisgood%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9915
赤いカードがＲ枚、青のカードがＢ枚存在する。
最初にカードは伏せられており、１枚選んでひっくり返す。
ひっくり返したカードが赤ならスコアが＋１、青ならー１となる。
プレイヤーは任意のプレイ回数でプレイをやめてもよい。
このとき、プレイヤーが得られるスコアの最大の期待値を求める。
解き方 
まずはスコアの計算方法を紙に書いて整理してみた。
現在持っている赤のカード枚数rと青のカード枚数bであるとき
そのときのスコアdp[r][b]は
(dp[r-1][b]+1) *r/(r+b) +(dp[r][b-1]-1)*b/(r+b)もしくは0のうち最大のものになる。
ただし、カード枚数はそれぞれ5000枚なので5000*5000はメモリに保存できない。
ここで上記の式を考えると
「dp[r-1][b]＝ひとつ前の配列」と「dp[r][b-1]＝現在の配列」の２つだけを持っているだけでよいので、2*5000となりメモリ量も足りる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
double dp[2][5001];
class RedIsGood {
public:
double getProfit(int R, int B) {
memset(dp,0,sizeof(dp));</description>
    </item>
    
    <item>
      <title>SRM 502 DIV1 Middle - TheProgrammingContestDivOne （復習xx）</title>
      <link>https://chaingng.github.io/post/srm-502-div1-middle---theprogrammingcontestdivone-%E5%BE%A9%E7%BF%92xx/</link>
      <pubDate>Sat, 29 Mar 2014 11:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-502-div1-middle---theprogrammingcontestdivone-%E5%BE%A9%E7%BF%92xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11357
プログラミングコンテストが開催され、複数与えられる問題を時間Ｔ以内に解く。
各問題について、得られるmaxPointsと1分あたりに引かれるポイント数pointsPerMinute、解くのに必要な時間requiredTimeが与えられる。
このとき、得られる最大のポイント数を求める。
解き方 
問題を解く順番によりポイントが変わるのが問題文から読みとれる。
問題数は最大５０なので、50!とすると計算量が間に合わない。
ここで、各問題に与えられる情報からどの順番で問題を解けばよいかがわかる。
問題jを問題iより先に解いた方がスコアが高いのであれば、
maxp[i]-pm[i]*rtime[i]+maxp[j]-pm[j]*(rtime[i]+rtime[j])&amp;lt;
maxp[j]-pm[j]*rtime[j]+maxp[i]-pm[i]*(rtime[i]+rtime[j])
-pm[i]*rtime[i]-pm[j]*(rtime[i]+rtime[j])&amp;lt;-pm[j]*rtime[j]-pm[i]*(rtime[i]+rtime[j])
-pm[i]*rtime[i]-pm[j]*rtime[i]-pm[j]*rtime[j]&amp;lt;-pm[j]*rtime[j]-pm[i]*rtime[i]-pm[i]*rtime[i]
-pm[j]*rtime[i]&amp;lt;-pm[i]*rtime[i]
pm[j]*rtime[i]&amp;gt;pm[i]*rtime[i]
よってrequiredTime/pointsPerMinuteが大きい順に並び替え、
順にdpを適用していき最大のスコアを求めればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheProgrammingContestDivOne {
public:
int find(int T, vector&amp;lt;int&amp;gt; maxp, vector&amp;lt;int&amp;gt; pm, vector&amp;lt;int&amp;gt; rtime) {</description>
    </item>
    
    <item>
      <title>SRM 350 DIV1 Middle -  StarsInGraphs　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-350-div1-middle----starsingraphs%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 29 Mar 2014 09:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-350-div1-middle----starsingraphs%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1666
有効グラフが存在する。
ある一つのノードについて、starpathがC個以下であればそのノードはstarとみなされる。
starpathは辺が５本のとき、5C3+5C4+5C5で表わされる。
このとき、starのうちstarpathが小さいものから大きいものへのパスの最長の長さを求める。
ただし、無限ループが存在する場合はー１を返す。
解き方 
問題文を読み解くのに一苦労。
はじめにC個以下を満たす最大の辺の数を求め、３以上かつもとめた最大の辺以下のノードを抽出する。
次に、今回はパスに閉路が存在しうるのでダイクストラ法ではなくベルマンフォード法を利用する。
閉路がないか判定しつつ、最長の経路を求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class StarsInGraphs {
public:
int C(int n,int k){
double ret=1;
FORE(i,0,k)ret*=(double)(n-i)/(i+1);
return (int)ret;
}
int calc(int x){
int ret=0;</description>
    </item>
    
    <item>
      <title>SRM 330 DIV1 Middle - PrefixFreeSubsets　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-330-div1-middle---prefixfreesubsets%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 29 Mar 2014 08:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-330-div1-middle---prefixfreesubsets%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1520
複数の文字列集合が与えられる。
そこから任意のサブ集合をピックアップして、そのうちのどのペアも接頭辞になっていないようにしたい。
このとき、そのようなサブ集合は何通りあるか求める。
解き方 
支配集合のうち、互いに子でない組み合わせを求める問題。
漸化式としてｄｐを利用して、それまでの組み合わせ＋そのうち子がいない組み合わせの値を更新していく。
今回は文字列をソートすることで子である文字列は隣り合わせになるので、シンプルに実装することができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PrefixFreeSubsets {
public: long long cantPrefFreeSubsets(vector&amp;lt;string&amp;gt; words) {
int n=words.size();
long long dp[n+1];
memset(dp,0,sizeof(dp));
dp[n]=1;
sort(all(words));
for(int i=n-1;i&amp;gt;=0;i--){
int j=i;</description>
    </item>
    
    <item>
      <title>SRM 398 DIV1 Middle - CountPaths　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-398-div1-middle---countpaths%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 26 Mar 2014 21:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-398-div1-middle---countpaths%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1897
フィールドの長さとして行の数rと列の数cが与えられる。
rとcの番号は1からスタートする。
合わせて、行列中の特別なフィールドが、(r,c)の形で順番に与えられる。
(1,1)からスタートし、下または右にしか移動して(r,c)まで移動する。
このとき、フィールドを通った回数ごとに、その場合の数を求める。
ただし、フィールドは与えられた順に通った時にしか通った回数は加算されない。
例えば、フィールドの順番１を通った後に順番２以降を通ったら回数は加算されるが、
順番２を通った後に０，１を通っても加算されない。
解き方 
格子状の経路の場合の数の求め方の応用。
ｄｐをどう設計するか。
行番号、列番号の他に、フィールドを通った回数、さらに以前に通ったフィールドの順番が必要なことがわかる。
すべての行列で全探索し、
さらにその中で各長さ、各フィールドの順番の和を求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[51][51][51][51];
class CountPaths {
public:
vector&amp;lt;int&amp;gt; difPaths(int r, int c, vector&amp;lt;int&amp;gt; fieldrow, vector&amp;lt;int&amp;gt; fieldcol) {</description>
    </item>
    
    <item>
      <title>SRM 388 DIV1 Middle - InformFriends　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-388-div1-middle---informfriends%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 26 Mar 2014 19:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-388-div1-middle---informfriends%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=2031
無向グラフが与えられる。
入力となるノード（人）を選んで噂を流したとき、そこからつながるノードへ噂を伝搬することができる。
このとき、全てのノードにいきわたったらそのうわさが全員に伝わったことになる。
一人に伝えられる噂はひとつであるとき、全員に伝えられる噂は最大何種類あるか求める。
解き方 
入力となるノードの全ての選び方に対して、全員に伝わるかを判定する。
次に、ｄｐを用いて選んだノードを状態として持たせ、そこからＸＯＲにて部分集合の最大を求める。
ＸＯＲを求めるときはＸ＾Ｙが必ず部分集合となるように全ての値を検索するのがポイント。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class InformFriends {
public: int maximumGroups(vector&amp;lt;string&amp;gt; friends) {
int n=friends.size();
int ok[1&amp;lt;&amp;lt;16]={};
for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;n);i++){
int mask=i;
FORE(j,0,n)FORE(k,0,n)if((i&amp;amp;(1&amp;lt;&amp;lt;j))&amp;amp;&amp;amp;friends[j][k]==&#39;Y&#39;)mask|=(1&amp;lt;&amp;lt;k);
ok[i]=(mask==(1&amp;lt;&amp;lt;n)-1);
}
int dp[1&amp;lt;&amp;lt;16]={};</description>
    </item>
    
    <item>
      <title>SRM 262 DIV1 Middle - BestYahtzeeScore　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-262-div1-middle---bestyahtzeescore%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 26 Mar 2014 09:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-262-div1-middle---bestyahtzeescore%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4797&amp;amp;rd=7996
サイコロが５個あり、出る数字があらかじめ与えられている。与えられた数字が&#34;354621111111111&#34;であれば、１回目に振った数字は
&#34;35462&#34;である。次に5を選んでもう一回振りなおせば、&#34;1&#34;が出る。
１度に同時で５つのサイコロを振り直せるが、同時に振り直せる回数は３回までになる。
最後に出た数字が全て同じ数字なら５０点、すべて連続していれば４０点、４つ連続していれば３０点、３つ同じ数字かつ２つが同じ数字なら２５点、４つ同じ数字があればすべてのサイコロの目を足した数がスコアになる。
出る数字があらかじめ与えられた時、とりうる最大のスコアを求める。
解き方 
ｄｐで解く問題。どうｄｐを構成するか。
まず、何回サイコロを振ったかの状態は持たなければいけない。
次に、同時にサイコロを振り直す時にどのサイコロを選ぶかを決めなければならない。
また、サイコロを振り直す時にどこまで振ったかをわからなければならない。
これより、上記の３つの状態をもつｄｐを作り、現在の状態から現在のすべてのサイコロの振り方を選んであげればよい。
コード 
string rolls;
class BestYahtzeeScore {
public:
int score(vector&amp;lt;int&amp;gt; cur){
int ret=0;
int num[7]={};
FORE(i,0,5)num[cur[i]]++;
FORE(i,1,7){
if(num[i]&amp;gt;=5)ret=max(ret,50);
if(num[i]&amp;gt;=4)ret=max(ret,cur[0]+cur[1]+cur[2]+cur[3]+cur[4]);
if(num[i]&amp;gt;=3)FORE(j,1,7)if(i!=j&amp;amp;&amp;amp;num[j]&amp;gt;=2)ret=max(ret,25);
}
if(num[1]&amp;amp;&amp;amp;num[2]&amp;amp;&amp;amp;num[3]&amp;amp;&amp;amp;num[4]&amp;amp;&amp;amp;num[5])ret=max(ret,40);
if(num[2]&amp;amp;&amp;amp;num[3]&amp;amp;&amp;amp;num[4]&amp;amp;&amp;amp;num[5]&amp;amp;&amp;amp;num[6])ret=max(ret,40);
if(num[1]&amp;amp;&amp;amp;num[2]&amp;amp;&amp;amp;num[3]&amp;amp;&amp;amp;num[4])ret=max(ret,30);
if(num[2]&amp;amp;&amp;amp;num[3]&amp;amp;&amp;amp;num[4]&amp;amp;&amp;amp;num[5])ret=max(ret,30);
if(num[3]&amp;amp;&amp;amp;num[4]&amp;amp;&amp;amp;num[5]&amp;amp;&amp;amp;num[6])ret=max(ret,30);
return ret;
}
int dfs(int pos,vector&amp;lt;int&amp;gt; cur,int cnt){
if(cnt==0)return score(cur);
int ret=0;
for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;5);i++){
vector&amp;lt;int&amp;gt; b=cur;
int p=pos;
for(int j=0;j&amp;lt;5;j++){
if(i&amp;amp;(1&amp;lt;&amp;lt;j)){
b[j]=rolls[p++]-&#39;0&#39;;
}
}
ret=max(ret,dfs(p,b,cnt-1));
}
return ret;
}</description>
    </item>
    
    <item>
      <title>SRM 499 DIV1 Middle - WhiteSpaceEditing　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-499-div1-middle---whitespaceediting%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 26 Mar 2014 00:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-499-div1-middle---whitespaceediting%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=2810
スペースと改行からなる文字列がある。
最初は改行のみ入力されている。
このとき、与えられた配列が(3,2,2)であるなら
space space space 改行 space space 改行 space space 改行となるようにしたい。
可能な操作は以下の通り。
①spaceの追加
②spaceの削除
③直前のspaceと改行のコピー
&amp;nbsp; (space 改行 space space 改行で2つめの改行の前にカーソルを合わせると
space 改行 space space 改行 space space 改行)
このとき、必要な最小の操作回数を求める。
解き方 
例を出して操作をシミュレーションしてみる。
{1,2,3}のとき
{1}→{1,1}→{1,2}→{1,2,2}→{1,2,3}と操作回数は６回。
{1,3,2}のとき
{1}→{1,1}→{1,2}→{1,2,2}→{1,3,2}と操作回数は6回。
ここでp[]={a,c,b}　a&amp;lt;=b&amp;lt;=cのとき,
前の数より大きいものについて,(c-a)
それに加えてa+配列数-1で作れそうなことがわかる。
大きな例で確認してみる
{1,4,3,2,3}のとき
{1}→{1,1}→{1,2}→{1,2,2}→{1,2,3}→{1,2,2,3}→{1,3,2,3}→{1,3,3,2,3}
→{1,4,3,2,3} 操作回数は9回。
1(最初の要素) + 5(配列数) -1 +(4-1)+(3-2)　=1+4+3+1=9
ということで複雑な例でも満たすことがわかる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)</description>
    </item>
    
    <item>
      <title>SRM 370 DIV1 Middle - ConnectTheCities　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-370-div1-middle---connectthecities%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 23 Mar 2014 23:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-370-div1-middle---connectthecities%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8185
都市ＡとＢがあり、その間の距離があらかじめ与えられる。
またその都市の直線状にならぶ複数のノードがあり、都市Ａを０としたときの距離がが与えられる。
このとき、ノードを全て等間隔にし、ＡとＢをつなぎたい。
ノードを１移動するとコストが１かかり、最大でfunds以内に抑えたい。
このときに必要なノードの間隔の最小値を求める。
解き方 
ｄｐを利用する。
ｄｐは現在のノードと現在の距離を状態に持つ、コストの大きさとする。
それぞれの間隔についてコストを計算し、funds以下であるものについて最小のものを求める。
間隔の求め方は昇順に調べてもよいが、2分探索を使って計算量を削減する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dist,funds,n,dp[110][110];
vector&amp;lt;int&amp;gt; position;
class ConnectTheCities {
public:
int dfs(int v,int len,int width){
if(v==n)return abs(len-dist)&amp;lt;=width ? 0 : 100000;</description>
    </item>
    
    <item>
      <title>SRM 408 DIV1 Middle - CandyGame　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-408-div1-middle---candygame%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Mar 2014 11:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-408-div1-middle---candygame%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8462
有効グラフが存在し、そのノードにコインが２枚以上あれば1枚を消費し、１枚を隣へ移すことができる。
プレイヤーがゲームを行い、ターゲットとなるノードにコインを置くことができれば負けになる。
ターゲットにコインが置かれないような置き方にするとき、置くことのできる最大のコインの数を求める。
解き方 
あるノードにおけるコインの数は、そこから到達できる最大の深さによる。
コインの数は最大の１＜＜（最大の深さー現在の深さ）になるので、重複がないように全てのノードについての和を足す。
ただしターゲットに到達しないノードには好きなだけコインが置けるので、そのようなノードが存在する場合はー１を返す。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int used[60],maxdep[60],n;
vector&amp;lt;string&amp;gt; graph;
class CandyGame {
public:
long long dfs(int depth,int x){
used[x]=1;
maxdep[x]=depth;
long long ret=0;
FORE(i,0,n){
if(graph[x][i]==&#39;Y&#39;&amp;amp;&amp;amp;!used[i]){
ret+=dfs(depth+1,i);</description>
    </item>
    
    <item>
      <title>SRM 254 DIV1 Middle - Piglets　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-254-div1-middle---piglets%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Mar 2014 11:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-254-div1-middle---piglets%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=466
豚小屋があり、すでに豚が入っていない小屋に入っていく。
両端を豚にはさまれるのを嫌がるので、できるだけ避けて入りたい。
左端か右端が空いていれば挟まれないので、そこに入る。
どちらに入っても後に挟まれる確率が同じであれば、左側に入るのを優先する。
豚小屋が与えられた時、次にどの小屋に入ったらよいか答える。
解き方 
問題文より、入る場所をどの優先順位で入ったらよいかがわかる。
①左端が空いていれば左端に入る
②右端が空いていれば右端に入る
③”－－”が続くところがあれば、最も右端に存在するところに入る
④どこに入っても挟まれるので、”ー”が存在する最も左に入る
⑤入るところがないのでー１を返す
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Piglets {
public: int choose(string trough) {
int n=trough.size();
if(trough[0]==&#39;-&#39;)return 0;
if(trough[n-1]==&#39;-&#39;)return n-1;
int ret=0;</description>
    </item>
    
    <item>
      <title>SRM 364 DIV1 Middle - PowerPlants　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-364-div1-middle---powerplants%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 18 Mar 2014 08:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-364-div1-middle---powerplants%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1855
電気で電源が入る植物があり、電源はＯＮになっている他の植物から共有される。
各植物同士のＯＮにする電源量はあらかじめわかっている。
また、現在ＯＮになっている植物もわかっている。
このとき、numPlants本の植物をＯＮにするのに必要な最小の電源量を求める。
解き方 
ｄｐで解く。
状態として、現在ＯＮになっている植物を持っていればよい。
植物はすべてで１６本なので計算量も間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PowerPlants {
public:
int f(char ch){
if(&#39;0&#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&#39;9&#39;)return (int)(ch-&#39;0&#39;);
return (int)(ch-&#39;A&#39;)+10;
}
int minCost(vector&amp;lt;string&amp;gt; connectionCost, string plantList, int numPlants) {</description>
    </item>
    
    <item>
      <title>SRM 338 DIV1 Middle - RandomSwaps　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-338-div1-middle---randomswaps%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 16 Mar 2014 18:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-338-div1-middle---randomswaps%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1540
ある文字列の長さarrayLengthが与えられ、その文字列の任意の２つを選んでswapすることをswapCount数繰り返す。
swapが全て終わったとき、a番目の文字とb番目の文字が一致している確率を求める。
解き方 
a==bのとき、次にa==bとなる確率は
n-1C2 / nC2 = (n-2)/n
a!=bのとき、次にa==bとなる確率は
1/nC2 = 2/n(n-1)
これをswap回数分繰り返したものが答えになる。
コード 
sing namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class RandomSwaps {
public:
double getProbability(int arrayLength, int swapCount, int a, int b) {</description>
    </item>
    
    <item>
      <title>SRM 400 DIV1 Middle -ReversalChain　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-400-div1-middle--reversalchain%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 16 Mar 2014 17:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-400-div1-middle--reversalchain%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=2146
0と１からなる文字列が２つ与えられ、１つ目の文字列を２つ目の文字列に変換したい。
変換する方法として、文字列のi番目とj番目を選ぶことでそのサブ文字列を反対にすることができる。
このとき、文字列を変換するのに最小の変換回数を求める。
ただし、変換できないときはー１を返す。
解き方 
文字列の最初と最後に着目し、そこが同じであればその場所については交換しなくてもよい。
つまり、ｄｆｓを用いて最初が一緒のときはその文字を削除し次の走査に入り、
最後の文字についても同様。
どちらのケースもない場合は交換が必要だが、上記に当てはまらない場合は文字をすべてひっくり返すしか選択しはない。そのためすべてひっくり返し、上記の場合を調べる。
ｄｐの状態はサブ文字列とした箇所とひっくり返したかどうかなので、メモ化することで計算量も間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
map&amp;lt;string,int&amp;gt; m;
class ReversalChain {
public:
int calc(string init,string goal){
if(init==goal)return 0;
int n=init.size();
string str=init+&#39; &#39;+goal;
if(m.find(str)!=m.end())return m[str];</description>
    </item>
    
    <item>
      <title>SRM 149 DIV1 Middle -MessageMess　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-149-div1-middle--messagemess%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 16 Mar 2014 10:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-149-div1-middle--messagemess%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=218
ある文字列を、与えられた辞書中の文字に分割したい。
ただし、分割の方法が複数ある場合は&#34;AMBIGOUS!&#34;、ない場合は&#34;IMPOSSIBLE!&#34;を返す。
解き方 
与えられた文字列をi,jの位置で分割できるかの配列を作り、dpにてどこまで分割できるかを判定する。
複数あるかを判断するのでdpの値を足していくが、intの値をオーバーフローしないように注意が必要。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MessageMess {
public: string restore(vector&amp;lt;string&amp;gt; dictionary, string message) {
set&amp;lt;string&amp;gt; w;
w.clear();
FORE(i,0,dictionary.size())w.insert(dictionary[i]);
int n=message.size();
int can[n+1][n+1];
memset(can,0,sizeof(can));
FORE(i,0,n+1)FORE(j,0,n+1)if(i&amp;lt;j &amp;amp;&amp;amp; w.find(message.substr(i,j-i))!=w.end())can[i][j]=1;
long long dp[n+1];</description>
    </item>
    
    <item>
      <title>SRM 294 DIV1 Middle -Palindromist　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-294-div1-middle--palindromist%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 16 Mar 2014 09:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-294-div1-middle--palindromist%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1201
あるテキストが与えられ、そのテキストは元の回文の前半を切り出したサブ文字列である。
また、辞書に存在する文字列の集合が与えられる。
このとき、元の文字列を辞書に存在する文字列に順に分割したい。
ただし、分割の方法が複数ある場合は辞書順で最も先にくるものを返す。
解き方 
回文は元の文字列の最後の文字を繰り返すものと繰り返さないものの２通りあるため、
この２通りについて分割できるか調べる。
まずは元の文字列をsetに格納してどこからどこまで分割可能か判定する。
次にｄｐを用いて、ｄｐ[n]を最後からn番目の文字まで分割可能であるかどうかを表してあげる。
dp[0]まで漸化式的に走査し、dp[0]が1であれば答えは存在するので、今度は順に判定していき文字列の分割を行う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
set&amp;lt;string&amp;gt; w;
class Palindromist {
public:
string solve(string text){
int n=text.size();
int can[n+1][n+1];
memset(can,0,sizeof(can));
FORE(i,0,n+1)FORE(j,0,n+1)if(i&amp;lt;j &amp;amp;&amp;amp; w.find(text.substr(i,j-i))!=w.end())can[i][j]=1;
int dp[n+1];</description>
    </item>
    
    <item>
      <title>SRM 407 DIV1 Middle -PointsGame　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-407-div1-middle--pointsgame%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 16 Mar 2014 08:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-407-div1-middle--pointsgame%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=2209
(x,y)座標の点が複数存在し、２人のプレイヤーが交互に選んでいく。
最初は自分からスタートし、選んだ点を赤に塗る。次は相手の番に移り、選んだ点を青に塗る。塗る点がなくなったら終了。
スコアは自分の選んだ点と相手の選んだ点全てに対する距離の差になる。
自分はスコアをできるだけ大きくし、相手はできるだけ少なくする。
このとき、自分が得られる最大のスコアを求める。
解き方 
点は１２個と少ないが、自分と相手で戦略が異なるため単純な全探索ではとけない。
そこでｄｐを使い、自分がいままで選んだ点、相手がいままで選んだ点、どちらのターンかを状態に持つ。
自分のターンであればスコアを大きくなる方にＤＦＳを回し、相手のターンであればスコアを小さくなる方にＤＦＳを回せばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
double p[13][13];
int n;
vector&amp;lt;int&amp;gt; px,py;
map&amp;lt;pair&amp;lt;int,int&amp;gt;,double&amp;gt; m;
class PointsGame {
public:
double f(double x1,double y1,double x2,double y2){
return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</description>
    </item>
    
    <item>
      <title>SRM 349 DIV1 Middle -DiceGames　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-349-div1-middle--dicegames%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 16:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-349-div1-middle--dicegames%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1669
サイコロが複数与えられる。
各サイコロは、いくつまでの目をもっているかあらかじめわかっている。
このとき、すべてのサイコロの目の出方の組み合わせは何通りあるか求める。
ただし、サイコロの区別はしない。
解き方 
サイコロを、もつ目の数の昇順にソートする。
左から、１から始まりそれ以降の組み合わせをその数以上、としてｄｐで回せば重複なく答えが求められる。
メモ化が必要なので、現在のサイコロの場所と前のサイコロの目を状態としてもてば計算量は間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int n;
vector&amp;lt;int&amp;gt; sides;
long long dp[40][40];
class DiceGames {
public:
long long rec(int pos,int cnt){
if(pos==n)return 1;
if(dp[pos][cnt]!=-1)return dp[pos][cnt];</description>
    </item>
    
    <item>
      <title>SRM 295 DIV1 Middle -JimmyLightning　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-295-div1-middle--jimmylightning%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 15:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-295-div1-middle--jimmylightning%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1193
銀行強盗がおり、できるだけ多くのダイヤを持って帰りたい。
各部屋は隣り合った扉があり、最初の部屋のみ入り口の扉がある。
また、部屋番号と宝の価値、宝を盗むのに必要な時間が与えられる。
合わせて、各部屋ごとに滞在できる時間も与えられる。
このとき、できるだけ多くの宝を持って部屋をでることのできたときの最大の宝の価値の和を求める。
解き方 
各部屋はつながっており、最後には部屋を出ないといけない。
この条件より、各部屋については前の部屋のうち一番短い滞在時間しか、滞在することはできない。
また問題文より、各部屋には一つの宝ではなく、複数種類の宝が存在しているところに注意。
各時刻においてｄｐで走査し、最後に一番高い価値の値を返す。
ここも最後の時間が一番高い価値ではないことに注意。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class JimmyLightning {
public:
int robTheBank(vector&amp;lt;int&amp;gt; doors, vector&amp;lt;string&amp;gt; diamonds) {
int n=doors.size();
FORE(i,1,n)doors[i]=min(doors[i],doors[i-1]);
vector&amp;lt;pair&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt; &amp;gt; &amp;nbsp;p;</description>
    </item>
    
    <item>
      <title>SRM 248 DIV1 Middle -ContractWork　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-248-div1-middle--contractwork%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 14:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-248-div1-middle--contractwork%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=795
プレイヤーはこなさなければいけない、複数の仕事をかかえている。
この仕事を外部の会社に委託してすべてこなしたい。
それぞれの会社は各タスクを遂行するのに必要な金額は異なり、あらかじめのその金額はわかっている。
プレイヤーはどの会社に何度でも依頼することはできるが、連続して２つまでしか依頼できたい。
このとき、全ての仕事をこなすのに必要な最小コストを求める。
解き方 
ｄｐを適用する。
各仕事において、直前に依頼した会社とその会社に何回連続して依頼したかの状態を持っておけば計算量は間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[60][60][3],company[60][60],n,comp;
class ContractWork {
public:
int calc(int pos,int prev,int num){
if(pos==n)return 0;
if(dp[pos][prev][num]!=-1)return dp[pos][prev][num];
int ret=1e+9;
FORE(i,0,comp){
if(i!=prev)ret=min(ret,company[i][pos]+calc(pos+1,i,1));
else if(i==prev&amp;amp;&amp;amp;num&amp;lt;2)ret=min(ret,company[i][pos]+calc(pos+1,i,num+1));</description>
    </item>
    
    <item>
      <title>SRM 228 DIV1 Middle -BagsOfGold　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-228-div1-middle--bagsofgold%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 13:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-228-div1-middle--bagsofgold%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=768
ゴールドの山が順に並んでいる。
あらかじめ、それぞれの山にどれだけゴールドがあるかわかっている。
２人でこのゴールドの山の取りあいを行い、最初は自分のターン。
左端か右端のいずれかを選び、相手のターンに移る。
どちらも最適な選択をしたとき、自分が得られるゴールドと相手が得られるゴールドの差の最大値を求める。
解き方 
ｄｐの問題だが、自分のターンと相手のターンで選び方が異なる。
ターンの区別をなくし、次のターンは必ず相手は最善の選び方をすると考える。
そうすると、左端を選んだときに左端のスコアから相手が得られる最大のゴールドを引いたものと、右端を選んだときに右はじのスコアと相手から得られる最大のゴールドを引いたもののうち、最大のものを返してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
vector&amp;lt;int&amp;gt; b;
int dp[51][51];
class BagsOfGold {
public:
int calc(int left,int right){
if(left==right)return b[left];
if(dp[left][right]!=-1)return dp[left][right];
return dp[left][right]=max(b[left]-calc(left+1,right),b[right]-calc(left,right-1));
}</description>
    </item>
    
    <item>
      <title>SRM 320 DIV1 Middle -ContestSchedule　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-320-div1-middle--contestschedule%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 09:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-320-div1-middle--contestschedule%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1405
複数のプログラミングコンテストが開催され、各コンテストについて開始時間s、終了時間t、勝率pが与えられる。
プレイヤーはできるだけ多くのコンテストで勝ちを収めたい。ただし、時間が重複しているコンテストには出ることができない。
このとき、最も勝ちを収めることができたときの勝数を求める。
解き方 
サンプルを見ると、重複していない限りはできるだけ多くのコンテストに出場した方がよいことがわかる。
開始時間でソートし、該当コンテストにおいて最も勝数が高い場合は、その一つ前までの最適な勝数がわかっていれば求めることができる。
これを利用して、漸化式でｄｐを解く。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ContestSchedule {
public:
double expectedWinnings(vector&amp;lt;string&amp;gt; contests) {
int n=contests.size();
vector&amp;lt;pair&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt; &amp;gt; p(n);
FORE(i,0,n){
stringstream out(contests[i]);
out&amp;gt;&amp;gt;p[i].first&amp;gt;&amp;gt;p[i].second.first&amp;gt;&amp;gt;p[i].second.second;
}
sort(all(p));
int dp[60];</description>
    </item>
    
    <item>
      <title>SRM 299 DIV1 Middle -PalindromePartition　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-299-div1-middle--palindromepartition%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 15 Mar 2014 08:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-299-div1-middle--palindromepartition%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1160
A~Zからなる文字列がある。
これをサブ文字列に分割して各サブ文字列が回文になるようにしたい。
このときの最小のサブ文字列の数を求める。
解き方 
２段階でｄｐを適用する。
最初は各文字について、そこからどの長さまで回文になるかをｄｐで求める。
最後に、そのｄｐを使って最小のサブ文字列の数を求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int can[2501][2501];
class PalindromePartition {
public:
int partition(vector&amp;lt;string&amp;gt; s) {
string str=&#34;&#34;;
FORE(i,0,s.size())str+=s[i];
int n=str.size();
memset(can,0,sizeof(can));
FORE(i,0,n)can[i][1]=1;
FORE(i,0,n-1)can[i][2]=(str[i]==str[i+1]);
FORE(len,3,n+1)FORE(i,0,n-len+1){
can[i][len]=(str[i]==str[i+len-1] &amp;amp;&amp;amp; can[i+1][len-2] );</description>
    </item>
    
    <item>
      <title>SRM 229 DIV1 Middle -BusinessPlan　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-229-div1-middle--businessplan%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 14 Mar 2014 08:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-229-div1-middle--businessplan%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
様々な商品が存在し、各商品についてexpenseの金額を投資するとptime後にrevenueの収入が得られることがわかっている。
最初にＣ円持っており、これをＤ円にしたいとき、最短でかかる時間を求める。
ただし、そのような場合がないときはー１を返す。
解き方 
ｄｐを漸化的に更新していく問題。
ptimeは最大10であり、Dは最大10^5であるため、
dpのサイズを10^6確保して各時間における最大の所持金額を逐次更新していく。
最後に、最初にDを超える時間を返してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BusinessPlan {
public:
int howLong(vector&amp;lt;int&amp;gt; expense, vector&amp;lt;int&amp;gt; revenue, vector&amp;lt;int&amp;gt; ptime, int C, int D) {
int n=expense.size();
if(C&amp;gt;=D)return 0;
int dp[100001];</description>
    </item>
    
    <item>
      <title>SRM 275 DIV1 Middle -Horoscope　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-275-div1-middle--horoscope%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 14 Mar 2014 07:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-275-div1-middle--horoscope%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1090
占い師がうらなった、今後数日間の良い日、悪い日のリストがある。
リストは配列で与えられ、良い日は&#39;G&#39;、悪い日は&#39;B&#39;で表わされる。
しかし、その占いは連続でR日間は当たるが、連続でB日間は外れる。
このとき、最も良い日が続く時の、良い日の日数を求める。
解き方 
ｄｐで解く問題。
リストは最大で2500、R,Bは最大50であるので、
リストの長さと現在までに続いているRの長さ、Bの長さを状態としてもっておけば計算量O(2500*50*50)として間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[2510][2][60];
class Horoscope {
public:
int maxGoodDays(vector&amp;lt;string&amp;gt; predictions, int R, int W) {
string str=&#34;&#34;;
FORE(i,0,predictions.size())str+=predictions[i];
int n=str.size();
memset(dp,0,sizeof(dp));</description>
    </item>
    
    <item>
      <title>SRM 159 DIV1 Middle -  ThePriceIsRight　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-159-div1-middle----thepriceisright%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 14 Mar 2014 00:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-159-div1-middle----thepriceisright%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=328
商品の価格の一覧が与えられる。
最初はすべて伏せられていて金額がいくらかわからない。
ここで、プレイヤーは任意の数だけ伏せられている数をめくり、めくったものが昇順に並んでいるようにしたい。
このとき、昇順となる一番最長のめくった数とその場合の数を求める。
解き方 
単純なｄｐでは数字が１０＾６であるため解けないので、少し工夫したｄｐを使う。
ｄｆｓによる降順からの探索ではなく、漸化式のように順に最適値を求めていき、すでに求まっている最適値からその位置での最適値を求めるようにする。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ThePriceIsRight {
public: vector&amp;lt;int&amp;gt; howManyReveals(vector&amp;lt;int&amp;gt; prices) {
int n=prices.size();
int len[n],cnt[n];
memset(len,0,sizeof(len));
memset(cnt,0,sizeof(cnt));
FORE(i,0,n){
int maxlen=0;
FORE(j,0,i)if(prices[i]&amp;gt;prices[j])maxlen=max(maxlen,len[j]);
FORE(j,0,i)if(len[j]==maxlen&amp;amp;&amp;amp;prices[i]&amp;gt;prices[j])cnt[i]+=cnt[j];
if(maxlen==0)cnt[i]=1;
len[i]=maxlen+1;</description>
    </item>
    
    <item>
      <title>LinuxでCPUやメモリ使用状況のログを取る方法</title>
      <link>https://chaingng.github.io/post/linux%E3%81%A7cpu%E3%82%84%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%B3%81%E3%81%AE%E3%83%AD%E3%82%B0%E3%82%92%E5%8F%96%E3%82%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 12 Mar 2014 19:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%A7cpu%E3%82%84%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%B3%81%E3%81%AE%E3%83%AD%E3%82%B0%E3%82%92%E5%8F%96%E3%82%8B%E6%96%B9%E6%B3%95/</guid>
      <description>Linux(使っているのはRedhat Enterprise Linux 6.3)でCPU負荷とメモリ使用状況のログを取る必要があったので使い方をメモ。
①CPU使用率とメモリ使用状況の表示
vmstatを使うことでCPU・メモリ使用率のログが取ることができる。
5秒間隔で３回ログを取りたいときは、以下のように引数を指定する。
$vmstat 5 3
②時刻情報の表示
使用率の分析にはいつ出力されたかが知りたいと思うので、時刻と紐づけたいことが多いと思う。これはpipとawkを使うことで実現する。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 }&#39;
awkで時刻情報を出力させた後、現在の行(vmstat)を出力させている。
これで１秒間隔で、年／月／日　hh:mm:sssの時刻情報と紐づけて出力することができる。
③ログへの出力
実は上記のコマンドの標準出力をログに出そうとしても出力されない。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 }&#39;　&amp;gt;&amp;gt; sample.log
これは、pipの後ろの処理が終了してからバッファに保存してある情報をファイルに書き込みむため。
そのため、system()関数を用いてバッファをリフレッシュする。
vmstat 1 | awk &#39;{ print strftime(&#34;%Y/%m/%d %H:%M:%S&#34;), $0 } {system(&#34;&#34;)}&#39;　&amp;gt;&amp;gt; sample.log
こちらに詳細な解説が。
http://www.kt.rim.or.jp/~kbk/gawk-30/gawk_13.html
これでやっと、途中でコマンドを終了させてもログに書き込まれているようになる。
 </description>
    </item>
    
    <item>
      <title>SRM 253 DIV1 Middle - AlphabetCount　（復習××）</title>
      <link>https://chaingng.github.io/post/srm-253-div1-middle---alphabetcount%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 12 Mar 2014 08:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-253-div1-middle---alphabetcount%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=975
アルファベットＡ～Ｚからなる配列が与えられる。
長さlengthが与えられ、このときAを長さ1とし、B,C,,,と長さ分の連続したアルファベットを作りたい。
連続したアルファベットを作る際には、配列の任意の文字からスタートして、縦横斜めに一つずつ移動することができる。
このとき、作ることのできる連続したアルファベットは何通りあるか求める。
ただし、１０＾９通り以上ある場合は１０＾９を返す。
解き方 
ｄｐで解く問題。ただし、１０＾９を超えているかチェックし超えていればそこで打ち切る処理が必要。
ｄｐ＝０で初期化すると実装はより簡単だが、探索して何もなかったときの判定ができないので計算量が間に合わない場合がある。
そのため、ｄｐ＝ー１で初期化して探索済みの場合は０以上になるようにした。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int length,w,h;
int p[60][60];
long long dp[60][60];
class AlphabetCount {
public:
int rec(int r,int c,int len){
if(dp[r][c]!=-1)return dp[r][c];
if(len==length-1)return dp[r][c]=1;</description>
    </item>
    
    <item>
      <title>SRM 259 DIV1 Middle - SuperString　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-259-div1-middle---superstring%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Mar 2014 22:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-259-div1-middle---superstring%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1005
文字列が与えられたとき、その文字列中１回しか出現しないアルファベットの和がその文字列のスコアになる。
ある文字列が与えられた時、スコアが最も大きくなるサブ文字列を求める。
ただし同じスコアの場合は、アルファベットの昇順のものを返す。
解き方 
コーディングは単純だが、単純に実装するとO（2500^3）計算量が間に合わない。
そこで、最初に最も高いスコアがいくつであるか走査する。
スコアがわかった後にもう一度走査させて、最大のスコアのもののみ文字列が昇順であるかの判定を行う。
これにより計算量がＯ（2*2500^2）とオーダーが一つ下がるので時間内に解くことができる。
オーダーを線形に変換できるかがポイント。
実装するときに細かく計算量を見積もらないと、システムテストで失敗してしまう。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SuperString {
public:
string goodnessSubstring(vector&amp;lt;string&amp;gt; superstring) {
string str=&#34;&#34;;
FORE(i,0,superstring.size())str+=superstring[i];
int best=0;
FORE(i,0,str.size()){
int check[26]={},cnt=0;
FORE(j,i,str.size()){
if(check[str[j]-&#39;A&#39;]==0)cnt++;</description>
    </item>
    
    <item>
      <title>SRM 301 DIV1 Middle - EscapingJail　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-301-div1-middle---escapingjail%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Mar 2014 20:49:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-301-div1-middle---escapingjail%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1248
各囚人がペアで鎖でつながれている。
ただし、囚人のペアによっては鎖でつながれていない。
ここで、つながれている鎖それぞれの長さがわかっている。
このとき、２人の囚人が最も離れることのできる距離を求める。
ただし、つながれていない場合はー１を返す。
解き方 
囚人aと bの距離は、その他の囚人xに対してa-b &amp;lt;=a-x+x-bでなければいけない。
この距離は小さい方から決まっていくので、鎖の長さ０から最大の長さそれぞれに対して
上記の式を満たすよう長さを更新していき、最後に残った最も長い距離を返してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int p[60][60];
class EscapingJail {
public:
int calc(char ch){
if(ch==&#39; &#39;)return 1e+9;
if(&#39;0&#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&#39;9&#39;)return (int)(ch-&#39;0&#39;);
if(&#39;a&#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&#39;z&#39;)return (int)(ch-&#39;a&#39;)+10;</description>
    </item>
    
    <item>
      <title>SRM 413 DIV1 Middle - InfiniteSequence2　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-413-div1-middle---infinitesequence2%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Mar 2014 20:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-413-div1-middle---infinitesequence2%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9922&amp;amp;rd=13504
X[n]=X[n/p-x]+X[n/q-y]となる関数がある。
ただし、n&amp;lt;=0のときX[n]=1となる。
ｎが与えられたとき、X[n]がいくつになるか求める。
解き方
nは１０＾１３なので全探索では解けない。
ｄｐを利用した場合でも、10^13のメモリ空間は使えないのでメモリ量としても解くことができない。
ここで、関数の性質からnが小さいほどメモ化が有効になることが想定される。
そのため、メモリ量として保存できるだけはメモ化して、それより大きい数については単純にＤＦＳすることでメモリ量も計算量も抑えて解くことができる。
最初はmapを使っていたが動的にメモリを確保するデータ構造ではエラーが起きてしまうので、単純にlong long型で最初からメモリを確保しておく。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int p,q,x,y;
long long dp[5000001];
class InfiniteSequence2 {
public:
long long f(long long n){
if(n&amp;lt;=0)return 1;
if(n&amp;lt;=5000000&amp;amp;&amp;amp;dp[n]!=0)return dp[n];
long long a=n/p-x,b=n/q-y;</description>
    </item>
    
    <item>
      <title>SRM 288 DIV1 Middle - CannonBalls　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-288-div1-middle---cannonballs%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Mar 2014 08:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-288-div1-middle---cannonballs%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1154
１個、２個、３個・・・とボールを三角形上に積み重ねていく。
このときに内部に存在する三角形は１，４、１０個・・・になる。
Ｎ個を内部に存在する三角形の数の和で現したいとき、
最低何個の三角形が必要になるか求める。
解き方 
まず、内部に存在する三角形の個数をＮまで全て調べる。
その後ｄｐを利用する。
今回Ｎは最大３＊１０＾５なので、ｄｐの全探索で間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CannonBalls {
public: int fewestPiles(int n) {
vector&amp;lt;int&amp;gt; p;
for(int x=0,cur=0,add=0;cur&amp;lt;=n;x++){
add+=x;
cur+=add;
p.push_back(cur);
}
int dp[n+1];
FORE(i,0,n+1)dp[i]=1e+9;
dp[0]=0;</description>
    </item>
    
    <item>
      <title>SRM 212 DIV1 Middle - SumOfSquareRoots　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-212-div1-middle---sumofsquareroots%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Mar 2014 17:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-212-div1-middle---sumofsquareroots%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2943&amp;amp;rd=5858
正の整数の集合が与えられ、この数の平方根を考える。
この平方根に対して足すことができるものを全てまとめて、最後に昇順にして返す。
解き方 
全ての平方根に対して整数を切り出して、根が一緒のものをまとめる。
最後に切り出した整数をまた根の中に戻してあげて、昇順にソートすればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[1001];
class SumOfSquareRoots {
public:
vector&amp;lt;int&amp;gt; shortestList(vector&amp;lt;int&amp;gt; A) {
memset(dp,0,sizeof(dp));
FORE(i,0,A.size()){
int x=A[i];
int cost=1;
for(int j=2;j*j&amp;lt;=A[i];j++){
if(x%(j*j)==0){
while(x%(j*j)==0){
cost*=j;
x/=(j*j);
}</description>
    </item>
    
    <item>
      <title>SRM 205 DIV1 Middle - HexagonalSums　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-205-div1-middle---hexagonalsums%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Mar 2014 17:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-205-div1-middle---hexagonalsums%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2921&amp;amp;rd=5851
６面体を左下が重なるように順に大きいものを重ねていく。
そのときの点の数は１、６，１８，２５，４５，６６・・・となる。
また、正の整数Ｎが与えられた時、これを上記の数の組み合わせで表現したい。
どのＮであっても６個以下の組み合わせで表現することができ、
Ｎ＝２６のときが６個の組み合わせの最大数、
Ｎ＝１３０のときが５個の組み合わせの最大数、
Ｎ＝１４６８５８のときが４個の組み合わせの最大数になる。
Ｎが与えられた時、組み合わせる６面体の数の最小の個数を求める。
解き方 
Ｎが１３０以下のときはｄｐで全探索を用いる。
それ以上のときは６面体全てのペアの組み合わせの値を求め、さらにその組み合わせでＮを表現することで、４個以下の組み合わせになるので答えが求まる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[1000001];
class HexagonalSums {
public:
int minLength(int N) {
vector&amp;lt;int&amp;gt; v;
int prev=1;
for(int x=2;prev&amp;lt;=1000000;x++){
v.push_back(prev);</description>
    </item>
    
    <item>
      <title>SRM 477 DIV1 Middle - PythTriplets　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-477-div1-middle---pythtriplets%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Mar 2014 11:37:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-477-div1-middle---pythtriplets%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10766&amp;amp;rd=14157
以下の条件を満たす３角形を考える。
・３辺a,b,cがすべて整数
・a^2+b^2=c^2
・a,bの最大公約数が1
また辺の集合が与えられ、この中からできるだけ多く(a,b)のペアを作りたい。
このとき、(a,b)のペアの最大数を求める。
解き方 
a,bの最大公約数が1であるということは、片方が奇数で片方が偶数になる。
仮に両方とも偶数であれば最大公約数は2以上になり、
両方とも奇数であればa^2+b^2=c^2が成り立たない。
上記より奇数のグループと偶数のグループからペアの最大数を見つける問題になるので
２部マッチングが適用できる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int edge[2600][2600],visited[2600],to[2600],ret,n;
class PythTriplets {
public:
bool dfs(int x){
if(x==-1)return true;
if(visited[x])return false;
visited[x]=true;
FORE(i,0,n){
if(edge[x][i]&amp;amp;&amp;amp;dfs(to[i])){</description>
    </item>
    
    <item>
      <title>SRM 312 DIV1 Middle - AntarcticaPolice　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-312-div1-middle---antarcticapolice%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Mar 2014 09:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-312-div1-middle---antarcticapolice%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6501&amp;amp;rd=9992
都市Antarcticaにポリスステーションを建てたい。
Antarcticaには複数の町があり、それぞれの町にポリスステーションを建てた時のコストがあらかじめわかっている。
ただし全ての町にポリスステーションを建てる必要はなく、その他のポリスステーションからその町に行くことができれば必要ない。
また、各町について一方通行でつながっているかどうかの情報も与えられる。
このとき、１つのポリスステーションを建てた時の平均コストが最小になるときの値を求める。
解き方 
無向グラフではなく有向グラフの問題。
強連結である部分集合を求め、その他の集合からたどりつけない集合であればその部分集合から最小のコストを足す必要がある。
最後に、選ばれていない町のコストについて、平均が低くなるものについてのみコストを足してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AntarcticaPolice {
public:
double minAverageCost(vector&amp;lt;int&amp;gt; costs, vector&amp;lt;string&amp;gt; roads) {
int n=costs.size();
bool p[n][n];
FORE(i,0,n)FORE(j,0,n)p[i][j]=(roads[i][j]==&#39;Y&#39;);
FORE(i,0,n)p[i][i]=1;
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)p[i][j]|=(p[i][k]&amp;amp;&amp;amp;p[k][j]);
int G=0,root[n];</description>
    </item>
    
    <item>
      <title>SRM 223 DIV1 Middle - PrimeAnagrams　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-223-div1-middle---primeanagrams%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 21:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-223-div1-middle---primeanagrams%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
数字の文字列が与えられる。
そこから全ての数字を好きに組み合わせて、３つの素数を作る。
３つの素数が複数通り作れるのであれば、その積が最も小さいものを返す。
解き方 
数字の数は最大８つなので、全探索で解くことができる。
すべての数字のpermutationに対し、全ての区切りで３つの数を作り、それが全て素数であるか判定すればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PrimeAnagrams {
public:
bool isprime(int x){
if(x==2)return true;
if(x==1||x%2==0)return false;
for(int i=3;i*i&amp;lt;=x;i+=2)if(x%i==0)return false;
return true;
}
int calc(vector&amp;lt;int&amp;gt; num,int start,int end){
int x=0,p=1;</description>
    </item>
    
    <item>
      <title>SRM 227 DIV1 Middle - TreeSpreading　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-227-div1-middle---treespreading%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 20:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-227-div1-middle---treespreading%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
a,b,c,dの４種類の木を並べて植えたい。
ただし、隣り合う木は必ず別の種類にしたい。
それぞれの植えられる木の本数が与えられるとき、木の植え方が全部で何通りあるか求める。
解き方 
ｄｐで解けそうな問題。
状態は前に植えた木、各種類の木についてあと何本植えられるかがわかればよい。
メモ化を使って全ての状態を洗い出し、最後に問題文で与えられた本数についての答えを返してあげる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TreeSpreading {
public:
long long countArrangements(int a, int b, int c, int d) {
if(a+b+c+d==0)return 1;
long long dp[4][11][11][11][11]={};
dp[0][1][0][0][0]=1;
dp[1][0][1][0][0]=1;</description>
    </item>
    
    <item>
      <title>SRM 371 DIV1 Middle - ChessMatchup　（復習○）</title>
      <link>https://chaingng.github.io/post/srm-371-div1-middle---chessmatchup%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 15:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-371-div1-middle---chessmatchup%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1718
それぞれN人で構成される2つのチームが、団体戦でチェスの試合を行う。
試合はＮ回行われ、各試合は各チームのメンバ１対１で行われる。
各メンバは１試合しか出場できない。
試合については強い方のメンバのチームが２点加算され、同じ強さの場合は各チーム１点が加算される。
ここで自分のチームについては全メンバーの強さがわかっており、また相手の全メンバーの強さもわかっている。
このとき、自分のチームが得られる最も高いスコアを求める。
解き方 
まずは各チームの強さを昇順にソートする。
自分のチームは弱い方から選んでいき、
相手の最も強いメンバに勝てるとき→そのメンバと対戦してスコア＋２
相手の最も弱いメンバに勝てるとき→そのメンバと対戦してスコア＋２
がもっともよい戦術であることがわかる。
ただし、上記のどれとも一致しない場合は
相手の最も強いメンバと弱いメンバ、どちらと対戦して良いかはその場で判断できない。
そのため、この２通りについてｄｐを回して高い方のスコアを採用すればよい。
ｄｐは６０＾３であるため十分に間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int n,dp[60][60][60];
vector&amp;lt;int&amp;gt; us,them;
class ChessMatchup {
public:
int f(int pos,int left,int right){</description>
    </item>
    
    <item>
      <title>SRM 411 DIV1 Middle - HoleCakeCuts　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-411-div1-middle---holecakecuts%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 14:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-411-div1-middle---holecakecuts%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9752&amp;amp;rd=12183
座標(0,0)を中心として、１辺の長さがcakeLength*2であり、中心の穴がholeLength*2であるケーキが存在する。
このケーキを、あらかじめ与えられたy軸に平行なカットとx軸に平行なカットを行ったときに最終的に残るカットされたケーキの数を求める。
解き方 
(0,0)が中心というのを最初見落としてしまい、時間がかかってしまった。
(0,0)→(cakeLength,cakeLength)となるように座標変換して
左上が(0,0)にくるようにして、各カットのまとまりごとにdfsを回して答えを求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int used[200][200],vcut[200],hcut[200],n;
class HoleCakeCuts {
public:
void dfs(int i,int j){
if(used[i][j])return;
used[i][j]=1;
if(i&amp;gt;0&amp;amp;&amp;amp;!vcut[i-1])dfs(i-1,j);
if(i&amp;lt;n-1&amp;amp;&amp;amp;!vcut[i])dfs(i+1,j);
if(j&amp;gt;0&amp;amp;&amp;amp;!hcut[j-1])dfs(i,j-1);
if(j&amp;lt;n-1&amp;amp;&amp;amp;!hcut[j])dfs(i,j+1);
}
int cutTheCake(int cake, int hole, vector&amp;lt;int&amp;gt; h, vector&amp;lt;int&amp;gt; v) {</description>
    </item>
    
    <item>
      <title>SRM 266 DIV1 Middle - ZCurve　（復習×○）</title>
      <link>https://chaingng.github.io/post/srm-266-div1-middle---zcurve%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 09:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-266-div1-middle---zcurve%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=1036
一辺が2^Nからなるセルの集合が与えられる。
セルの値は左上の0から始まり、ｚを描くように１ずつ増えていく。
N=1 のとき
0 1
2 3
N=2のとき
&amp;nbsp;0 &amp;nbsp;1 &amp;nbsp; &amp;nbsp; 4 &amp;nbsp;5
&amp;nbsp;2 &amp;nbsp;3 &amp;nbsp; &amp;nbsp; 6 &amp;nbsp;7
&amp;nbsp;8 &amp;nbsp;9 &amp;nbsp; 12 13
10 11 14 15
Nと行番号、列番号(r,c)が与えられた時、
その(r,c)にある数字を求める。
解き方 
Nから1までセルを４等分していって、どの位置にあるかを特定していけばよい。
N=2の例を場合に考える。
move=2^(N-1)=2とすると、
rもcもmove未満のときは左上、cのみmove以上のときは右上、
rのみmove以上のときは左下、そうでなければ右下の位置になる。
また、score=4^(N-1)=4とすると、
右上のときは＋score、左下のときは+score*2、右下のときは+score*3してあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).</description>
    </item>
    
    <item>
      <title>SRM 353 DIV1 Middle - PlatformJumper　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-353-div1-middle---platformjumper%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Mar 2014 08:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-353-div1-middle---platformjumper%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7847&amp;amp;rd=10710
x,y座標上に複数のプラットフォームがあり、各プラットフォームには任意の数のコインが存在する。
また、走る速さvと重力加速度gが与えられ、時間tあたりt*t*g/2の速さで落下していく。
プレイヤーは、走る速さvが足りていれば高いプラットフォームから低いプラットフォームへ移動することができる。
任意のプラットフォームからスタートできるとき、得られる最大のコインを求める。
解き方 
ｄｐで解ける問題。
あるプラットフォームiに対して、そこから到達できる全てのプラットフォームのdp[j]のうち最大の値とプラットフォームiにあるコインの数の和がdp[i]になる。
届くか届かないかの判定の関数は、式を変形することでできるだけ割り算を少なくすることが誤差を小さくするポイント。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[60],n,v,g;
vector&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt; &amp;gt; p;
class PlatformJumper {
public:
int f(int pos){
if(dp[pos]!=-1)return dp[pos];
if(pos==n)return 0;
int x=p[pos].first.second,y=p[pos].first.first,score=p[pos].second;
int ret=score;</description>
    </item>
    
    <item>
      <title>SRM 510 DIV1 Middle - TheLuckyGameDivOne　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-510-div1-middle---theluckygamedivone%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 05 Mar 2014 08:37:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-510-div1-middle---theluckygamedivone%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11463
4と７からなる数字をluckynumberと呼ぶ。
数字の範囲a&amp;lt;=x&amp;lt;=bであるa,bが最初に与えられ、JohnとBrusでゲームを行う。
最初はJohnのターンであり、jLenの長さだけ連続した数字を選ぶ。Johnはできるだけ最終的にluckynumberが多く含むようにしたい。
次はBrusのターンであり、Johnが選んだ数字からbLenの長さだけ連続した数字を選ぶ。Brusはできるだけluckynumberを少なく含むようにしたい。
このとき、Johnが得ることのできるもっとも多いluckynumberの数を求める。
解き方 
数の範囲が10^10なので全探索では解けない。
ここで、luckynumberに着目するとその数は2^11になるので、luckynumberをからめて考えることができれば解けるようになる。
次に、luckynumberとからめてどうすればJohnができるだけ多くの数字を得られて、Brusができるだけ少ない選び方ができるかを考える。
Johnについてはluckynumber-blen+1から初めて数字を取り始めれば最も多く数字をとることができる。
Brusはluckynumber+1から初めて数字を取り始めれば最も少なく数字をとることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
long long blen;
vector&amp;lt;long long&amp;gt; luckynum;
int n;
class TheLuckyGameDivOne {
public:
void getnum(long long a,long long b,long long x){</description>
    </item>
    
    <item>
      <title>SRM 515 DIV1 Middle - NewItemShop　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-515-div1-middle---newitemshop%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 03 Mar 2014 22:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-515-div1-middle---newitemshop%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11508&amp;amp;rd=14540
売り物である剣を任意の数持っており、複数の顧客が訪れる。
各顧客について、&#34;時間、買う値段、来る確率&#34;で表わされる情報が複数個与えられる。
ただし、一人の顧客について１つの剣しか売ることができない。
このとき、得られる収益の最大値を求める。
解き方 
ぱっと見てｄｐで解けそう。
どうｄｐを適用するかが問題。
問題文から読みとると時系列の処理が必要なので、時間ごとに処理を行っていく。
次に、各顧客について訪れたか訪れていないかの情報を保存しようとすると２＾２４で発散するため難しい。
ただし、どの顧客を選ぶかの情報であれば２４Ｃ１２のため２＊１０＾６程度になる。
さらに、一度しか訪れない顧客は２度現れないことから情報を保存しなくてもよいので計算量が削減できる。よって、２度以上現れる顧客のみINDEXを順につけてあげる。
上記より、「時間、現在の剣の在庫、すでに選んだ顧客の情報」を元にｄｐを回せばよい。
訪れる顧客は最大で２４人、うち複数回訪れる顧客は最大１２人のため、２＾１２分のビットマスクで足りる。
ｄｐでは、
①その時間に既に現れた顧客であれば時間のみ進め、
②まだ現れていない顧客でありその時間にも現れなければ、現れない確立をかけて進め、
③現れた場合であれば、その顧客に売ったときもしくは売らないときの最大の値をとってあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int N[24],M[24];
double P[24],dp[26][24][5000];
class NewItemShop {
public:
double f(int swords,int hour,int mask){</description>
    </item>
    
    <item>
      <title>SRM 534 DIV1 Middle - EllysNumbers　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-534-div1-middle---ellysnumbers%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Mar 2014 23:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-534-div1-middle---ellysnumbers%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11787&amp;amp;rd=14727
エリーが好きな数であるｎが存在する。
ここで、複数の数が与えられ、その中から任意の数選んだ数字の積がｎになるようにしたい。
ただし、選んだ数字それぞれは約数を持たない数でなければいけない。
このとき、選んだ数字の積がｎとなる選び方の場合の数を求める。
解き方 
問題文で最初見落としたが重要なところは、選んだ数字それぞれは約数を持たない数であるということ。
つまり、N=x^i * y^j *z^k　で表わせるとき、
x,y,zではなく、x^i , y^j , z^kを最小単位の固まりとして考えることができる。
記を最小単位の固まりとして考えるとき、
与えられた数字xはnで割り切れ、かつn/xはxとの最大公約数が１でなければならない。
これに従って、まずは候補の数字を洗い出す。
次に、洗い出した候補の数字に対して最大公約数で割っていき、１にならなければ答えが存在しないので０を返す。
ここで洗い出した候補の数字に対して、その素因数がｎの素因数でもあるので
どの素因数からなるかのビットマスクを作成する。
ビットマスクを作成後、ｄｐを回してすべてのビットマスクが１となるものが答えとなる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EllysNumbers {
public:
long long gcd(long long x,long long y){</description>
    </item>
    
    <item>
      <title>SRM 531 DIV1 Middle - MonsterFarm　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-531-div1-middle---monsterfarm%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Mar 2014 23:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-531-div1-middle---monsterfarm%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11232&amp;amp;rd=14724
各ノードごとに、次に変換するノードが与えられる。
次に変換するノードは１つ以上になる。
ノード０からスタートするとき、最後に収束するノード数を求める。
ただし、ノード数が発散するときはー１を返す。
解き方 
グラフを利用する。
次に変換するノードが複数存在するので、
単純に連結しているかのグラフと次につながるエッジ数を表わす２つのグラフを利用する。
単純な連結グラフは発散するかの判定に用いワーシャルフロイドをかけて各ノード間の連結を確かめる。
自分から出るノードが２個以上かつループが存在するときに発散する。
次につながるエッジ数のグラフは答えを求めるのに用い、
ノード数分のステップを最低繰り返してノード数を収束させる。
答えは各ステップごとに各ノードの数を保存し、全回保存したノード数から足していき更新させればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MonsterFarm {
public: int numMonsters(vector&amp;lt;string&amp;gt; transforms) {
int a[55][55]={},b[55][55]={};
int n=transforms.size(),MOD=1000000007;
FORE(i,0,n){
int x;</description>
    </item>
    
    <item>
      <title>SRM 522 DIV1 Middle - CorrectMultiplication　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-522-div1-middle---correctmultiplication%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Mar 2014 14:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-522-div1-middle---correctmultiplication%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11604&amp;amp;rd=14547
正の整数a,b,cが与えられる。
正の整数A,B,Cがa,b,cをそれぞれ増減した値であるとき
A*B=Cが成り立つ、|A-a|+|B-b|+|C-c|の最小値を求める。
解き方 
Cの値の最大値がわからないと手掛かりがないため、まずはCの最大値を求める。
答えは|A-a|+|B-b|+|C-c|であることから最小である答えが1*1=1であるとき
答えの最大値はa+b+c-3となる。
つまり、Cの最大値はc+a+b+c-3となる。
次に、Aを１から調べていく。
Ｂも同様に調べることで対称性があるので、ＡはＡ＊Ａ＜＝Ｃの最大値まで調べればよい。
Ａが決まったとき、Ｂはc/Aの±１の範囲で最適なCが存在するのでそれぞれの場合について|A-a|+|B-b|+|C-c|の最小値を更新していくことで答えが求まる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CorrectMultiplication {
public: long long getMinimum(int a, int b, int c) {
long long ret=1e+18;
long long maxans=(long long)a+b+c-3;</description>
    </item>
    
    <item>
      <title>SRM 535 DIV1 Middle - FoxAndBusiness　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-535-div1-middle---foxandbusiness%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Mar 2014 11:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-535-div1-middle---foxandbusiness%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11454&amp;amp;rd=15037
ワーカーが複数存在し、それぞれのワーカーi について以下がわかっている。
a[i]:１時間あたりにこなせる仕事の数
p[i]:仕事あたりにかかるコスト
今回、ワーカーから複数人選び、同じ時間働くように均等に仕事を割り当てる。
こなしたい仕事の数がわかっているとき、必要な最小コストを求める。
解き方 
サンプル通りの計算だとワーカーiにタスクtを割り当てた時のコストは
t[i]*3600/a[i]となる。
ここで時間が均等になるようtを割り当てるのは計算が難しいので
考え方を変える。
ｘ時間を均等に割り当てたとき、
コスト　&amp;nbsp;：x*(a[i]*p[i] + a[j]*p[j]...+3600K)
タスク数：x*(a[i]+a[j]...)
単純にするために１時間の場合を考えると
コスト　&amp;nbsp;：a[i]*p[i] + a[j]*p[j]...+3600K
タスク数：a[i]+a[j]...
ここで、求めたい最小のコストansは
ans/totalwork*(a[i]+a[j]...)&amp;gt;=a[i]*p[i] + a[j]*p[j]...+3600K
を満たす最小のansとなる。
ここで１タスクあたりの最小コストM=ans/totalworkとおくと、M*(a[i]+a[j]...)&amp;gt;=a[i]*p[i] + a[j]*p[j]...+3600K
よって上記式を満たす最小のMを求め、totalWorkをかけてあげればよい。
Mは２分探索で探すことができ、
最適なワーカーはa[i]*(M-p[i])の昇順で選ぶことができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).</description>
    </item>
    
    <item>
      <title>SRM 546 DIV1 Middle - FavouriteDigits　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-546-div1-middle---favouritedigits%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 23 Feb 2014 19:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-546-div1-middle---favouritedigits%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12045&amp;amp;rd=14738
ある数字が与えられる。
プレイヤーは好きな数字を２つもっており、それぞれ決められた個数だけ含んでいる数にしたい。
ある数字以上であり、かつ上記の条件を満たす最小の数字を求める。
解き方 
全探索は１０＾１５のためできない。
まず必要な桁数は、もとの数字の桁数、もしくは好きな数字の数の合計、のいずれか大きい方になる。
次に例として、好きな数字が９が２つ、７が１つであるときを考える。
最初の数字を１２３４５６７８とすると、
４の桁の数字を一つ足すことで１２３５？？？？
？には好きな数字を入れることができるので、最適な数字を入れることで探索範囲を狭めることができる。
ここでいう最適な数字とは、以下になることがわかる。
（０＊？の残りの桁）＋（小さい数字＊必要数）＋（大きい数字＊必要数）
上記の例では「１２３５０７９９」となる。
つまり、少ない数字から足していく方法が最初に思い浮かぶが、
大きい数字から考えるとシンプルに実装することができる。
あとは元の数字から１を引き、それより大きい数字を左から全て探索する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class FavouriteDigits {
public:
string tostring(long long x){
string str;
stringstream out;</description>
    </item>
    
    <item>
      <title>SRM 556 DIV1 Middle - LeftRightDigitsGame2　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-556-div1-middle---leftrightdigitsgame2%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 23 Feb 2014 14:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-556-div1-middle---leftrightdigitsgame2%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12198&amp;amp;rd=15178
ある数字の列が与えられる。
数字列の左側から順に、空白から始めてその左側もしくは右側に足していって新たな数字の列を作ることができる。
また、最低限満たしたい数字の列も与えられる。
このとき、最低限満たしたい数字の列よりも大きく、かつできるだけ小さい数字列を求める。
ただしそのような数字の列が存在しない場合は””を返す。
解き方 
順に考えると手掛かりがないので、逆の操作をすることを考える。
逆の操作を考えると、最後の文字列はそれまでできた文字列の左側もしくは右側に足すことになる。
また、最後から２番目の文字列はそれまでにできた文字列の左側、もしくは右側に、、、とｄｐに落とすことができる。
ｄｐの状態としては、これまで左側に振り分けた文字、右側に振り分けた文字と、それぞれ振り分けた数字と最低限満たしたい文字列との大小関係を保存する。
大小関係は文字列数分振り分けた後に、最小文字以上かどうかを判定するのに利用する。
各ｄｐでの判定については、左側に振り分けた文字については左から順に決まっていくので、それまで＝であったときのみ大小関係を新たに判定する。
右側に振り分けた文字は右側から決まっていくので、毎回大小関係を判定する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int n;
string digits,lowerbound;
string dp[60][60][3][3];
int used[60][60][3][3];
class LeftRightDigitsGame2 {
public:
string rec(int l,int r,int cmpl,int cmpr){</description>
    </item>
    
    <item>
      <title>SRM 586 DIV1 Middle - History　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-586-div1-middle---history%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 23 Feb 2014 11:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-586-div1-middle---history%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12692&amp;amp;rd=15698
複数の王朝があり、各王朝ごとに皇帝ごとの在位期間がわかっている。
ただし王朝ごとに年号の割り振り方が違うので、年数は必ずしも一致していない。
ここで、王朝同士の戦いの記録がある。記録をもとに、王朝同士がどの年数に対応しているかわかるようになっている。
このとき、王朝同士の戦いのクエリが与えられた時、そのクエリが整合性がとれるものであればＹ，そうでなければＮを返す。
解き方 
王朝ごとの年数の一致を全体でとる必要がある。
今回グローバルの年号を仮に考えたとき、グローバルと各王朝の年数のずれをXと考える。
つまり、王朝iのグローバルとの年数のずれはX[i]とする。
次に、戦いがあったときにどの導き出される制約は以下の通り。
王朝uにおけるa番目の皇帝の始まりの年数をp[u][a]とすると、
王朝uのa番目の年号と王朝vのb番目の年号との戦いは
x[u]+p[u][a] ～p[u][a+1]-1 &amp;nbsp; 対 x[v]+p[v][b] ～p[v][b+1]-1
x[u]+p[u][a+1]-1&amp;gt;=x[v]+p[v][b] かつ x[v]+p[v][b+1]-1&amp;gt;=x[u]+p[u][b]
x[u]-x[v]&amp;gt;=p[v][b]-p[u][a+1]+1 &amp;nbsp;かつ x[v]-x[u]&amp;gt;=p[u][a]-p[v][b+1]+1　x[v]-x[u]&amp;gt;=p[u][a+1]-p[v][b]-1 &amp;nbsp;かつ x[u]-x[v]&amp;gt;=p[v][b+1]-p[u][a]-1　
これをワーシャルフロイド法を用いて全体の整合性を取る。最後にクエリを加えたことで矛盾が生じる、つまり負の経路が発生した時はＮを返しそうでなければＹを返せばよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()</description>
    </item>
    
    <item>
      <title>SRM 593 DIV1 Middle - MayTheBestPetWin　（復習××○）</title>
      <link>https://chaingng.github.io/post/srm-593-div1-middle---maythebestpetwin%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Feb 2014 19:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-593-div1-middle---maythebestpetwin%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12779&amp;amp;rd=15705
複数のペットがおり、各ペットごとにトラックを走りきる最小の時間と最大の時間が与えられる。
ペットを２つのチームに分けてチームごとに競争させ、２つのチームのゴール時間ができるだけ均衡するようにしたい。
このとき、２チーム間のゴール時間の差の最小を求める。
解き方 
２つのチームをそれぞれＳ，Ｔとしたとき、
Ｓの最小とＴの最大の差、Ｓの最大とＴの最小の差のうち大きい方が答えになる。
各ペットの最小時間の集合をＡ，最大時間の集合をＢとしたとき、
Ｓの最小とＴの最大の差は　|ΣA(s)ーΣB(t)|
(A(sum)-ΣA(t))-ΣB(t)
A(sum)-Σ(A(t)+B(t))
よって、Ａの合計からＴチームのA+Bを引いたものになる。
同様にＳの最大とＴの最小の差は
|ΣB(s)-ΣA(t)|
B(sum)-ΣA(s)-ΣA(t)
B(sum)-Σ(A(s)+A(t))
よって、Ｂの合計からＴチームのA+Bを引いたものになる。
あとは、全てのとりうるA+Bに対してAの合計とＢの合計との差を計算し、
最小の値が答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MayTheBestPetWin {
public:
int calc(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {</description>
    </item>
    
    <item>
      <title>SRM 599 DIV1 Middle - FindPolygons　（復習×××）</title>
      <link>https://chaingng.github.io/post/srm-599-div1-middle---findpolygons%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Feb 2014 15:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-599-div1-middle---findpolygons%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12842&amp;amp;rd=15711
多角形の外周の長さである、整数Ｌが与えられる。
多角形の各点はｘ、ｙ座標上になければいけない。
このとき、考えられる多角形のうち、辺の数が最も少ないものについて
一番長い辺と一番短い辺の差を求める。
解き方 
問題文のままだと全探索を考えるのも難しいので、法則がないか一つ一つ考える。
１つ目は四角形のとき、Ｌは偶数でなければいけない。
２つ目に辺の長さが√xのとき、辺の長さの合計であるLは整数にならない。
よって、辺の長さは整数となる。
３つ目として三角形のとき、a^2+b^2=c^2を考えると
a,b,cの組み合わせは(偶、奇、奇)、（偶、偶、偶）、（奇、奇、偶）。
よって、a+b+cは必ず偶数になるので、Ｌは偶数である。
これより、答えは四角形以下となる。
また、Ｌが３未満のときは答えが存在しないので４以上でなければいけない。
次に解き方として、三角形のときを考える。
問題を簡単にするために、１点は原点にあると考える。
各点はｘｙ座標上になければいけないので、原点との距離ｄである（ｘ、ｙ）を考えると
ｘ＾２＋ｙ＾２＝ｄ＾２かつｘ、ｙ、ｄは整数でなければいけない。
これを満たす全ての点に対し合計の長さがＬとなるものを求める。
そのような三角形がなければ、四角形のときを考える。
Ｌが４で割り切れれば正方形なので答えは０、そうでなければ長い辺が短い辺＋１である長方形が存在するので答えは１になる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
static const int maxc=2501*2501;
int A[20000],B[20000],square[maxc+1];
class FindPolygons {</description>
    </item>
    
    <item>
      <title>SRM 417 DIV1 Easy - TemplateMatching （復習○）</title>
      <link>https://chaingng.github.io/post/srm-417-div1-easy---templatematching-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Feb 2014 09:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-417-div1-easy---templatematching-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9943&amp;amp;rd=13508
ある文字列と、接頭辞と接尾辞が与えられる。
ある文字列のサブ文字列について、接頭辞と接尾辞ができるだけマッチするものを求める。
ただし、接頭辞と接尾辞のマッチ数が同じときは接頭辞のマッチ数が大きいものにする。
また、上記も同じであれば文字の昇順のものにする。
解き方 
シミュレーション問題なので、いかにシンプルに実装するか。
接頭辞の一致に時間がかかってしまったので、例とＦＯＲを回してみて正しく実装してみるか机上で検証してみるのがやはり大事。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
string P,S;
class TemplateMatching {
public:
int prefixes(string str){
int score=0;
int n1=str.size(),n2=P.size();
FOR(i,0,min(n1,n2)){
string s1=str.substr(0,i+1);
string s2=P.substr(n2-1-i,i+1);
if(s1==s2)score=max(score,i+1);
}
return score;</description>
    </item>
    
    <item>
      <title>SRM 593 DIV1 Easy - HexagonalBoard (復習××)</title>
      <link>https://chaingng.github.io/post/srm-593-div1-easy---hexagonalboard-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Feb 2014 08:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-593-div1-easy---hexagonalboard-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12784&amp;amp;rd=15705
５角形のセルからなるボードがあり、任意の場所に石が置いてある。
石が隣り合うときは、かならず違う色にしなければいけない。
このとき、全ての石を塗るのに必要な最小の色の数を求める。
解き方 
シミュレーションしてみると、色の数は最大３色になることがわかる。
色が０色のときは石がないとき、１色のときは全て独立したセルであることから簡単に判定できるので、２色と３色のときの判定ができればよい。
今回は２色でぬろうとしたときに塗れないとき、つまり隣り合うセルが同じ色になってしまうときに３色を返すようにＤＦＳでコーディングする。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int w,h;
vector&amp;lt;string&amp;gt; B;
int dr[]={-1,-1,0,0,1,1};
int dc[]={0,1,-1,1,-1,0};
class HexagonalBoard {
public:
int dfs(int r,int c,int v){
if(B[r][c]!=&#39;X&#39;)return 0;
int ret=1;</description>
    </item>
    
    <item>
      <title>SRM 410 DIV1 Easy - AddElectricalWires (復習××)</title>
      <link>https://chaingng.github.io/post/srm-410-div1-easy---addelectricalwires-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 22 Feb 2014 07:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-410-div1-easy---addelectricalwires-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8817&amp;amp;rd=12182
ノードが複数存在し、任意のノード同士がつながっている。
また、任意のノードが電力源につながっている。ただし、複数の電力源につながってはいけない。
このとき、接続可能なエッジの数を求める。
解き方 
各電力源につながっているノードの集合ごとに、残りでつなぐことのできるエッジ数を求める。
また、そのうち最大の集合と、電力源につながっていないノードの積も答えに加わる。
あるノードの集合におけるエッジ数は、残りのエッジ数ではなく最大エッジ数を求めた後で、最後に最初に存在するエッジ数を引いてあげればコーディングが簡単になる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int cnt,p[50],n;
vector&amp;lt;string&amp;gt; W;
class AddElectricalWires {
public:
void dfs(int x){
if(p[x])return;
p[x]=1;
cnt++;
FORE(i,0,n)if(W[x][i]==&#39;1&#39;&amp;amp;&amp;amp;p[i]==0)dfs(i);
}
int maxNewWires(vector&amp;lt;string&amp;gt; wires, vector&amp;lt;int&amp;gt; grid) {</description>
    </item>
    
    <item>
      <title>SRM 331 DIV1 Easy - CarolsSinging (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-331-div1-easy---carolssinging-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 21 Feb 2014 10:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-331-div1-easy---carolssinging-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7280&amp;amp;rd=10011
一つの歌をみんなで歌いたいが、それぞれの人で覚えている箇所が違う。
このとき、みんなが少なくとも１箇所歌える最小の歌詞の長さを求める。
解き方 
歌詞の長さは１０なので、全探索可能。
ビットマスクを利用して全探索する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CarolsSinging {
public:
int choose(vector&amp;lt;string&amp;gt; lyrics) {
int n=lyrics[0].size();
int ret=1e+9;
for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;n);i++){
int cnt=0;
vector&amp;lt;int&amp;gt; p(n,0);
for(int j=0;j&amp;lt;n;j++){
if(i&amp;amp;(1&amp;lt;&amp;lt;j)){
cnt++;
p[n-j-1]=1;</description>
    </item>
    
    <item>
      <title>SRM 368 DIV1 Easy - JumpingBoard (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-368-div1-easy---jumpingboard-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 21 Feb 2014 00:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-368-div1-easy---jumpingboard-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8245&amp;amp;rd=10936
あるボードが存在し、その中には１～９までの数字かＨで表わされる穴が存在する。
まずは一番左上のセルからスタートし、そのセルに書いてある数だけ上下左右に移動する。ボードの外に出たらそこで終了する。
このとき、ボードの外に出るまでの最大のターン数を求める。
ただし、ループが可能でボードの外に出なくてもよい場合はー１を返す。
解き方 
ＢＦＳに最初見えたがＤＦＳにて全てのルートを探索する必要がある。
ただし、一度通ったルートはメモ化が可能なのでｄｐが適用できる。
注意する点はループが発生した場合はー１を返さなければならないので、
現在探索中のルートはフラグを立てて判定しなければならない。
今回は以下のように値を割り振ることでコーディング可能。
セルを超えた時　：０で終了
すでに探索したルート：０以上で終了（うち、ホールにあたったときは０で終了）
現在探索中のルート　：ー２で例外値を返し終了
それ以外　：－１で次のループに進む
他の方のコードをみましたが、throw&amp;amp;catchしてもよさそうでした。
http://community.topcoder.com/stat?c=problem_solution&amp;amp;rd=10936&amp;amp;pm=8245&amp;amp;cr=251074
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
int dp[60][60];
int w,h;
int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
vector&amp;lt;string&amp;gt; B;
class JumpingBoard {</description>
    </item>
    
    <item>
      <title>SRM 435 DIV1 Easy - CellRemoval （復習○）</title>
      <link>https://chaingng.github.io/post/srm-435-div1-easy---cellremoval-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 19 Feb 2014 21:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-435-div1-easy---cellremoval-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10275&amp;amp;rd=13697
有向グラフが存在し、各ノードに対しどのノードが親であるかの情報が与えられる。
ただし、根のノードはー１が入っている。
この有向グラフに、ある指定されたノードが削除され、その子となっているノードも削除される。
このとき、元のノードの葉であり削除されていない葉の数を求める。
解き方 
元のグラフの葉のノードは、どのノードからも参照されていないノードになる。
また、あるノードが削除されたときに、その子であるノードはＢＦＳで探索できる。
上記の２つの処理を行うことで答えを求めることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CellRemoval {
public: int cellsLeft(vector&amp;lt;int&amp;gt; parent, int deletedCell) {
int n=parent.size();
int p[n+1];
memset(p,1,sizeof(p));
FORE(i,0,n)p[parent[i]]=0;
queue&amp;lt;int&amp;gt; q;
q.push(deletedCell);
while(!q.empty()){</description>
    </item>
    
    <item>
      <title>SRM 382 DIV1 Easy - CollectingRiders (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-382-div1-easy---collectingriders-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 19 Feb 2014 21:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-382-div1-easy---collectingriders-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8319&amp;amp;rd=10805
通常のチェスのナイトの動きを１度にＫ回まで動くことのできるＫ－ナイトをが存在し、
ボード上に配置されている。ボード上の数がＫにあたる。
このとき、すべてのボード上のナイトが同じセルに到達するまでに必要な最小移動回数の合計を求める。
そのようなセルが存在しない場合はー１を返す。
解き方 
ボードが１０＊１０なので、全探索で解くことができる。
計算量はＯ（１００００）。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CollectingRiders {
public: int minimalMoves(vector&amp;lt;string&amp;gt; board) {
int w=board[0].size(),h=board.size();
int dx[]={2,2,1,1,-1,-1,-2,-2};
int dy[]={1,-1,2,-2,2,-2,1,-1};
int ret=10000;
FORE(x,0,h){
FORE(y,0,w){
int p[h][w];
FORE(i,0,h)FORE(j,0,w)p[i][j]=10000;</description>
    </item>
    
    <item>
      <title>SRM 397 DIV1 Easy - SortingGame （復習○）</title>
      <link>https://chaingng.github.io/post/srm-397-div1-easy---sortinggame-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 17 Feb 2014 21:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-397-div1-easy---sortinggame-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8745&amp;amp;rd=12169
１～ｎまでの数字からなる配列が与えられる。
また、ｋ個の連続した数字を逆順に並び変えることができる。
このとき、元の配列を昇順にソートするのに必要な操作回数を求める。
ただし、昇順にソートできない場合はー１を返す。
解き方 
メモ化を利用した全探索を行う。
今回はｄｆｓよりキューを利用したｂｆｓの方が効率よく書くことができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
map&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt; m;
queue&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; q;
class SortingGame {
public:
int fewestMoves(vector&amp;lt;int&amp;gt; board, int k) {
int n=board.size();
m.clear();
m[board]=1;
q.push(board);
while(!q.empty()){</description>
    </item>
    
    <item>
      <title>SRM 591 DIV1 Easy - TheTree (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-591-div1-easy---thetree-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 13 Feb 2014 15:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-591-div1-easy---thetree-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12746&amp;amp;rd=15703
グラフの各深さに対する頂点数が与えられる。
このとき、そのグラフの直径を求める。
解き方 
グラフを最大のケースで作ってもよいが、場合分けをすれば簡単に求められる。
まず、答えの最小は各深さの頂点が１のとき、つまり深さ＋１（要素数）となる。
次に、直径の長さはその深さにおける頂点数が１もしくは２以上の場合しか影響されない。
②頂点数が２以上の場合
折り返し分の直径が増えるので、その値と比較して最大値を更新
①頂点数が１の場合
折り返し分はリセットされる。
リセットされた際の最大値の更新は①で比較済み。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheTree {
public: int maximumDiameter(vector&amp;lt;int&amp;gt; cnt) {
int n=cnt.size();
int ret=n;
int last=-1,len=0;
FORE(i,0,n){
if(cnt[i]==1){
last=i,len=0;</description>
    </item>
    
    <item>
      <title>SRM 407 DIV1 Easy - CorporationSalary（復習○）</title>
      <link>https://chaingng.github.io/post/srm-407-div1-easy---corporationsalary%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 13 Feb 2014 14:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-407-div1-easy---corporationsalary%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=9824&amp;amp;rd=12179
部下とマネージャーからなるサラリーマンの会社がある。
配列が与えられ、ある人に対してその部下が誰かがわかっている。
また、ある人の部下の部下は、ある人の部下でもあり、
あるひとのマネージャーのマネージャーは、ある人のマネージャーでもある。
ここで、ある人の給料は、その人の部下の給料の合計になる。
部下がいないひとの給料は１になる。
このとき、その会社のサラリーマン全員の給料の合計を求める。
解き方 
ある人の給料はその人の部下全員の給料の合計であるので、ＤＦＳにて答えを求めてあげればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
long long dp[60];
vector&amp;lt;string&amp;gt; R;
class CorporationSalary {
public:
long long f(int x){
if(dp[x]!=-1)return dp[x];
long long ret=0;
FORE(i,0,R.size())if(R[x][i]==&#39;Y&#39;)ret+=f(i);</description>
    </item>
    
    <item>
      <title>SRM 302 DIV1 Easy - DivisorInc （復習××○）</title>
      <link>https://chaingng.github.io/post/srm-302-div1-easy---divisorinc-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 21:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-302-div1-easy---divisorinc-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6186&amp;amp;rd=9823
ある整数から、ある整数へ変換したい。
ある整数からの変換は、１とその数以外の、その整数で割りきれる数を足すことができる。
このとき、最小の変換回数を求める。
解き方 
ぱっと見てdpで解く問題。
ただし、整数Ｎ割り切れる数を探すのにＮ/2まで探索しては間に合わない。
そこで、sqrt(Ｎ）まで探索してその数iとN/iの両方で検査する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class DivisorInc {
public: int countOperations(int N, int M) {
int dp[M+1];
FORE(i,N,M+1)dp[i]=1e+9;
dp[N]=0;
FORE(i,N,M+1){
if(dp[i]==1e+9)continue;
for(int j=2;j*j&amp;lt;=i;j++){
if(i%j!=0)continue;
if(i+j&amp;lt;=M)dp[i+j]=min(dp[i+j],dp[i]+1);
if(i+i/j&amp;lt;=M)dp[i+i/j]=min(dp[i+i/j],dp[i]+1);</description>
    </item>
    
    <item>
      <title>SRM 303 DIV1 Easy - SpiralNumbers (復習××)</title>
      <link>https://chaingng.github.io/post/srm-303-div1-easy---spiralnumbers-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 16:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-303-div1-easy---spiralnumbers-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6093&amp;amp;rd=9824
座標上に１から始まり、らせん上に数が増えていく。
この座標の１の場所を（０，０）として右側を正のｘ座標、下側を正のｙ座標としたときに与えられた数字の座標の位置を求める。
解き方 
数字の最大が1e+9なので全探索では解くことができない。
ここで、各四角形を考えると右上の座標の数は１，９，２５と(i+2)^2ずつ増えていることがわかる。また、その座標は（１、－１）、（２、－２）とこちらも１ずつ増減していることがわかる。
この法則に従ってどの四角形に与えられた数字があるかを判定し、逆にらせんを描くことで答えを求めることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SpiralNumbers {
public: string getPosition(int N) {
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
int x=0,y=0,len=0;
if(N==1)return &#34;(0,0)&#34;;
for(long long i=1;i*i&amp;lt;=1e+18;i+=2){
len++;
if(i*i&amp;lt;N)continue;
x=len-1,y=-(len-1);</description>
    </item>
    
    <item>
      <title>SRM 242 DIV1 Easy - GuessCard (復習○)</title>
      <link>https://chaingng.github.io/post/srm-242-div1-easy---guesscard-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 16:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-242-div1-easy---guesscard-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4490&amp;amp;rd=7217
行と列の長さが与えられ、最初は１行目から順に１，２、３・・・と数字が入っている。
ここで、ある数字を思い浮かべたとき、その数字が何列目に入っているか答える。
答えた後は行と列の数字を入れ替えて、また何列目に入っているか答える。
この操作を繰り返した時、最後に思い浮かべた数字のある行を答える。
複数存在しうるとき、またひとつも存在しないときはー１を返す。
解き方 
シミュレーション問題なので、いかにシンプルに実装するか。
候補の数の更新には配列で＆を使ってもよいが、insertのすでに入っているかの判定を使うことでよりシンプルになる。
数字の入れ替えは間違えやすいので例を出しながら確かめる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class GuessCard {
public: int whichRow(int width, int height, vector&amp;lt;int&amp;gt; columns) {
set&amp;lt;int&amp;gt; s;
FORE(n,1,height*width+1)s.insert(n);
int p[height][width],n=1;
FORE(i,0,height)FORE(j,0,width){
p[i][j]=n;
n++;</description>
    </item>
    
    <item>
      <title>SRM 177 DIV1 Easy - TickTick (復習×)</title>
      <link>https://chaingng.github.io/post/srm-177-div1-easy---ticktick-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 15:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-177-div1-easy---ticktick-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1609&amp;amp;rd=4690
ＰＣのクロックが１ｍｓごとに時間を刻む。
また、ＰＣの中では複数のプログラムが順に動いており、一つのプログラムが終わったらすぐに次のプログラムが動く。
このときプログラムの起動タイミングによっては起動する前と終了した後に時刻が変わっていることがある。
このとき、各プログラムごとに時刻が変わっている／変わっていない２つ状態があるとしたとき、時刻の刻み方による全ての場合の数を求める。
解き方 
時刻の取り方は小数点以下10^6あり、全探索していては間に合わない。
このケースの問題は、調べる箇所は絞らなければいけなく、その箇所は決めることができる場合が多い。
この問題の場合は各時刻に対して最小数分のみ足した場合を足すことで、
各プログラムにおいて時刻が変わるときの最小値、時刻が変わらないときの最小値をピックアップすることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TickTick {
public: int count(vector&amp;lt;string&amp;gt; events) {
set&amp;lt;string&amp;gt; ans;
vector&amp;lt;double&amp;gt; p(events.size()+1,0.0);
FORE(i,0,events.size())sscanf(events[i].c_str(),&#34;%lf&#34;,&amp;amp;p[i+1]);
FORE(i,0,p.size()){
double tick=p[i]+1e-7;
tick=tick-(double)((int)tick);
int prev=-1;</description>
    </item>
    
    <item>
      <title>SRM 150 DIV1 Easy - InterestingDigits (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-150-div1-easy---interestingdigits-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 11:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-150-div1-easy---interestingdigits-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1523&amp;amp;rd=4555
３の倍数はその各桁の数の和も同じく３の倍数になる。
上記に対し、ｘ進数のときにも同じ法則が成り立つ倍数を求める。
解き方 
ｘ進数を考えた時、ｘ＾４まで考えればよく、ｘは最大で３０であるので
計算量は30^4 *30 =30^5 =3*10^5となる。
条件を満たさない場合はbreak,continue等で打ち切りを行えば
十分全探索で間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class InterestingDigits {
public: vector&amp;lt;int&amp;gt; digits(int base) {
vector&amp;lt;int&amp;gt; ans;
FORE(i,2,base){
int valid=1;
FORE(j,1,pow(base,4)){
if(j%i!=0)continue;
int tmp=j,num=0;
while(tmp&amp;gt;0){</description>
    </item>
    
    <item>
      <title>SRM 156 DIV1 Easy - BombSweeper （復習○）</title>
      <link>https://chaingng.github.io/post/srm-156-div1-easy---bombsweeper-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 10:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-156-div1-easy---bombsweeper-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1778&amp;amp;rd=4585
マリンスイーパーを解く。
最初に好きな場所を選ぶ。
①そこにボムがあれば負け
②ボムがなくても周りにボムがあれば違うセルを選ぶ
③ボムがなくて、かつ周りにボムがなければ勝ち
このとき、勝率を求める。
解き方 
ボムがなくて周りにボムがある場合は違うセルを選ぶ、つまりノーカウントとなるので、
①と③の数のみ調べて100*③／（①＋③）が答えになる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BombSweeper {
public: double winPercentage(vector&amp;lt;string&amp;gt; board) {
int w=board[0].size(),h=board.size();
int ret=0,bomb=0;
FORE(i,0,h){
FORE(j,0,w){
int valid=1;
FORE(x,max(i-1,0),min(i+2,h))FORE(y,max(j-1,0),min(j+2,w))if(board[x][y]==&#39;B&#39;)valid=0;
if(valid)ret++;
if(board[i][j]==&#39;B&#39;)bomb++;</description>
    </item>
    
    <item>
      <title>SRM 168 DIV1 Easy - NumberGuesser (復習××)</title>
      <link>https://chaingng.github.io/post/srm-168-div1-easy---numberguesser-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 09:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-168-div1-easy---numberguesser-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1869&amp;amp;rd=4645
１～９９９８までの数字を考える。
（例）４３２１
各桁の数を入れ替えて、元の数字より小さければ入れ替えた数を引く。
（例）４３２１－１２３４＝３０８７
引いた後の数に、０ではない桁の数字を引き、３ケタ未満であれば０を最初につける。
（例）０８７
この操作をしたあとにできる数があらかじめ与えられた時、
引かれた桁の数字が何であるかを求める。
解き方 
数字が10^4、かつ数の入れ替えが4!=24通りであるため、
全探索可能。
あとはシミュレーションなので、シンプルに間違いのないよう実装する。
別解として、元の数を1000a+100b+10c+dとすると引く数は1000d+100c+10b+aとなる。
この数を引くと、999a+99b-90c-999d、つまり9の倍数となる。
9の倍数は各桁の数の和も9の倍数となるから、これを利用して簡単に解くことができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class NumberGuesser {
public:
int f(vector&amp;lt;int&amp;gt; a,vector&amp;lt;int&amp;gt; b){
int num=0,idx=-1;
FORE(i,1,10){
if(b[i]-a[i]==1)num++,idx=i;
else if(b[i]-a[i]&amp;gt;0||b[i]-a[i]&amp;lt;0)return -1;</description>
    </item>
    
    <item>
      <title>SRM 151 DIV1 Easy - Archimedes (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-151-div1-easy---archimedes-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 09:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-151-div1-easy---archimedes-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1693&amp;amp;rd=4560
円周率を正多角形から求めたい。
円の外周は２＊円周率＊半径の長さで求められる。
このとき、正ｎ角形を考えた時に計算できる円周率を求める。
解き方 
求めたい円周率をx,半径をr、正n角形の外周をyとすると、
2*x*r=y　...①
また、正多角形のうち一つの二等辺三角形の底辺dを考えると
正ｎ角形の外周はy= n*d
ここで、dの長さは
sinα=(d/2)/r
α=(2*Pi)/(n*2)=Pi/nであるため
d=2*r*sin(Pi/n)
y=n*2*r*sin(Pi/n)　...②
①、②より、
2*x*r=n*2*r*sin(Pi/n)
x=n*sin(Pi/n)
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Archimedes {
public: double approximatePi(int numSides) {
return numSides*sin(M_PI/numSides);</description>
    </item>
    
    <item>
      <title>SRM 172 DIV1 Easy - BadClock （復習○）</title>
      <link>https://chaingng.github.io/post/srm-172-div1-easy---badclock-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 08:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-172-div1-easy---badclock-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1969&amp;amp;rd=4665
正確な時計と、１時間あたり必ずｘ分ズレる時計がある。
各時計は１～１２時までの表示になる。
正確な時計とズレる時計の現在時刻が与えられた時、
時計の時刻が一緒になるまでに必要な時間を求める。
解き方 
現在時刻のズレＤとｘ分のずれの正負が異なれば答えはＤ／ｘになる。
一方で、正負が一緒であれば一周する必要があるので、（４３２００－Ｄ）／ｘとなる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BadClock {
public:
int calc(string str){
int h=(str[0]-&#39;0&#39;)*10+(str[1]-&#39;0&#39;);
int m=(str[3]-&#39;0&#39;)*10+(str[4]-&#39;0&#39;);
int s=(str[6]-&#39;0&#39;)*10+(str[7]-&#39;0&#39;);
return h*3600+m*60+s;
}
double nextAgreement(string trueTime, string skewTime, int hourlyGain) {</description>
    </item>
    
    <item>
      <title>SRM 174 DIV1 Easy - BirthdayOdds (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-174-div1-easy---birthdayodds-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 11 Feb 2014 00:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-174-div1-easy---birthdayodds-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1848&amp;amp;rd=4675
何人かのグループを考えた時、ある割合で同じ誕生日の人が存在する。
同じ誕生日の人がいる確率が与えられ、また誕生日となりうる日数が与えられた時、
何人の人がいれば与えられた確率以上で同じ誕生日の人が存在するかを求める。
解き方 
日数をＤとすると、Ｄ／Ｄ＊（Ｄ－１）／Ｄ・・・と計算していき
この値が１００－与えられた確率以下になるときの人数を答えればよい。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BirthdayOdds {
public: int minPeople(int minOdds, int daysInYear) {
double p=1.0;
FORE(i,1,daysInYear){
p*=(double)(daysInYear-i)/daysInYear;
if(p*100&amp;lt;=100-minOdds)return i+1;
}
return daysInYear+1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 157 DIV1 Easy - Salary (復習○)</title>
      <link>https://chaingng.github.io/post/srm-157-div1-easy---salary-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Feb 2014 23:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-157-div1-easy---salary-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1786&amp;amp;rd=4590
サラリーマンは出社したときと退社した時にスタンプカードを押し、その時間がわかっている。ただし、退社した時の時間は仕事時間に含まれない。
合わせて時給がわかっており、０：００～５：５９の間、かつ１８：００～２３：５９の間は時給が１．５倍になる。
このとき、サラリーマンの一日の給料を求める。
ただし、小数点以下は切り下げる。
解き方 
シミュレーション問題なので以下にシンプルに実装するか。
同じ計算は記載ミスを招くので、２度以上現れる計算は変数に保存して扱うことでミスをより少なくできる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Salary {
public:
int calc(string str){
int h=(str[0]-&#39;0&#39;)*10+(str[1]-&#39;0&#39;);
int m=(str[3]-&#39;0&#39;)*10+(str[4]-&#39;0&#39;);
int s=(str[6]-&#39;0&#39;)*10+(str[7]-&#39;0&#39;);
return h*3600+m*60+s;
}
int howMuch(vector&amp;lt;string&amp;gt; arrival, vector&amp;lt;string&amp;gt; departure, int wage) {</description>
    </item>
    
    <item>
      <title>SRM 153 DIV1 Easy - Inventory (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-153-div1-easy---inventory-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 10 Feb 2014 22:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-153-div1-easy---inventory-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1772&amp;amp;rd=4570
ある製品について、何日間で何個売れるかがわかっている。
複数の製品について上記の情報が与えられたとき、
１カ月あたり、つまり３０日あたり平均何個の製品が売れるかを求めたい。
ただし、情報が０日間であったときはその製品はないものとみなす。
また、割りきれない場合は誤差1e-9を引いたのちに繰り上げる。
解き方 
実装自体はシンプル。
以下の例外条件をきちんと書けるかがポイント。
・情報が０日間はカウントしない。（売れる数が０個のときはカウント）
・誤差の計算（問題文のとおり、1e-9を引く）
・最後に割り算が来るので、０のときの例外条件を記載
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Inventory {
public: int monthlyOrder(vector&amp;lt;int&amp;gt; sales, vector&amp;lt;int&amp;gt; daysAvailable) {
double cnt=0.0,ret=0.0;
FORE(i,0,sales.size()){
if(daysAvailable[i]==0)continue;
ret+=sales[i]*30.0/daysAvailable[i];
cnt++;
}</description>
    </item>
    
    <item>
      <title>SRM 159 DIV1 Easy - FryingHamburgers （復習×○）</title>
      <link>https://chaingng.github.io/post/srm-159-div1-easy---fryinghamburgers-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 22:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-159-div1-easy---fryinghamburgers-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1517&amp;amp;rd=4600
指定された数のハンバーガーを両面焼きたい。
両面焼くのには、片面ずつ、各５分必要となる。
また、フライパンが与えられ、一度に何枚のハンバーガーが焼けるかがわかっている。
このとき、指定された数のハンバーガーを焼くのに必要な最小時間を求める。
解き方 
ハンバーガーの数は１０００なので全探索で解ける。
シミュレーション問題なので、いかにシンプルに解くか。
片面ずつの配列を作って埋めていってもよいが、それぞれを区別する必要はないので
以下のように整理する。
フライパン１回使用につき、
①まずは両面とも焼いていないものを優先して載せる
②あまったところで片面のみ焼いてあるものを載せる。
③最後に両面とも焼けていないもの、片面のみ焼けているものの数を更新し、どちらも０になるまでループさせる。
１回のターンにつき①と②で同じものを選ばないようにするのがSystemtestで落ちないためのポイント。
コード 
class FryingHamburgers {
public: int howLong(int panSize, int hamburgers) {
int ret=0,half=0;
while(hamburgers+half&amp;gt;0){
ret++;
int first=min(hamburgers,panSize);
int both=min(panSize-first,half);
hamburgers-=first;
half+=first;
half-=both;
}
return ret*5;
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).</description>
    </item>
    
    <item>
      <title>SRM 181 DIV1 Easy - CombinationLock (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-181-div1-easy---combinationlock-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 20:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-181-div1-easy---combinationlock-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1945&amp;amp;rd=4725
数字を合わせてロックを空ける回転式の鍵がある。
合わせるのに必要な数字の一覧が順に与えられ、数字の数も与えられる。
ロックを解除する操作は以下の通り。
１．回す方向を決める
２．合わせるのに必要な一覧の、残りの数だけ１回転させる
３．現在合わせる数字まで回転させる
４．次の回転は逆回り
最初にセットしてある数字が与えられるとき、ロックの解除までに必要な回転角度を求める。
解き方 
問題文の理解に時間がかかったが、サンプルを例に試してみることで理解できた。
問題文の理解ができれば、あとはシミュレーション問題なので実装するだけ。
時計回りと反時計回りのときに数字を合わせるまでに動かす数だけ正確に実装できればあとは簡単。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class CombinationLock {
public: double degreesTurned(vector&amp;lt;int&amp;gt; combo, int size, int start) {
double ret=0.0;
int n=combo.size();</description>
    </item>
    
    <item>
      <title>ブートローダー</title>
      <link>https://chaingng.github.io/post/%E3%83%96%E3%83%BC%E3%83%88%E3%83%AD%E3%83%BC%E3%83%80%E3%83%BC/</link>
      <pubDate>Sun, 09 Feb 2014 18:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%83%96%E3%83%BC%E3%83%88%E3%83%AD%E3%83%BC%E3%83%80%E3%83%BC/</guid>
      <description>最近Androidのrootを取るのにbootloaderのアンロックを行ったのでメモ。
BootLoaderとは
起動直後のコンピュータはハードディスクからＯＳを読み込むことができない。
そのため、ＯＳを起動させるためにＢＩＯＳが読み込む小さなプログラムがブートローダーになる。
ただ、ブートローダーは通常はハードディスク等の先頭部分に５１２バイト分しか存在しないため、ＯＳを呼び出すことができない。
そこで、ブートローダーは各パーティションの先頭にあるブートマネージャー（２次ブートローダー）を起動させる。
ブートマネージャーは設定された内容に従って、指定されたパーティションにあるＯＳを起動する。
ここでブートマネージャーの設定ファイルに複数のＯＳ情報を記載することによって、
複数のＯＳの起動を選択することができる。
Bootloaderのアンロック
ブートローダーにはシステムのアップデート機能もあり、特定の場所にイメージを置いておくとアップデートすることができる。
ただし、電子署名された特定のイメージしかアップデートできないようにメーカーが設定している場合もある。
このとき独自のイメージを焼きたいときに、ブートローダーのアンロックが必要になる。
リカバリーにBootloaderのアンロックが必要
Androidにはboot,system,recoveryの３つのパーティションがある。
通常はsystemが起動するが、アップデートの際は起動できないのでrecoveryを起動してアップデートする必要がある。また、boot領域はシステムが壊れても最低限の起動をするのに必要なもの。
Bootloaderのアンロックをすることで、recovery領域のアップデート（カスタムリカバリー）も可能になる。

 </description>
    </item>
    
    <item>
      <title>SRM 182 DIV1 Easy - SlayingDeer （復習○）</title>
      <link>https://chaingng.github.io/post/srm-182-div1-easy---slayingdeer-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 17:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-182-div1-easy---slayingdeer-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2308&amp;amp;rd=4730
鹿を追いかけて捕まえたい。
プレイヤーは速度Ａ，鹿は速度Ｂ，距離はＣで与えられる。
ただし、鹿は３０分走ったあと１５分休憩する。
このとき、何分後に鹿を捕まえられるかを求める。
ただし、決して捕まえられない場合はー１を返す。
解き方 
シミュレーションで間に合わない場合はお互い走って休んでを１周とすると
何周目に捕まえられるかの計算が必要になるが、
時間Ｃの最大が10^5なので単純なシミュレーションで間に合う。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SlayingDeer {
public: int getTime(int A, int B, int C) {
int rest=C,ret=0;
while(1){
if((A-B)*30&amp;lt;rest){
ret+=30;
rest-=(A-B)*30;
}</description>
    </item>
    
    <item>
      <title>SRM 188 DIV1 Easy - Percents (復習×)</title>
      <link>https://chaingng.github.io/post/srm-188-div1-easy---percents-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 17:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-188-div1-easy---percents-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2386&amp;amp;rd=4760
あるアンケートに対して、yesと答えた人の割合が％で与えられる。
このとき、その割合になるときに必要なアンケート人数の母数を求める。
ただし、小数点３位以下は四捨五入される。
解き方 
最初に文字列からｐを取りだすのにそのままの小数点を取りだすと、整数にしようと掛け算をした時に誤差が出てしまうので、文字から直接取りだした。
母数を１～１００００まで順に操作し、
そのときのyesと答えた人の割合は切り捨てとなる場合と切り上げになる場合の
両方を検査する。
ｎで割ったときの判定については、ｎの半分を足すことで四捨五入の値を求めることができる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Percents {
public: int minSamples(string percent) {
int p=(percent[0]-&#39;0&#39;)*1000+(percent[1]-&#39;0&#39;)*100+(percent[3]-&#39;0&#39;)*10+(percent[4]-&#39;0&#39;);
FORE(n,1,10000){
int cost=n*p/10000;
if((cost*10000+n/2)/n==p)return n;
if(((cost+1)*10000+n/2)/n==p)return n;
}
return 10000;</description>
    </item>
    
    <item>
      <title>SRM 189 DIV1 Easy - Display (復習○)</title>
      <link>https://chaingng.github.io/post/srm-189-div1-easy---display-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 15:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-189-div1-easy---display-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2295&amp;amp;rd=4765
縦横が-10^6～10^6の間にあるｘ、ｙ座標上の点を、
0～10^3の座標上に変換したい。
このとき、変換後の座標を求める。
解き方 
Exampleを見るとx,ｙ座標それぞれに対して
最小の数を０になるよう足し引きして、その後最大の座標が１０００になるよう縮尺してあげればよい。
システムテストで落ちないように以下の四則演算には注意。
・最後に０．５単位の数を繰り上げる際には、掛け算をしてから割り算をする。
・０になるよう足し引きする際は、最小が＋－のときどのような操作になるかを
手書きで確かめてから実装する。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Display {
public: vector&amp;lt;string&amp;gt; transform(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
int n=x.size();
int minx=1e+9,miny=1e+9;
FORE(i,0,n){
minx=min(minx,x[i]);
miny=min(miny,y[i]);
}</description>
    </item>
    
    <item>
      <title>SRM 199 DIV1 Easy - TriangleCount （復習○）</title>
      <link>https://chaingng.github.io/post/srm-199-div1-easy---trianglecount-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 14:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-199-div1-easy---trianglecount-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2889&amp;amp;rd=5074
１辺の長さが与えられる。
各辺の長さが１の三角形を組み合わせて、１辺の長さが与えられた長さになるよう
三角形を作る。
このとき、１辺が１～与えられた長さである三角形の数の合計を求める。
解き方 
なにか法則がありそう。
単純な三角形の数だけ見ても法則はないが、
普通の三角形と逆にした三角形を別々に考えると以下の法則があることがわかる。
１辺の長さがｘの三角形を考えると、その数は以下の通りになる。
普通の三角形：長さがｘのとき１個、ｘ＋１のとき３個、３のとき６個・・・と等差数列の値だけ増加
逆の三角形　：長さがｘ＊２のとき１個、ｘ＊２＋１のとき３個・・・と等差数列の値だけ増加
あとはdpにて実装して、最後に全ての和を足すことで答えが求められる。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TriangleCount {
public: int count(int N) {
int dp[N];
memset(dp,0,sizeof(dp));
FORE(i,0,N){
int cnt=1;
FORE(j,i,N){</description>
    </item>
    
    <item>
      <title>SRM 204 DIV1 Easy - Apothecary (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-204-div1-easy---apothecary-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 14:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-204-div1-easy---apothecary-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2312&amp;amp;rd=5850
ある物体の重さを、天秤を使って測りたい。
天秤の重さは３＾ｘのものが各１つずつ存在する。
このとき、必要な天秤の重さを昇順にソートして返す。
解き方 
重さの最大は10^6なので、各３のべき乗に対し３通りの計算と考えると
3^14ほどになり計算量がちょっと怪しい。
※計算
10^6=3^x log10^6=log3^x x=6/log3≠13
ここで各３のべき乗xとそこまでのすべてのべき乗の和をsum[x]とすると、
sum[x-1]&amp;lt;abs(W)&amp;lt;sum[x]のときその数xは使わなければならない。
逆にsumが超えてしまうとその数を使ってはいけなくなる。
これをループさせて範囲を狭めていき、答えを求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Apothecary {
public: vector&amp;lt;int&amp;gt; balance(int W) {
vector&amp;lt;int&amp;gt; ans;
int x=1,sum=1;
while(W!=0){
if(sum&amp;gt;=abs(W)){</description>
    </item>
    
    <item>
      <title>SRM 212 DIV1 Easy - WinningRecord （復習○）</title>
      <link>https://chaingng.github.io/post/srm-212-div1-easy---winningrecord-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 10:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-212-div1-easy---winningrecord-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=3003&amp;amp;rd=5858
あるチームの直近の勝ち負けの結果が与えられる。
そこから、直近のいつまでがもっとも勝率がよくて、直近のいつまでがもっとも勝率が悪かったかを求める。
ただし、答えは３ゲーム目以降の結果から比較する。
解き方 
直近の１試合前から最後まで勝率を計算しベストとワーストのものを更新していけばよい。
２ゲーム目までは比較対象にせず、３ゲーム目から更新していく。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class WinningRecord {
public: vector&amp;lt;int&amp;gt; getBestAndWorst(string games) {
vector&amp;lt;int&amp;gt; ans(2,0);
double best=0.0,worst=0.0;
double wins=0,loses=0;
FORE(i,0,games.size()){
if(games[i]==&#39;W&#39;)wins++;
else loses++;
if(i&amp;lt;2)continue;
if(best&amp;lt;=wins/(wins+loses)){
best=wins/(wins+loses);
ans[0]=i+1;</description>
    </item>
    
    <item>
      <title>SRM 221 DIV1 Easy - TerribleEncryption (復習○)</title>
      <link>https://chaingng.github.io/post/srm-221-div1-easy---terribleencryption-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 09:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-221-div1-easy---terribleencryption-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1924&amp;amp;rd=5867
暗号化された文字列があり、それを復号したい。
あらかじめ暗号化された文字pool、配列data,keysが与えられる。
復号後の文字列のi番目の文字は、
(data[i]*k)%keys[i]=1となる最小の正の整数kを求め、
j=k%(poolのサイズ)としたとき、pool[j]の文字となる。
このとき、復号後の文字列を求める。
解き方 
問題文の理解ができれば、同じように実装するだけ。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TerribleEncryption {
public: string decrypt(string pool, vector&amp;lt;int&amp;gt; data, vector&amp;lt;int&amp;gt; keys) {
int n=data.size(),m=pool.size();
string str=&#34;&#34;;
FORE(i,0,n){
int k=1;
while((data[i]*k)%keys[i]!=1)k++;
str+=pool[k%m];
}
return str;</description>
    </item>
    
    <item>
      <title>SRM 230 DIV1 Easy - SortEstimate （復習○）</title>
      <link>https://chaingng.github.io/post/srm-230-div1-easy---sortestimate-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 08:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-230-div1-easy---sortestimate-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=3561&amp;amp;rd=6519
ソートアルゴリズムの計算量を計算したい。
計算量はc*n*log2(n)で表わされ、これをtime以下でかつ最大となるときのｎを求めたい。
cとtimeはあらかじめ与えられる。
解き方 
nが一意に決まれば計算量は算出できるので、二分探索が適用できる。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class SortEstimate {
public: double howMany(int c, int time) {
double low=0.0,high=1e+18;
FORE(i,0,100){
double mid=(low+high)/2.0;
if(c*mid*log(mid)/log(2)&amp;lt;=time)low=mid;
else high=mid;
}
return low;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 245 DIV1 Easy - Flush (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-245-div1-easy---flush-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 09 Feb 2014 00:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-245-div1-easy---flush-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4487&amp;amp;rd=7220
４種類の絵柄のトランプあり、それぞれの絵柄についてカード数が与えられる。
Ｎ枚のカードを引いたとき、最も多い同じ絵柄のカード数がFlushスコアになる。
このとき、Flushスコアの期待値を求める。
解き方 
カードの種類は４種類、カード数は１３枚なので、
あり得る全てのカードの取り方について全探索すればよい。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Flush {
public:
double f(int x,int y){
double ret=1.0;
for(int i=y;i&amp;gt;y-x;i--)ret*=i;
for(int i=x;i&amp;gt;0;i--)ret/=i;
return ret;
}
double size(vector&amp;lt;int&amp;gt; s, int number) {
double ret=0.0;</description>
    </item>
    
    <item>
      <title>SRM 247 DIV1 Easy - Musical (復習○)</title>
      <link>https://chaingng.github.io/post/srm-247-div1-easy---musical-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 22:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-247-div1-easy---musical-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4495&amp;amp;rd=7222
椅子取りゲームを行う。
プレイヤーはｎ人、椅子はn-1個で等間隔でサークル上に置かれる。
プレイヤーはＡが椅子の横、Ｂがその次に続き、Ｃがその次に・・・とサークル上に等間隔で位置している。
プレイヤーは椅子のサークルをtime秒だけ周回し、止まったときにある椅子に最も近いプレイヤーがその椅子に座る。
ただし、10秒でちょうど一周することになる。
このとき、負けるプレイヤーが誰になるかを求める。
解き方 
問題条件をいかにシミュレーションできるか、簡単にコーディングできるかになる。
まず、１周の長さを１とすると、各プレイヤーは周る方向とは逆の順にＢ，Ｃ、と並ぶ。
各プレイヤーの間隔は1/n、各椅子は同様にして、1/(n-1)離れている。
最後に、最も椅子から離れているプレイヤーが負けるプレイヤーになる。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class Musical {
public: string loser(int n, double time) {
time=fmod(time,10.0)/10.0;
vector&amp;lt;double&amp;gt; x,c;
FORE(i,0,n)x.push_back(fmod((double)i/n+1.0-time,1.0));
FORE(i,0,n-1)c.push_back((double)i/(n-1));
double worst=0.0;
int ret=-1;
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 284 DIV1 Easy - TriCount (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-284-div1-easy---tricount-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 19:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-284-div1-easy---tricount-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4811&amp;amp;rd=8081
１辺の最小の長さと、最大の長さが与えられる。
このとき、とりうる三角形の数を求める。
ただし、回転して同じ三角形になる場合は同じものとみなす。
答えが10^9を超える場合は-1を返す。
解き方 
２重ループでは計算量として間に合わない、はずなのですが
10^9以上は-1を返すので２重ループで収まります。
コード 
class TriCount {
public: int count(int minLength, int maxLength) {
long long ret=0LL;
FORE(i,minLength,maxLength+1){
FORE(j,i,maxLength+1){
ret+=min(maxLength,i+j-1)-j+1;
if(ret&amp;gt;1000000000)return -1;
}
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 281 DIV1 Easy - IntegerGenerator (復習○)</title>
      <link>https://chaingng.github.io/post/srm-281-div1-easy---integergenerator-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 11:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-281-div1-easy---integergenerator-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6093&amp;amp;rd=9824
有効な一ケタの数字一覧と、現在の数字が与えられる。
現在の数字より大きく、かつ有効な数字のみで構成された数を求める。
ただし無効である場合は”INVALID INPUT”を返す。
解き方 
例外判定がまずは大事。
現在の数字に無効な数字が含まれているか、０から始まるのであれば無効。
あとは一ケタ目から有効な数字をインクリメントしてあげればよい。
その桁において、元の数より大きい数になればそこで終了、
そうでなければ桁上がりするので次の桁に進む。
最後までインクリメントされるのであれば、最初に一番小さい有効な数字を足す。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class IntegerGenerator {
public: string nextInteger(vector&amp;lt;int&amp;gt; allowed, string current) {
int num[10]={0};
FORE(i,0,allowed.size())num[allowed[i]]=1;
FORE(i,0,current.size())if(num[current[i]-&#39;0&#39;]==0)return &#34;INVALID INPUT&#34;;
if(current[0]==&#39;0&#39;)return &#34;INVALID INPUT&#34;;
for(int i=current.</description>
    </item>
    
    <item>
      <title>SRM 265 DIV1 Easy - ScheduleStrength (復習○)</title>
      <link>https://chaingng.github.io/post/srm-265-div1-easy---schedulestrength-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 10:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-265-div1-easy---schedulestrength-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
複数のチームがあり対戦を行う。
総当たり戦ではなく、対戦しないチーム同士もある。
ここで、各チームの強さを求めたい。
あるチームの強さは、対戦した他のチーム全てに対し、
「他のチームの勝ち数／他のチームの勝ち数＋他のチームの負け数」
が少ないほど強いチームにある。
ただし、他のチームの勝ち数からは自チームの負け数、他のチームの負け数からは自チームの勝ち数を引いてカウントしなければならない。
このとき、各チームを強さの順にソートして返す。強さが同じ時はチーム名の昇順に並べる。
解き方 
シミュレーション問題なので、いかにシンプルにコーディングするか。
いきなり計算してもよいのですが、各チームの勝ち負け数をカウントしてから
強さを計算することでシンプルに実装できます。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class ScheduleStrength {
public: vector&amp;lt;string&amp;gt; calculate(vector&amp;lt;string&amp;gt; teams, vector&amp;lt;string&amp;gt; results) {
int n=teams.size();
int win[n],lose[n];
memset(win,0,sizeof(win));
memset(lose,0,sizeof(lose));
FORE(i,0,n){
FORE(j,0,n){
if(results[i][j]==&#39;W&#39;)win[i]++;
if(results[i][j]==&#39;L&#39;)lose[i]++;</description>
    </item>
    
    <item>
      <title>SRM 608 DIV1 Easy - MysticAndCandies (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-608-div1-easy---mysticandcandies-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 08 Feb 2014 09:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-608-div1-easy---mysticandcandies-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12997&amp;amp;rd=15841
複数の箱それぞれに対しlowとhighの値が割り振られ、lowからhighの間の数のキャンディーが入っている。
また、合計のキャンディーの数もわかっている。
プレイヤーは複数の箱を選び、Ｘ個以上のキャンディーを食べたい。
このとき、どの箱を選んでもＸ個以上のキャンディーが入っているような、最小の箱の数を求める。
解き方 
問題文のどのキャンディーの入り方でもＸ個以上、という最悪条件になっていることに気付くのに時間がかかってしまいました。
答えは最大で箱の数なので、選ぶ数は１～ｎまで順番に調べていき
条件を満たせばそこで答えになります。
条件の満たし方は以下の２通りのうちいずれかを満たせばよいです。
①最小のキャンディーは必ず入っているので、最小の数のみの和でＸ以上になること
②選んでいない残りの箱の最大数がＣ－Ｘ以下になること。
例外条件として、②は選んだ箱の取りうるキャンディー数がＸを満たすか気になります。
これは、選んだ箱の取りうるキャンディー数がＸ未満の場合、残りの箱は最大数を選んでいるため合計のキャンディー数が決して満たない数になってしまいます。
①の例外条件として合計だけでは満たさなくとも、残りで最大を選んだときのバッファを足せば満たすかがありますが、これはまさに②なので大丈夫です。
例外条件をちゃんと確かめるか、もしくはコードでカバーしておくかが大事です。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class MysticAndCandies {
public: int minBoxes(int C, int X, vector&amp;lt;int&amp;gt; low, vector&amp;lt;int&amp;gt; high) {
int n=low.size();</description>
    </item>
    
    <item>
      <title>SRM 607 DIV1 Easy - PalindromicSubstringsDiv1 xx</title>
      <link>https://chaingng.github.io/post/srm-607-div1-easy---palindromicsubstringsdiv1-xx/</link>
      <pubDate>Wed, 05 Feb 2014 22:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-607-div1-easy---palindromicsubstringsdiv1-xx/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12964&amp;amp;rd=15840
ある文字列が与えられる。
文字列はアルファベットと、？からなり、？には任意の文字を入れることができる。
？に任意の文字が入れられたとき、
その文字列中の回文であるサブ文字列の数の期待値を求める。
解き方 
文字列は最大５０００であるため、？の全ての場合に対して期待値を求めては間に合わない。
ここで回文の判定については、その両端の２つの文字列だけを見ればよいことがわかる。
ある文字列が回文であれば、その両端の文字の判定結果をかけていけば回文の判定は時間内に間に合う。
データ構造としてdp[i][j]をi番目からj番目までの文字列、と定義することで
計算量は最大で5000*5000/2になるので時間内に解くことができる。
コード 
double dp[5010][5010];
string s;
class PalindromicSubstringsDiv1 {
public:
double calc(int i,int j){
if(s[i]!=&#39;?&#39;&amp;amp;&amp;amp;s[j]!=&#39;?&#39;) return s[i]==s[j] ? 1.0 : 0.0;
return 1.0/26.0;
}
double expectedPalindromes(vector&amp;lt;string&amp;gt; S1, vector&amp;lt;string&amp;gt; S2) {
double ret=0.0;
memset(dp,0,sizeof(dp));
s=&#34;&#34;;
FORE(i,0,S1.size())s+=S1[i];
FORE(i,0,S2.size())s+=S2[i];
int n=s.size();
FORE(i,0,n){
dp[i][i]=1.0;
ret+=dp[i][i];
}
FORE(i,0,n-1){
dp[i][i+1]=calc(i,i+1);
ret+=dp[i][i+1];
}
FORE(len,3,n+1){
for(int i=0;i+len-1&amp;lt;n;i++){
int j=i+len-1;
dp[i][j]=dp[i+1][j-1]*calc(i,j);
ret+=dp[i][j];
}
}
return ret;</description>
    </item>
    
    <item>
      <title>SRM 293 DIV1 Easy - ScrabbleBet （復習○）</title>
      <link>https://chaingng.github.io/post/srm-293-div1-easy---scrabblebet-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 05 Feb 2014 20:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-293-div1-easy---scrabblebet-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6116&amp;amp;rd=9814
１セットあたりのゲーム回数が与えられ、それを指定回数分のセット数行う。
１ゲームにたいして勝つ確率が与えられ、そのセット数で勝つために必要な勝ちゲーム数が与えられる。
このとき、少なくとも１つのセットで勝つことのできる確率を求める。
解き方 
問題文の理解に少し時間がかかった。
１セットあたりに負ける確率さえ計算できれば、答えは１－負ける確率＾セット数で求められる。
１セットあたりに負ける確率の計算に順列を使ってもよいが、
ゲーム数は２０なので全探索してもたかだか１０＾６程度なので間に合う。
コード 
class ScrabbleBet {
public: double estimate(int trials, int games, int winsNeeded, int winChance) {
double loses=0.0;
double p=winChance/100.0;
for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;games);i++){
int x=0;
for(int j=0;j&amp;lt;20;j++)if(i&amp;amp;(1&amp;lt;&amp;lt;j))x++;
if(x&amp;lt;winsNeeded)loses+=pow(p,x)*pow(1.0-p,games-x);
}
return 1.0-pow(loses,trials);
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).</description>
    </item>
    
    <item>
      <title>SRM 440 DIV1 Easy - IncredibleMachine (復習××)</title>
      <link>https://chaingng.github.io/post/srm-440-div1-easy---incrediblemachine-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 05 Feb 2014 19:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-440-div1-easy---incrediblemachine-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10310&amp;amp;rd=13748
ある惑星上にて（ｘ、ｙ）からなる点が複数与えられる。
その惑星の重力ｇは不明だが、すべての点を順番に通った時の合計時間Tはわかっている。
また、１つの点から次の点までの距離dは以下の式で計算される。
d=v0*t+0.5*a*t
ここでtは２点間の移動に必要な時間、a=g*sinで表わされる。
v0は速度であり次の点に移ったときの速度はv1=v0+a*tで表わされる。
このとき、その惑星の重力gを求める。
解き方 
ｇが決まればそのときの合計時間T(g)は一意に求めることができる。
つまり、二分探索で解くことができる。
コード 
class IncredibleMachine {
public:
double calc(vector&amp;lt;int&amp;gt; x,vector&amp;lt;int&amp;gt; y,double g){
double ret=0.0;
double v0=0.0;
FORE(i,0,x.size()-1){
double d=sqrt((x[i]-x[i+1])*(x[i]-x[i+1])+(y[i]-y[i+1])*(y[i]-y[i+1]));
double a=g*abs(y[i]-y[i+1])/d;
double t=(-v0+sqrt(v0*v0+2.0*a*d))/a;
v0+=a*t;
ret+=t;
}
return ret;
}
double gravitationalAcceleration(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, int T) {
double low=0.0,high=1e+9;
FORE(i,0,200){
double mid=(low+high)/2.0;
if(calc(x,y,mid)&amp;lt;T)high=mid;
else low=mid;
}
return high;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 489 DIV1 Easy - BallsConverter (復習○)</title>
      <link>https://chaingng.github.io/post/srm-489-div1-easy---ballsconverter-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Feb 2014 20:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-489-div1-easy---ballsconverter-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11211&amp;amp;rd=14242
２つのボールを捨てて、新しくボールを作るマシーンがある。２つのボールのタイプがi、jとすると、
新しく作られるボールはパターンc[i][j]もしくはc[j][i]となる。
このとき、最初に入っているボールがわかっているときに結果が変わらないパターンであればＧｏｏｄ、そうでなければＢａｄを返す。
解き方 
問題文を理解するのが難しかった。
要は、任意の３つのボールに対して結合法則が成り立つかどうかを全てのタイプに対して調べればよい。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BallsConverter {
public:
int f(char ch){
if(&#39;A&#39;&amp;lt;=ch&amp;amp;&amp;amp;ch&amp;lt;=&#39;Z&#39;)return ch-&#39;A&#39;;
else return ch-&#39;a&#39;+26;
}
string theGood(vector&amp;lt;string&amp;gt; c) {
int n=c.size();
FORE(i,0,n)FORE(j,0,n)FORE(k,0,n)if(c[f(c[i][j])][k]!=c[i][f(c[j][k])])return &#34;Bad&#34;;
return &#34;Good&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 490 DIV1 Easy - Starport (復習○)</title>
      <link>https://chaingng.github.io/post/srm-490-div1-easy---starport-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Feb 2014 18:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-490-div1-easy---starport-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11227&amp;amp;rd=14243
Ｍ秒間隔でスペースシャトルが到着し、Ｎ秒間隔でテレポートが始まる。
スペースシャトルが到着したときにテレポート間隔とぴったりでなければ、次のテレポート時間まで待つ。
このとき、待ち時間の平均時間を求める。
解き方 
数学的に解く問題。
サンプルを元に計算すると、
N=10 M=4 (gcd=2 lcm=20)M:4 8 12 16 20 24 28 32 36 40 44N: &amp;nbsp; &amp;nbsp;10 &amp;nbsp; &amp;nbsp; &amp;nbsp; 20 &amp;nbsp; &amp;nbsp; &amp;nbsp; 30 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 40 50 60 70
１サイクルの待ち時間 T=6+2+8+4+0=20となる。
また、要素数はlcm/Mとなることがわかる。
また要素をgcdにて割ると、
M&#39;:2 4 6 8 10&amp;nbsp;N&#39;: &amp;nbsp; &amp;nbsp;5 &amp;nbsp; &amp;nbsp; &amp;nbsp;10 &amp;nbsp;
１サイクルの待ち時間はT=gcd*(3+1+4+2+0)
また、0,1,...N&#39;-1のすべての要素が出現することがわかる。
つまり、合計待ち時間T、要素数Kと答えとなるT/Kは以下のように計算できる。
T=gcd*N&#39;*(N&#39;-1)/2
&amp;nbsp; =gcd*(N/gcd)(N/gcd-1)/2
&amp;nbsp; =N(N/gcd-1)/2
K=lcm/M=N/gcd
T/K= (N(N/gcd-1)/2) &amp;nbsp;/(N/gcd)
&amp;nbsp; &amp;nbsp; &amp;nbsp;= (N(N/gcd-1)*gcd) &amp;nbsp;/(N*2)</description>
    </item>
    
    <item>
      <title>SRM 493 DIV1 Easy - StonesGame (復習×)</title>
      <link>https://chaingng.github.io/post/srm-493-div1-easy---stonesgame-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Feb 2014 14:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-493-div1-easy---stonesgame-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11292&amp;amp;rd=14422
番号が１から始まる長さＮの列に、ひとつだけ白い石が置かれている。
そのほかの場所には黒い石が置かれている。
ここで２人のプレイヤーでゲームを行い、連続してＫ個の石を選びその順番をひっくりかえす。
ただし、選んだ中には白い石がなければならない。
プレイヤーは交互にプレイする。最初はRomeoの番で、次はStrangletの番。
このとき、勝つ方のプレイヤーの名前を返す。
ただし、決着がつかない場合はDrawを返す。
解き方 
石の場所とゴールの場所が与えられた時に勝ちかどうかを判定できる関数を正確に作ることができるか。
関数は以下の条件で作成できる。
・ゴールと初期位置の差とＫ＋１の偶奇が一致しているか
・ゴールと初期位置の差がＫ未満であるか
・ひっくり返すＫの選び方が、列におさまるか
コード 
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class StonesGame {
public:
bool can(int N,int M,int K,int L){
if(M&amp;gt;L)swap(M,L);
if(L-M&amp;gt;=K)return 0;
if(K%2==0){
if(abs(M-L)%2==0)return false;
int len=(K-abs(L-M)-1)/2;</description>
    </item>
    
    <item>
      <title>SRM 599 DIV1 Easy - BigFatInteger (復習○)</title>
      <link>https://chaingng.github.io/post/srm-599-div1-easy---bigfatinteger-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Feb 2014 11:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-599-div1-easy---bigfatinteger-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12867&amp;amp;rd=15711
・最初は１から始まり、Ａ＾Ｂとなる数にしたい。
・操作方法は、素数をかけるか、現在の数の約数をかけるかの２通り。
このとき、最小の操作回数を求める。
解き方 
サンプルを例に素因数分解してみる。
Ａ＝360、Ｂ＝8のとき、
Ａ＝2＾3＋3＾2＋5
Ａ＾Ｂ＝2＾24＋3^16＋5＾8
ここで、最も大きい階乗２４に対して2^K&amp;gt;=24となるＫを考えた時
素因数の数＋Ｋが答えになることがわかる。
コード 
class BigFatInteger {
public: int minOperations(int A, int B) {
int x0=0;
int x1=0;
for(int i=2;i&amp;lt;=A;i++){
int cnt=0;
while(A%i==0){
A/=i;
cnt++;
}
if(cnt==0)continue;
x0++;
cnt*=B;
int p=1,tmp=0;
while(p&amp;lt;cnt){
p*=2;
tmp++;
}
x1=max(x1,tmp);
}
return x0+x1;
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i !</description>
    </item>
    
    <item>
      <title>SRM 604 DIV1 Easy - PowerOfThree (復習××)</title>
      <link>https://chaingng.github.io/post/srm-604-div1-easy---powerofthree-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 02 Feb 2014 10:03:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-604-div1-easy---powerofthree-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12917&amp;amp;rd=15837
ロボットが座標（０，０）からスタートし、４方向に移動する。
ステップ０からスタートし、各ステップ３＾Ｋだけ指定した方向に移動する。
移動したい座標（ｘ、ｙ）が与えられた時、その座標に移動できるなら”Possible”、移動できないなら&#34;Impossible&#34;を返す。
解き方 
足し引きできる数は３の階乗なので、
ビット計算に落とし込むことで解くことができる。
座標の正負は関係ないので正の座標に変換し、
例としてサンプルの一つを３進数で考えると以下のように変換できる。
ｘ座標：１＝００１
ｙ座標：９＝１００
ここで３の階乗を足していくステップは、
３進数の右から考えていくと毎回ｘ、ｙのどちらかの数を引くことと同じになる。
ここでどちらかが１であればよいが、
どちらも０、もしくはどちらも１であれば”Impossible”になる。
途中でｘ＝０、ｙ＝０になれば&#34;Possible&#34;で終了になる。
コード 
class PowerOfThree {
public:
string ableToGet(int x, int y) {
x=abs(x);
y=abs(y);
while(!(x==0&amp;amp;&amp;amp;y==0)){
if(x%3==0&amp;amp;&amp;amp;y%3==0)return &#34;Impossible&#34;;
if(x%3!=0&amp;amp;&amp;amp;y%3!=0)return &#34;Impossible&#34;;
if(x%3==1)x--;
if(x%3==2)x++;
if(y%3==1)y--;
if(y%3==2)y++;
x/=3,y/=3;
}
return &#34;Possible&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 439 DIV1 Easy - PouringWater （復習○）</title>
      <link>https://chaingng.github.io/post/srm-439-div1-easy---pouringwater-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 23:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-439-div1-easy---pouringwater-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10408&amp;amp;rd=13747
N個のボトルがあり、最初は１Ｌだけ水が入っている。
ここで同じ量だけ水が入っているボトルを選んで、一つのボトルに水をまとめることができる。
このとき、水が入っているボトルをＫ個以下にしたい。
ただし現在のボトル数ではＫ個以下にできない場合は、ボトルを追加で買うことができる。
このとき、水が入っているボトルをＫ個以下にしたいときに、追加で必要なボトルの最小数を求める。
解き方 
ぱっと見た感じだと解法が思い浮かばないので、ボトル数の計算を式に落とせないか考えてみる。
ここで、１個、２個、４個、８個・・・のボトルは一つにまとめられることから
２＾Ｋ個のボトルは１つにまとめることができる。
次に例をあげてみると、
１５＝２＾３＋＋２＾２＋２＾１＋１のように変換することができる。
上記の式を眺めてみると、ボトルの数は２進数に変換したときの１の数と等しい
ことがわかる。
次にボトルを減らしたいときに買うべきボトルの数を、先の例を使って考える。
１５＝１１１１であり、ボトルを１つ買うと
１００００、つまりボトルが１つになる。
つまり、右から走査し１が存在した時はその数を足し、
ボトル数がＫ個以下になるまで繰り返してあげればよい。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PouringWater {
public:
int calc(int x){
int ret=0;
while(x&amp;gt;0){
ret+=x%2;
x/=2;
}</description>
    </item>
    
    <item>
      <title>SRM 436 DIV1 Easy - BestView （復習○）</title>
      <link>https://chaingng.github.io/post/srm-436-div1-easy---bestview-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 21:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-436-div1-easy---bestview-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10341&amp;amp;rd=13698
間隔１で一列に高層ビルが並んでいる。
高層ビルの上から他のビルをできるだけ多く見渡したい。
他のビルを見渡すには、そのビルと他のビルの屋上を結んだときに間に他のビルがなければよい。
このとき、一番多く見渡せるビルの数を求める。
解き方 
各ビルにおいて見渡せるビルの数を全探索する。
最初は三平方の定理を使ってしまったが、座標の傾きを使えば簡単に他のビルがさえぎっているかどうかを判定することができる。
aからbを見渡す時、uがさえぎっていないかを判定するには
(h(u)-h(a))/(b-a) *x +h(a) &amp;lt;= h(u) ここでx=(u-a)のときにビルuがさえぎってしまうので
(h(u)-h(a))/(b-a) *(u-a) +h(a) &amp;lt;= h(u) (h(u)-h(a))/(b-a) *(u-a) &amp;lt;= h(u) -h(a)
(h(u)-h(a)) *(u-a) &amp;lt;= (h(u) -h(a)) *(b-a)
この式で判定できる。
見渡すビルを固定した時に他のビルを見渡せるかの判定については、
最初順序を決めて左と右の走査と分けてしまったが
間のビルがさえぎっていないかどうかだけを判定すればよいので
それがわかればよりシンプルに実装することができる。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)</description>
    </item>
    
    <item>
      <title>SRM 427 DIV1 Easy - DesignCalendar （復習○）</title>
      <link>https://chaingng.github.io/post/srm-427-div1-easy---designcalendar-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 20:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-427-div1-easy---designcalendar-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10155&amp;amp;rd=13518
１日あたりの日数Ｄと１年あたりの日数Ｙが与えられる。
１年あたりの日数が１日あたりの日数で割り切れるのに必要な年数を求める。
解き方 
問題文がとにかく難しい。
要は、必要な年数をＸとすると
（Ｙ＊Ｘ）％Ｄ＝＝０となる最小のＸを求めればよい。
ここでＹ％Ｄ＝aとすると、求めるxは
（例）
a=4,D=6のとき lcd=12 gcd=2となりx=3
a=4,D=14のとき lcd=28 gcd=2となりx=7

つまり、x=D/gcd(a,D)となる。
例外処理として、aが割り切れる場合は答えは１となるのに注意。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class DesignCalendar {
public:
int gcd(int a,int b){
if(a%b==0)return b;
return gcd(b,a%b);
}
int shortestPeriod(int dayLength, int yearLength) {</description>
    </item>
    
    <item>
      <title>SRM 426 DIV1 Easy - ShufflingMachine (復習×)</title>
      <link>https://chaingng.github.io/post/srm-426-div1-easy---shufflingmachine-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 19:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-426-div1-easy---shufflingmachine-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10196&amp;amp;rd=13517
カードをシャッフルして配るゲームがあり、最初は０からＮ－１まで順番に並んでいる。
シャッフル方法についてプレイヤーは知っている。
プレイヤーがシャッフル後に受け取るカードの位置と、欲しいカードの枚数がわかっている。
加えてシャッフル回数の最大はわかっているが、実際のシャッフルは１～最大回数のうちランダムな回数になる。
このとき、欲しいカードを最適な場所においたときに、欲しいカードがもらえる最大の期待値を求める。
解き方 
シャッフルの仕方について問題文を理解するのに時間がかかってしまった。
全探索により、最大回数までシャッフルしたときに各位置について得られるスコアを計算する。
各位置について得られるスコアは独立であるため、最後に大きい順からＫ個の和をとり、最大のシャッフル数で割ることで答えが求められる。
コード 
class ShufflingMachine {
public:
double stackDeck(vector&amp;lt;int&amp;gt; shuffle, int maxShuffles, vector&amp;lt;int&amp;gt; cardsReceived, int K) {
int n=shuffle.size();
vector&amp;lt;int&amp;gt; order(n,0);
FORE(i,0,n)order[i]=i;
vector&amp;lt;int&amp;gt; score(n,0);
FORE(i,0,maxShuffles){
vector&amp;lt;int&amp;gt; tmp=order;
FORE(j,0,n)order[j]=tmp[shuffle[j]];
FORE(j,0,cardsReceived.size())FORE(k,0,n)if(order[k]==cardsReceived[j])score[k]++;
}
sort(score.rbegin(),score.rend());
double ret=0;
FORE(i,0,K)ret+=score[i];
return ret/(double)maxShuffles;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 333 DIV1 Easy - BirthNumbersValidator (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-333-div1-easy---birthnumbersvalidator-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 17:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-333-div1-easy---birthnumbersvalidator-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7291&amp;amp;rd=10657
誕生日を表わす１０桁の数字が与えられる。
その数字を&#34;YYMMDDCCCC&#34;とすると、以下で表わされる。
ＹＹが１９０７～２００６までの西暦の下２桁。
うるう年も存在する。うるう年は４００で割れるか、４で割れて１００で割れない年。
ＭＭが月であり、ＭＭは女性の場合に限り５１～６２の範囲になる。
ＤＤが日付。
ＣＣＣＣはチェックサムで、１０ケタの数字を１１で割った余りが０になるようになっている。
このとき、与えられた数字が有効であればＹＥＳを、無効な数字であればＮＯを返す。
解き方 
シミュレーション問題なので以下にシンプルに解くか。
今回の実装のポイントは３つ。
・各条件の判定には関数を用いる
・月の判定には配列を用いる。
・ＹＥＳ，ＮＯの判定にはbool値を定義し、andを取って判定する。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class BirthNumbersValidator {
public:
long long calc(string str){
stringstream out(str);
long long num;
out&amp;gt;&amp;gt;num;
return num;
}</description>
    </item>
    
    <item>
      <title>SRM 421 DIV1 Easy - EquilibriumPoints (復習○)</title>
      <link>https://chaingng.github.io/post/srm-421-div1-easy---equilibriumpoints-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 16:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-421-div1-easy---equilibriumpoints-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10104&amp;amp;rd=13512
直線状に複数の点とその点にある球の数が与えられる。
ある点を考えた時、その点と点ｘの距離をｄ、点ｘの球の数をｍとすると
Ｆ＝Ｇ＊ｍ１＊ｍ２／ｄ＾２で引力が表わされる。
ここでＧは定数。
このとき、引力が左右均衡となる点を求める。
点が複数存在する場合は、昇順に並べる。
解き方 
サンプルを見ると各点の間ごとに均衡点があることがわかる。
あとは、その間すべてに対して２分探索すれば答えが求められる。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class EquilibriumPoints {
public:
double calc(int m,double d){
return m/d/d;
}
vector&amp;lt;double&amp;gt; getPoints(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; m) {
vector&amp;lt;double&amp;gt; ans;
int n=x.size();
FORE(i,0,n-1){</description>
    </item>
    
    <item>
      <title>SRM 441 DIV1 Easy - PerfectPermutation (復習○)</title>
      <link>https://chaingng.github.io/post/srm-441-div1-easy---perfectpermutation-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 14:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-441-div1-easy---perfectpermutation-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10463&amp;amp;rd=13749
ある０～n-1の数がランダムに並べられた、長さｎの配列が与えられる。
このとき、childpermutation Bは、
B[0]=0, B[i]=B[A[B[i-1]]で現した時
もとの配列と同様に0~n-1の数が存在するものと定義する。
最初に与えられた数列がchildpermutationを含む時は０を、
配列の数字の入れ替えが発生する場合は元の数列と異なる要素数のうち
最小の差のものを求める。
解き方 
すべてpermutationしていては要素数が５０のため間に合わない。
ここで、全ての数が現れる場合というのはＢがループしている場合ということがわかる。
ループが１つの場合はそのまま答えになるが、
ループが複数存在する場合はお互いの数字を入れ替えることで一つのループにすることができる。
よって、ループの数を計算し１つであれば０、複数存在するのであればループ数を返す。
コード 
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PerfectPermutation {
public: int reorder(vector&amp;lt;int&amp;gt; P) {
int n=P.size();
int ans=0;
int used[n];
memset(used,0,sizeof(used));
FORE(i,0,n){</description>
    </item>
    
    <item>
      <title>SRM 488 DIV1 Easy - TheBoredomDivOne (復習××)</title>
      <link>https://chaingng.github.io/post/srm-488-div1-easy---theboredomdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 14:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-488-div1-easy---theboredomdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11193&amp;amp;rd=14241
友人が複数いて、既に飽きている友人と飽きていない友人がいる。
毎回その中から２人を選んで、握手させる。握手した友人は飽きてしまう。
このとき、全員が飽きるまでに要する回数を求める。
解き方 
通常のｄｐで解くと、数が変わらないときに無限ループになってしまうので工夫が必要。
ここで、dp[x]をx人が飽きていないときの回数と定義する。
p1は飽きていない人がｘ人のときから友人を選んで
飽きていない人の数がx-1人になる確率、p2はx-2人になる確率とすると、
dp[x]=1+p0*dp[x]+p1*dp[x-1]+p2*dp[x-2]　と表わすことができる。
式を変形すると、dp[x]=(1+p1*dp[x-1]+p2*dp[x-2])/(1-p0)となりdpで解くことができる。
dpはそれまでの状態の数がわかれば通常は解くことができるが、
今回のケースのように状態が変わらないケースが存在するときは等号式を作って変形させてあげる必要がある。
コード 
class TheBoredomDivOne {
public: double find(int n, int m) {
int t=n+m;
double dp[t+1];
memset(dp,0,sizeof(dp));
FORE(i,1,m+1){
double sum=t*(t-1)/2.0;
double p0=(t-i)*(t-i-1)/(sum*2.0);
double p2=i*(i-1)/(sum*2.0);
double p1=1.0-p0-p2;
if(i==1)dp[i]=(1+p1*dp[i-1]+p2*0)/(1-p0);
else dp[i]=(1+p1*dp[i-1]+p2*dp[i-2])/(1-p0);
}
return dp[m];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 484 DIV1 Easy - RabbitNumber (復習×)</title>
      <link>https://chaingng.github.io/post/srm-484-div1-easy---rabbitnumber-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 12:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-484-div1-easy---rabbitnumber-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11131&amp;amp;rd=14237
ある数xの平方数yを考えたとき、(x*x=y),
かつnの各桁の和で表わされるS(n)について、S(x)*S(x)=S(y)が成り立つとき
その数はRabbit Numberになる。
このとき、lowからhighまでの間のRabbit Numberの数を求める。
解き方 
普通に解くとlow,highともに10^9であるため解くことができない。
そのため法則がないか考える。
ここで、ｘの各桁の数が３以下であればRabbit Numberになる可能性がある。
1*1=1,S(1)*S(1)=1
2*2=4,S(2)*S(2)=4
3*3=9,S(3)*S(3)=9　しかし、4以上のとき、つまり桁上がりしてしまうときは決してRabbit Numberにならない。
4*4=16,S(4)*S(4)=16 (≠7)　5*5=25,S(5)*S(5)=25 (≠7)

つまり、各桁が０～３の全ての数のうち、平方数のS(n)とイコールになるものについて(この中でも２ケタ以上の数では桁上がりは発生しうるので)、lowとhighの間の数をカウントしてあげればよい。　コード 
class RabbitNumber {
public:
int S(long long x){
int ret=0;
while(x&amp;gt;0){
ret+=x%10;
x/=10;
}
return ret;
}
int calc(int low,int high,int cur){
int ret=0;
FORE(i,0,4){
int x=10*cur+i;
if(x==0||S(x)*S(x)!=S((long long)x*x))continue;
if(low&amp;lt;=x&amp;amp;&amp;amp;x&amp;lt;=high)ret++;
if(x&amp;lt;=high/10)ret+=calc(low,high,x);
}
return ret;
}
int theCount(int low, int high) {
return calc(low,high,0);</description>
    </item>
    
    <item>
      <title>SRM 472 DIV1 Easy - PotatoGame (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-472-div1-easy---potatogame-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 11:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-472-div1-easy---potatogame-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10759&amp;amp;rd=14154
・TaroとHanakoの２人がゲームをする。
・ポテトの数が与えられて、４の階乗分だけ自分のターンのときに食べることができる。
・ポテトの数が０になったら勝ち。
・最初はTaroのターン。
・このとき、勝つ方のプレイヤーの名前を求める。
解き方 
１０＾９のため全探索では解くことができない。
パターンを見つけようとdpで１０００ほど出力させてみると、
MOD5のとき0もしくは２のときHanakoが勝つことがわかる。
次に上記の証明。
4の階乗を引くということは、mod5で考えた時±1していることと同じ。
例えば、4のときは 4^2 mod5=-1 、16のときは 4^2 mod5=1となる。
ここで、Taroが勝つポジションを n=1,3,4(mod5)としたとき、
4^Kを引いた場合に相手に負けるポジションに移動させることができる。
例外としてN=1,3のときは1を引くことしかできない。
N=1 のときは1を引くことで勝ちとなるのでＯＫ．
N=3 のときは1を引いてN=2と負けのポジションに移動させられるのでＯＫ．
逆に、負けるポジション n=0,2(mod5)にいた場合は
4^Kを引いても相手を負けるポジションに移動させることができない。
よって、最初のMOD5のときのポジションで勝ち負けが一意に決まる。
コード 
class PotatoGame {
public: string theWinner(int n) {
return n%5==0||n%5==2 ? &#34;Hanako&#34; : &#34;Taro&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 258 DIV1 Easy - AutoLoan (復習○)</title>
      <link>https://chaingng.github.io/post/srm-258-div1-easy---autoloan-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 01 Feb 2014 09:18:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-258-div1-easy---autoloan-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=3970&amp;amp;rd=7993
・車をローンで購入する。
・車の費用はあらかじめわかっており、ディーラーは月額の固定支払額と払い終わるまでの月数を教えてくれる。
・ただしその場合のローン率は教えてくれない。
・支払いは毎月残額にたいしてローン率／１２が足された後、毎月の固定支払額が引かれる計算となる。
・このとき、ローン率がいくらになるか求める。
解き方 
２分探索で簡単に解くことができる。
相対誤差で計算してもよいが、100回まわせば誤差1e-9に対して精度は10^2/10^100なので十分。
コード 
class AutoLoan {
public: double interestRate(double price, double monthlyPayment, int loanTerm) {
double low=0.0,high=100.0;
FORE(i,0,100){
double mid=(high+low)/2.0;
double cost=price;
FORE(j,0,loanTerm){
cost+=cost*mid/12.0;
cost-=monthlyPayment;
}
if(cost&amp;lt;=0)low=mid;
else high=mid;
}
return low*100.0;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 289 DIV1 Easy - FallingBall</title>
      <link>https://chaingng.github.io/post/srm-289-div1-easy---fallingball/</link>
      <pubDate>Sat, 01 Feb 2014 08:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-289-div1-easy---fallingball/</guid>
      <description>問題 
・トライアングル上に釘が打ってある台からボールを落とす。
・台の高さはあらかじめ与えられる。
・ボールを落としたとき、下に落ちる場所は釘の左側か右側になる。
・また、通って欲しい釘の場所が複数与えられる。
・このとき、通って欲しい場所を通るボールの落ち方の場合の数を求める。
そのような場合がない場合はー１を返す。
解き方 
パスカルの三角形を使えば解くことができる。
最初に与えられた台の数のパスカルの三角形を作り、
各座標の差だけパスカルの三角形の場合の数をかけていく。
座標の差が通ることができない差であればー１を返す。
最後に、台の高さと最後の座標の高さの差の数だけ２の階乗すれば答えが求まる。
コード 
class FallingBall {
public: int howMany(vector&amp;lt;string&amp;gt; cells, int n) {
int ret=1;
vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; p;
int dp[n+1][n+1];
memset(dp,0,sizeof(dp));
dp[0][0]=1;
FORE(i,1,n+1){
dp[i][0]=1;
FORE(j,1,n+1)dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
}
FORE(i,0,cells.size()){
stringstream out(cells[i]);
int a,b;
out&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
p.push_back(make_pair(a,b));
}
p.push_back(make_pair(0,0));
sort(all(p));
FORE(i,1,p.size()){
int dy=p[i].first-p[i-1].first;
int dx=p[i].second-p[i-1].second;
if(dx&amp;lt;0||dx&amp;gt;dy)return 0;
ret*=dp[dy][dx];
}
return ret*(1&amp;lt;&amp;lt;(n-1-p[p.size()-1].first));
}
}; </description>
    </item>
    
    <item>
      <title>BeautifulSoupの第一歩</title>
      <link>https://chaingng.github.io/post/beautifulsoup%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AD%A9/</link>
      <pubDate>Fri, 31 Jan 2014 23:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/beautifulsoup%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AD%A9/</guid>
      <description>クローラーで取ってきたHTMLを解析するのにBeautifulSoupが使いやすそうだったので使ってみました。以下は簡単な使い方のメモ。
バージョン
BeautifulSoupは３と４がありますが
現在はBeautiful Soup３は終了していてBeautiful Soup４が主流とのこと。
Webをみていると３の使い方が多いので注意。
そしてPython3はBS3が使えないです。
インポート
まずはインポート。
BeautifulSoup4は以下の書き方になります。
from bs4 import BeautifulSoup
まずは全文抽出
まずは、以下のように書くことでhtmlの全文が保存されます。
datas = BeautifulSoup(datas)

findで指定のタグを抽出
次にfind文で指定のタグを抽出できます。
今回はfindAll文を使うことで、html中の指定のタグを抽出しました。
以下ではdivタグのresult classを抽出。
datas2 = datas.findAll(&#34;div&#34;, attrs={&#34;class&#34;: &#34;result&#34;})

さらに下層の情報取得とテキスト抽出
ここで抽出された情報は配列となっているので、
さらにそこから抽出したい情報があれば配列番号でアクセス。
result_name=datas2[1].find(&#34;h5&#34;).get_text().replace(&#39; &#39;,&#39;&#39;)
score=datas2[2].find(&#34;h5&#34;).get_text()
ここでは1番目と2番目にあるh5タグを抽出しています。
これまでだとタグと本文を含めてまとめて抽出されるので、
本文だけを取りだしたい場合はget_text()を利用。
また、タグ内の属性情報を取り出したいときはget(&#39;href&#39;)など指定することで可能です。
タグ名を取りだしたいときは .nameで取れます。
 </description>
    </item>
    
    <item>
      <title>SRM 184 DIV1 Easy - RaceCalculator (復習×)</title>
      <link>https://chaingng.github.io/post/srm-184-div1-easy---racecalculator-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 31 Jan 2014 23:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-184-div1-easy---racecalculator-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2250&amp;amp;rd=4740
・人がある道を走るシチュエーションで、通過した距離とその時点での時間が任意の地点分与えられる。
・同じペースで走ることができ、予想される時間が計算できるのが理想だが、疲れが影響してペースは一定にはならない。
・ある地点における予想時間は、その他の任意の２点を使って計算できる。
・このとき、一番実際の時間と予想時間との差が小さくなる地点を求める。
解き方 
問題文の意味を読み解くのに苦労しました。
ある地点に対する予想時間はその他の任意の２点を使って求めるということがわかれば、
３点の取り方に対する全ての場合の数を計算してあげれば答えが求まります。
コード 
class RaceCalculator {
public: int bestRace(vector&amp;lt;int&amp;gt; distances, vector&amp;lt;int&amp;gt; times) {
int n=times.size();
double badness[n];
FORE(i,0,n)badness[i]=-(1e+9);
FORE(i,0,n)FORE(j,0,n)FORE(k,0,n){
if(i==j||j==k||i==k)continue;
double a=log(times[j]/(double)times[i]);
double b=log(distances[i]/(double)distances[k]);
double c=log(distances[i]/(double)distances[j]);
double expected=times[i]*exp(a*b/c);
badness[k]=max(badness[k],(times[k]-expected)/expected);
}
int best=0;
FORE(i,0,n)if(badness[i]&amp;lt;badness[best])best=i;
return best;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 606 DIV1 Easy - EllysNumberGuessing （復習○）</title>
      <link>https://chaingng.github.io/post/srm-606-div1-easy---ellysnumberguessing-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Thu, 30 Jan 2014 19:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-606-div1-easy---ellysnumberguessing-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12975&amp;amp;rd=15839
・２人でゲームを行い、一人は１～１０＾９までの数を思い浮かべ、
もう一人が言った数との絶対値を答える。
・このターンを何度か繰り返したとき、最後に思い浮かべた数を返す。
ただし、そのような数が存在しないときはー２、複数存在するときは－１を返す。
解き方 
各ターンごとに存在しうる数字についてＡＮＤをとり、最後に残ったものが答えになる。
具体的には最初のターンで存在しうる２通りの数について、各ターンごとに現れるのであれば残し、なければfalseとして最後に判定すればよい。
また、最初に１～１０＾９内にある数か判定してあげればその後は毎回判定しなくてもよい。
単純に数を数えるコーディングや、同じセットが複数存在するときにエラーとなるコーディングではひっかかるので上記のように問題にシンプルに従って実装する。
コード 
class EllysNumberGuessing {
public: int getNumber(vector&amp;lt;int&amp;gt; guesses, vector&amp;lt;int&amp;gt; answers) {
int num1=guesses[0]+answers[0];
int num2=guesses[0]-answers[0];
int flag1=0,flag2=0;
if(1&amp;lt;=num1&amp;amp;&amp;amp;num1&amp;lt;=1000000000)flag1=1;
if(1&amp;lt;=num2&amp;amp;&amp;amp;num2&amp;lt;=1000000000)flag2=1;
FORE(i,0,guesses.size()){
if(guesses[i]+answers[i]!=num1&amp;amp;&amp;amp;guesses[i]-answers[i]!=num1)flag1=0;
if(guesses[i]+answers[i]!=num2&amp;amp;&amp;amp;guesses[i]-answers[i]!=num2)flag2=0;
}
if(flag1&amp;amp;&amp;amp;flag2)return -1;
if(!flag1&amp;amp;&amp;amp;!flag2)return -2;
if(flag1)return num1;
return num2;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 288 DIV1 Easy - FindTriangle</title>
      <link>https://chaingng.github.io/post/srm-288-div1-easy---findtriangle/</link>
      <pubDate>Thu, 30 Jan 2014 08:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-288-div1-easy---findtriangle/</guid>
      <description>問題 
・３次元座標上に、ＲＧＢのうち１つの色を持つ座標が複数与えられる。
・そのうち同じ色の３点、もしくは全て異なる色の３点を選んで三角形を作ることができる。
・このとき、作ることのできる三角形の最大の面積を求める。
解き方 
三角形の求め方がポイント。
ヘロンの法則を使って求めると、誤差が生じてしまう。
そのため、２つのベクトルの外積が平行四角形の面積になることを利用して解く。
コード 
class FindTriangle {
public:
double largestArea(vector&amp;lt;string&amp;gt; points) {
int n=points.size();
int c[n],x[n],y[n],z[n];
FORE(i,0,n){
stringstream out(points[i]);
char ch;
out&amp;gt;&amp;gt;ch&amp;gt;&amp;gt;x[i]&amp;gt;&amp;gt;y[i]&amp;gt;&amp;gt;z[i];
if(ch==&#39;R&#39;)c[i]=1;
else if(ch==&#39;G&#39;)c[i]=2;
else c[i]=4;
}
double ret=0.0;
FORE(i,0,n){
FORE(j,i+1,n){
FORE(k,j+1,n){
int flag=c[i]|c[j]|c[k];
if(flag==1||flag==2||flag==4||flag==7){
double dx1=x[j]-x[i];
double dy1=y[j]-y[i];
double dz1=z[j]-z[i];
double dx2=x[k]-x[i];
double dy2=y[k]-y[i];
double dz2=z[k]-z[i];
double len=(dy1*dz2-dz1*dy2)*(dy1*dz2-dz1*dy2);
len+=(dz1*dx2-dx1*dz2)*(dz1*dx2-dx1*dz2);
len+=(dx1*dy2-dy1*dx2)*(dx1*dy2-dy1*dx2);
ret=max(ret,len);
}
}
}
}
return sqrt(ret)/2.0;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 287 DIV1 Easy - TwoEquations (復習○)</title>
      <link>https://chaingng.github.io/post/srm-287-div1-easy---twoequations-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 28 Jan 2014 08:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-287-div1-easy---twoequations-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6013&amp;amp;rd=9808
・２次方程式が与えられる。
・このとき、ｘ、ｙを求める。
ただし解がない時は&#34;NO SOLUTIONS&#34;、解が複数あるときは&#34;MULTIPLE SOLUTIONS&#34;を返す。
解き方 
シミュレーションの問題なので、いかに簡単に実装するか。
ポイントは３つ。
１つめは、文字列から数字を取り出すところ。
２つめは、解がない時、複数あるときの例外判定。
３つめは、ｘ、ｙの求め方。
１つめについては数字の取り出しとかっこの判定を分けることで実装。
２つめ、３つめについては方程式を
Ax+ by= c、Dx+ ey= fとしたとき、
X= ce-bf / ae-bd,　Y= cd-af / bd-ae　となる。
２つめ、ae-bdが０のとき ce-bfかつcd-afが０であれば解が複数あり、そうでなければ解が存在しない。
またx,yのすべての係数が０のとき、右の項がすべて０なら解が複数あり、そうでなければ解が存在しない。
３つめについては上記の式でｘ、ｙを求めればよい。
コード 
class TwoEquations {
public:
int getnum2(string str){
string org;
if(str[0]==&#39;(&#39;)org=str.substr(1,2);
else org=str[0];
stringstream out(org);
int ans;
out&amp;gt;&amp;gt;ans;
return ans;
}
vector&amp;lt;int&amp;gt; getnum(string str){
stringstream out(str);
vector&amp;lt;int&amp;gt; ans(3,0);
string a0,a1,a2,b,c;
out&amp;gt;&amp;gt;a0&amp;gt;&amp;gt;b&amp;gt;&amp;gt;a1&amp;gt;&amp;gt;c&amp;gt;&amp;gt;a2;
ans[0]=getnum2(a0);
ans[1]=getnum2(a1);
ans[2]=getnum2(a2);</description>
    </item>
    
    <item>
      <title>SRM 286 DIV1 Easy - ExtraBall (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-286-div1-easy---extraball-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 27 Jan 2014 21:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-286-div1-easy---extraball-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=5891&amp;amp;rd=8083
・ビンゴゲームを行う。
・最初に紙には１～７５の数字が書いてあり、その数字がコールされるとその場所をくり抜くことができる。
・ビンゴゲームが終わったときに、与えられたパターンと同じところがくりぬかれたらそのパターンにおけるスコアを得ることができる。
・ここで、ゲームが終わった後にもう一つだけ数字をコールしてもらえることを考える。
・このとき、もう一つ数字をコールしてもらったときに得られる期待値を返す。
解き方 
Exampleを読むことで問題のルールを把握することができるので、あとは実装するだけ。
くり抜かれたパターンが一致するかの関数を作り、くり抜かれていない差が一つかどうかを判定すればあとは簡単。
コード 
class ExtraBall {
public:
bool match(string a,string b){
int dif=0;
FORE(i,0,a.size())if(a[i]==&#39;.&#39;&amp;amp;&amp;amp;b[i]==&#39;X&#39;)dif++;
return dif==1;
}
double expectedPayout(vector&amp;lt;int&amp;gt; card, vector&amp;lt;int&amp;gt; balls, vector&amp;lt;string&amp;gt; patterns, vector&amp;lt;int&amp;gt; prizes) {
string org=&#34;&#34;;
FORE(i,0,card.size())org+=&#39;.&#39;;
FORE(i,0,card.size())FORE(j,0,balls.size())if(card[i]==balls[j])org[i]=&#39;X&#39;;
int cost=0;
FORE(i,0,patterns.size())if(match(org,patterns[i]))cost+=prizes[i];
return (double)cost/(double)(75-balls.size());
}
}; </description>
    </item>
    
    <item>
      <title>Linuxのクロック</title>
      <link>https://chaingng.github.io/post/linux%E3%81%AE%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF/</link>
      <pubDate>Sun, 26 Jan 2014 19:37:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/linux%E3%81%AE%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF/</guid>
      <description>ハードウェアクロックとシステムクロック
Linuxには「ハードウェアクロック」と「システムクロックの」２つが存在します。
「システムクロック」がＯＳで使われている通常の時計であり、ＰＣを立ち上がっているときのみ有効です。メモリ上で管理するためＰＣをシャットダウンすると消えてしまいます。
上記のシステムクロックの仕組みですと、ＰＣを起動するたびに毎回時刻を設定しなければいけません。
初期のＰＣは毎回時刻を設定していました。
ただ現在では、電源が落ちていても内部バッテリーで動くハードウェアクロックが存在します。
ＰＣを立ち上げると、ハードウェアクロックを１度だけ参照してシステムクロックが設定される仕組みになっています。
コマンドでの時刻合わせ
ハードウェアクロックは内部バッテリーで動いているためバッテリーがなくなれば止まってしまい、また時刻のズレも発生してしまいます。時刻合わせにはＮＴＰの設定など色々と方法はありますが、以前手動で設定する必要があったためその方法をメモしておきます。

手動での設定時の注意ですが、
システムクロックはハードウェアクロックを参照して設定されるため、システムクロックだけ直しても再起動すると無効になってしまいます。
そのため、ハードウェアクロックの書き換えが必要になります。

最初に、システムクロックを変更# date --set=&#34;2014/1/26 19:32&#34;
次に、システムクロックをハードウェアクロックに書き込み
# clock -w
これで、ＰＣを再起動しても変更後の時刻が有効になります。
 </description>
    </item>
    
    <item>
      <title>Pythonでモジュールインポート時の注意</title>
      <link>https://chaingng.github.io/post/python%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E6%99%82%E3%81%AE%E6%B3%A8%E6%84%8F/</link>
      <pubDate>Sun, 26 Jan 2014 16:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/python%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E6%99%82%E3%81%AE%E6%B3%A8%E6%84%8F/</guid>
      <description>クローラーを作るのにPythonが使いやすかったので利用したのですが、
そのときにimportでひっかかってしまったのでメモ。
importの書き方
importには２通りの書き方があります。
１つ目は、importにパッケージ名.モジュール名と書く方法。
import urllib.request
こちらの場合はモジュールを使うのにフルパスを書かなければいけないです。
html = urllib.request.urlopen(x)
２つ目は、from　パッケージ名　import モジュール名と書く方法。
from bs4 import BeautifulSoup
こちらはモジュール名だけ書くだけで使用できるので、こちらの方がすっきりします。
datas2 = BeautifulSoup(datas).findAll(&#34;td&#34;, attrs={&#34;class&#34;: &#34;tdSearchResultListKanji&#34;})
import時の注意点
モジュールを利用するには、その上階層にある全てのパッケージ、サブパッケージ名を指定しなければいけないということ。
＃エラー
import urllib
＃正しい
import urllib.request
Ｃに慣れていたので、この書き方にひっかかってしまいました。
どうやら、サブパッケージを設けることでお互いがお互いの使用モジュールについて気にしなくてもよいからこの書き方をしているとのことです。
http://docs.python.jp/2.5/tut/node8.html
 </description>
    </item>
    
    <item>
      <title>SRM 485 DIV1 Easy - AfraidOfEven (復習×)</title>
      <link>https://chaingng.github.io/post/srm-485-div1-easy---afraidofeven-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 26 Jan 2014 13:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-485-div1-easy---afraidofeven-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11146&amp;amp;rd=14238
・ある数列が与えられる。
・その数列は等差数列だが、偶数の数字は奇数になるまで２で割られている。
このとき、もとの等差数列を求める。
解き方 
等差数列の差と、初項が決まれば等差数列になるかどうかは容易に判定できる。
問題文から数字はintの範囲なので、この範囲で全探索すれば答えが求まる。
＃もしくは、初項が偶数・奇数、差が偶数、奇数の場合を考えると
２項目から０項目の差/2、もしくは３項目から１項目の差/2が答えになることがわかる。
コード 
class AfraidOfEven {
public:
vector&amp;lt;int&amp;gt; calc(vector&amp;lt;int&amp;gt; org,int d){
int invalid=0;
FORE(i,1,org.size()){
while(1){
if(org[i]!=org[i-1]+d)org[i]*=2;
else break;
if(org[i]&amp;lt;1||org[i]&amp;gt;org[i-1]+d){
invalid=1;
break;
}
}
if(invalid){
org[0]=-1;
return org;
}
}
return org;
}
vector&amp;lt;int&amp;gt; restoreProgression(vector&amp;lt;int&amp;gt; seq) {
vector&amp;lt;int&amp;gt; ans;
FORE(d,-1000,1001){
vector&amp;lt;int&amp;gt; cur=seq;
while(cur[0]&amp;lt;=1e+9){
vector&amp;lt;int&amp;gt; tmp=calc(cur,d);
if(tmp[0]!=-1 &amp;amp;&amp;amp; (ans.empty()||ans&amp;gt;tmp))ans=tmp;
if(cur[0]&amp;gt;1e+8)break;
cur[0]*=2;
}
}
return ans;
}
};
using namespace std;
#define all(c) (c).</description>
    </item>
    
    <item>
      <title>SRM 501 DIV1 Easy - FoxPlayingGame (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-501-div1-easy---foxplayinggame-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 26 Jan 2014 10:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-501-div1-easy---foxplayinggame-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11284&amp;amp;rd=14430
・nA,nB,paramA,paramBが与えられる。
・最初は０から始まり、nA回だけparamA/1000を足し、nB回だけparamB/1000をかける。それぞれは好きな順番で行ってもよい。
このとき、最大となる値を求める。
解き方 
２つ解き方がある。
１つ目は、与えられたパラメータによって法則を見つける、場合分けして解く方法。
きちんと整理すれば解くことはできるが、少し複雑なので時間がかかってしまう。
２つ目は、dpを利用する方法。
今回は乗算の際に最大と最小が入れかわる可能性があるので、最大を求める通常のｄｐ１と最小を求めるｄｐ２の２つが必要。
データ構造と解き方が分かればこちらが確実でコーディングも早い。
コードは上記がｄｐの方法、コメントアウトしているのが１つめの方法。
コード 
class FoxPlayingGame {
public:
double theMax(int nA, int nB, int paramA, int paramB) {
double dp1[60][60]={},dp2[60][60]={};
FORE(i,0,nA+1){
FORE(j,0,nB+1){
if(i+j){
dp1[i][j]=-1e+100;
dp2[i][j]=1e+100;
}
if(i)dp1[i][j]=max(dp1[i][j],dp1[i-1][j]+0.001*paramA);
if(j)dp1[i][j]=max(dp1[i][j],max(dp1[i][j-1]*0.001*paramB,dp2[i][j-1]*0.001*paramB));
if(i)dp2[i][j]=min(dp2[i][j],dp2[i-1][j]+0.001*paramA);
if(j)dp2[i][j]=min(dp2[i][j],min(dp1[i][j-1]*0.001*paramB,dp2[i][j-1]*0.001*paramB));
}
}
return dp1[nA][nB];
/*double ret=0.0;
double pA=paramA/1000.0;
double pB=paramB/1000.0;
if(pA&amp;gt;=0){
if(pB&amp;gt;=1)ret=nA*pA*pow(pB,nB);
else if(-1&amp;lt;=pB&amp;amp;&amp;amp;pB&amp;lt;1)ret=nA*pA;
else {
if(nB%2==1)nB=max(0,nB-1);
ret=nA*pA*pow(pB,nB);
}
}
else{
if(pB&amp;gt;=1)ret=nA*pA;
else if(0&amp;lt;=pB&amp;amp;&amp;amp;pB&amp;lt;1)ret=nA*pA*pow(pB,nB);
else if(-1&amp;lt;=pB&amp;amp;&amp;amp;pB&amp;lt;0)ret=nA*pA*pow(pB,nB&amp;gt;0);
else{</description>
    </item>
    
    <item>
      <title>SRM 505 DIV1 Easy - RectangleArea (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-505-div1-easy---rectanglearea-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 26 Jan 2014 08:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-505-div1-easy---rectanglearea-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11400&amp;amp;rd=14434
・縦横の長さが異なる四角形がＮ＊Ｍ個与えられる。
ただし、同じ行にある四角形の縦の長さは同じであり、同じ列にある四角形の横の長さは同じである。
・最初にそれぞれの四角形について縦横の長さがわかっているもの、わかっていないもののリストが与えられる。
・わかっていない四角形については質問することで教えてもらうことができる。
・Ｎ＊Ｍ個の四角形を合わせた全体の面積を求めたいとき、必要な質問の最小回数を求める。
解き方 
Exampleより、任意の四角形を作ったときの３辺がわかれば残りの１辺を求めることができる。
配列全体に対し上記の処理を行う関数を作り、収束するたびに質問を加え、
関数を再実行することを繰り返していけばよい。
・反省：Exampleよりすべての面積を求める方法、ととらえてしまった。
４辺のうち３つがわかると残りの一つがわかる、ととらえられるかがポイントだった。
コード 
class RectangleArea {
public:
bool calc(){
FORE(i,0,H){
FORE(j,0,W){
FORE(k,1,H-i){
FORE(l,1,W-j){
if(dp[i][j]+dp[i][j+l]+dp[i+k][j]+dp[i+k][j+l]==3){
dp[i][j]=dp[i][j+l]=dp[i+k][j]=dp[i+k][j+l]=1;
calc();
return true;
}
}
}
}
}
return false;
}
int minimumQueries(vector&amp;lt;string&amp;gt; known) {
int ret=0;
W=known[0].size();
H=known.size();
memset(dp,0,sizeof(dp));
FORE(i,0,H)FORE(j,0,W)if(known[i][j]==&#39;Y&#39;)dp[i][j]=1;
calc();
while(1){
int finish=1,xidx=0,yidx=0;
FORE(i,0,H)if(dp[i][0]==0)finish=0,xidx=0,yidx=i;
FORE(j,0,W)if(dp[0][j]==0)finish=0,xidx=j,yidx=0;
if(finish)break;
dp[yidx][xidx]=1;
ret++;
calc();
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 596 DIV1 Easy - IncrementAndDoubling (復習○)</title>
      <link>https://chaingng.github.io/post/srm-596-div1-easy---incrementanddoubling-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 26 Jan 2014 00:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-596-div1-easy---incrementanddoubling-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12790&amp;amp;rd=15708
・求める整数の集合が与えられる。
・オペレーションはひとつの整数を１足すか全ての整数を２かけるかの２種類。
・各整数は０からスタートし、オペレーションを繰り返して求める整数の集合にする。
・このとき、必要な最小オペレーション回数を求める。
解き方 
全体の積の回数を正しく求められるかがポイント。
０にかけても０になることを利用できることがわかれば、
各整数の中で最大の積の回数が配列全体の積の回数と等しいことが導ける。
各整数の積と和の回数は２進数で考えることで求められる。
積の回数は２進数にしたときの桁数ー１であり、
和の回数は２進数にしたときの１の個数になる。
コード 
class IncrementAndDoubling {
public: int getMin(vector&amp;lt;int&amp;gt; desiredArray) {
int m=1;
int add=0;
FORE(i,0,desiredArray.size()){
int tmp=0;
while(desiredArray[i]&amp;gt;0){
tmp++;
add+=desiredArray[i]%2;
desiredArray[i]/=2;
}
m=max(m,tmp);
}
return m-1+add;
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).</description>
    </item>
    
    <item>
      <title>SRM 207 DIV1 Easy - RegularSeason (復習○)</title>
      <link>https://chaingng.github.io/post/srm-207-div1-easy---regularseason-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 20:56:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-207-div1-easy---regularseason-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2866&amp;amp;rd=5853
・複数のチームが総当たりで対戦する。
・各チームは与えられた対戦数をホーム・アウェーで対戦する。
・対戦する際の勝率が与えられる。
・勝つ試合数は勝率＊対戦数の和を最後に四捨五入(round up)したものになる。
・最後に勝った試合数の降順、同じ場合は四捨五入前の勝った試合数の降順、それも同じ場合はチーム名の昇順で”チーム名　勝った試合数”のフォーマットで返す。
解き方 
勝率の求め方が少しわかりにくくて苦労しました。
最後のソートは構造体のソートを書きましたが、
四捨五入前の数字があれば勝った試合数の降順は使わなくてもよいことに気づけばもっと単純にかけました。
計算ごとに１００で割るのではなく、最後に１００で割るのが丸め誤差を防ぐポイント。
コード 
class RegularSeason {
public:
struct team{
double points;
int score;
string name;
bool operator&amp;lt;(const team &amp;amp; v)const{
if(score!=v.score)return score&amp;gt;v.score;
if(points!=v.points)return points&amp;gt;v.points;
return name&amp;lt;v.name;
}
};
vector&amp;lt;string&amp;gt; finalStandings(vector&amp;lt;string&amp;gt; teams, int rounds) {
int n=teams.size();
vector&amp;lt;team&amp;gt; t(n);
vector&amp;lt;string&amp;gt; ans(n,&#34;&#34;);
FORE(i,0,n){
stringstream out(teams[i]);
out&amp;gt;&amp;gt;t[i].name;
FORE(j,0,n){
double num;
out&amp;gt;&amp;gt;num;
if(i==j)continue;
else{
t[i].points+=num*rounds;
t[j].points+=(100-num)*rounds;
}
}
}</description>
    </item>
    
    <item>
      <title>SRM 310 DIV1 Easy - PyramidOfCubes (復習○)</title>
      <link>https://chaingng.github.io/post/srm-310-div1-easy---pyramidofcubes-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 18:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-310-div1-easy---pyramidofcubes-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6577&amp;amp;rd=9990
・１＊１のキューブが任意の数与えられる。
・キューブを３＊３、２＊２、１＊１のようにピラミッド状に積み重ねていく。
下より作っていき、足りなければそこで積み重ねを終える。
このとき、積み重ねたキューブの表面積を求める。
解き方 
シミュレーション問題なので、いかに簡単にコーディングするかがポイント。
表面積の計算は、以下が独立であることが分かる。
①上下部分
②左右部分の手前奥部分
③左右部分の横部分
①については、一番下のキューブの数によって計算可能。
②については、残りのキューブの数とそのときの１辺の長さにて計算可能。
③については、さらに残ったキューブの数により計算可能。
最後にコーディングの順番を整理する。
まずはキューブの数と最大となる１辺の長さから①を計算。
次に②、③について計算。
土台を作ることができれば②，③は現在の１辺の長さ＊４。
作ることができなければ、
②は残りのキューブの数と現在の１辺の長さの小さい方。
③は１辺の長さを作ることができる数＋余り分となる。
コード 
class PyramidOfCubes {
public: double surface(int K) {
double ret=0.0;
int maxlen;
long long tmp=0LL;
for(int i=1;;i++){
tmp+=i*i;
if(tmp&amp;gt;=K){
maxlen=i;
break;
}
}
if(K&amp;gt;=maxlen*maxlen)ret+=maxlen*maxlen*2;
else ret+=K*2;
for(int len=maxlen;len&amp;gt;=1;len--){
if(K&amp;lt;=0)break;
if(K&amp;gt;=len*len){
ret+=len*4;
K-=len*len;
continue;
}
if(K&amp;gt;=len)ret+=len*2;
else ret+=K*2;
while(K&amp;gt;0){
ret+=2;
K-=len;
}
}
return ret;</description>
    </item>
    
    <item>
      <title>SRM 416 DIV1 Easy - NextNumber （復習○）</title>
      <link>https://chaingng.github.io/post/srm-416-div1-easy---nextnumber-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 17:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-416-div1-easy---nextnumber-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8576&amp;amp;rd=13507
・整数Ｎが与えられる。
・整数Ｎを２進数にしたときの１の数が同じで、かつＮより大きい最小の数を求める。
解き方 
法則が少し複雑。
サンプルを見てみると、以下のことがわかる。
①右から走査し、最初に１が存在したらそこから次に０が出る箇所が１になる。
②１にした箇所より右を、それまで残っている１の分だけ右から詰める。
ビット列走査により以下のように求められる。
最初に１が存在する箇所：N &amp;amp; -N(=x)
０から１にする箇所　：~(N+x=y)&amp;amp;N(=z)
１にした箇所から左部分：y(=N+x)
１にした箇所より右部分：z/x&amp;gt;&amp;gt;1
コード 
class NextNumber {
public: int getNextNumber(int N) {
int x=N&amp;amp;(-N);
int y=N+x;
int z=N&amp;amp;(~y);
return y|(z/x&amp;gt;&amp;gt;1);
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)</description>
    </item>
    
    <item>
      <title>SRM 145 DIV1 Easy - Bonuses （復習○）</title>
      <link>https://chaingng.github.io/post/srm-145-div1-easy---bonuses-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 15:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-145-div1-easy---bonuses-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://topcoder.bgcoder.com/print.php?id=276
・従業員それぞれに対し、稼いだポイントが与えられる。
・稼いだポイントに対し、ボーナスの配分を決めたい。
・ボーナスの配分の割合は、全従業員のポイント数に対する各従業員のポイントとする。ただし、割り切れない場合は切り捨てとする。
・最後に切り捨てて余った分の割合は、ポイントの多い従業員から順に１％ずつ割り当てる。同じポイントの場合は順番が最初の方に割り当てる。
解き方 
余ったポイントの割り当て方だけコーディングできれば簡単に解ける。
ソートを使いたいところだが、規則が簡単なので割り当て済みかを判定する配列を使ってあげれば簡単に実装できる。
コード 
class Bonuses {
public: vector&amp;lt;int&amp;gt; getDivision(vector&amp;lt;int&amp;gt; points) {
int n=points.size();
vector&amp;lt;int&amp;gt; ans(n,0);
double sum=0;
FORE(i,0,n)sum+=points[i];
int score=100;
FORE(i,0,n){
int tmp=(points[i]/sum)*100.0;
ans[i]=tmp;
score-=tmp;
}
vector&amp;lt;int&amp;gt; used(n,0);
FORE(i,0,score){
int cmax=-1,idx=-1;
FORE(j,0,n){
if(used[j])continue;
if(cmax&amp;lt;points[j]){
cmax=points[j];
idx=j;
}
}
ans[idx]++;
used[idx]=1;
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 171 DIV1 Easy - CrossCountry (復習○)</title>
      <link>https://chaingng.github.io/post/srm-171-div1-easy---crosscountry-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 13:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-171-div1-easy---crosscountry-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1950&amp;amp;rd=4660
・チーム数と、ゴールしたメンバーのチーム名が到着順に与えられる。
・チームのスコアは最初にゴールした５人の到着順の和になる。
ゴールした人数が５人未満のチームはカウント対象にならない。
・スコアの小さい順にチームを並べる。
スコアが同じとき、６人目のゴール者がいる場合はその到着が早い方が先になる。
６人目のゴール者がいない場合は６人目のゴール者がいる方が先になる。
それでも同一の場合は、チーム名の昇順になる。
このとき、チーム名を順番に並べた文字列を返す。
解き方 
ソートの方法が複雑なので、独自にソート順を定義する。
こちらを参考にさせていただきました。
http://d.hatena.ne.jp/minus9d/20130501/1367415668
コード 
class CrossCountry {
public:
struct team{
int score;
int sixth;
char name;
bool operator&amp;lt;(const team &amp;amp; a)const{
if(score!=a.score)return score&amp;lt;a.score;
if(sixth!=a.sixth)return sixth&amp;lt;a.sixth;
return name&amp;lt;a.name;
}
};
string scoreMeet(int numTeams, string finishOrder) {
vector&amp;lt;team&amp;gt; teams;
string ans=&#34;&#34;;
FORE(i,0,numTeams){
team t;
t.score=0;
t.sixth=10000;
t.name=&#39;A&#39;+i;
int num=0;
FORE(j,0,finishOrder.size()){
if((&#39;A&#39;+i)==finishOrder[j]){
if(num&amp;lt;5)t.score+=j;
else if(num==5)t.sixth=j;
num++;
}
}
if(num&amp;gt;=5)teams.push_back(t);</description>
    </item>
    
    <item>
      <title>SRM 226 DIV1 Easy - ManhattanMovement (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-226-div1-easy---manhattanmovement-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 11:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-226-div1-easy---manhattanmovement-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=3498&amp;amp;rd=6515
・直線ax+by=1、スタート位置（x0,y0）が与えられる。
・スタート位置から直線上の点まで移動する。
・ただし、ｘ軸に平行、もしくはｙ軸に平行のどちらか１回しか移動できない。
このとき、スタート位置から直線上の点まで移動するための最小の距離を求める。
解き方 
問題文のｘ軸に平行もしくはｙ軸に平行の部分について、どちらも利用できると判断してしまった。
計算式を変換して、ｘ軸に対する平行移動とｙ軸に対する平行移動のうちどちらか最小を返してあげればよい。
コード 
class ManhattanMovement {
public: double getDistance(int a, int b, int x0, int y0) {
double ans=1e+18;
if(a!=0)ans=min(ans,fabs( (1.0-(double)b*(double)y0)/(double)a -(double)x0 ));
if(b!=0)ans=min(ans,fabs( (1.0-(double)a*(double)x0)/(double)b -(double)y0 ));
return &amp;nbsp;ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 249 DIV1 Easy - TableSeating (復習×)</title>
      <link>https://chaingng.github.io/post/srm-249-div1-easy---tableseating-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 25 Jan 2014 10:51:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-249-div1-easy---tableseating-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=4616&amp;amp;rd=7224
・テーブルが複数存在する。
・各グループ人数ごとに来店する確率が与えられる。
来店する回数に制限はない。
・グループがきたときに、空いているテーブルにランダムに案内する。
ただし、グループが複数人のときは連続したテーブルに案内しなければならない。
各テーブルには１人席に着く。
このとき、テーブルに着席する人数の期待値を求める。
解き方
全探索では解けないので、ｄｐを利用する。
ｄｐをどう設計するかがポイントで、現在の席の空き状態を引数とすることで解くことができる。
同じグループ人数については何度選択してもよいので、その空き状態に対して全てのグループ数とその座り方について探索する。
こちらのコードを参考にさせていただきました。
http://community.topcoder.com/stat?c=problem_solution&amp;amp;rd=7224&amp;amp;pm=4616&amp;amp;cr=7459326
コード 
class TableSeating {
public:
double getExpected(int num, vector&amp;lt;int&amp;gt; probs) {
double dp[(1&amp;lt;&amp;lt;12)]={0};
bool can[15];
FORE(i,1,(1&amp;lt;&amp;lt;num)){
FORE(j,0,probs.size()){
int s=j+1;
double p=probs[j]/100.0;
FORE(k,0,15)can[k]=false;
FORE(k,0,15){
int uu=(1&amp;lt;&amp;lt;(k+s))-(1&amp;lt;&amp;lt;k);
if(k+s&amp;lt;=num &amp;amp;&amp;amp; ((i&amp;amp;uu)==uu) )can[k]=true;
}
int cnt=0;
FORE(k,0,15)cnt+=can[k];
p/=(double)cnt;
FORE(k,0,15){
if(!can[k])continue;
int uu=(1&amp;lt;&amp;lt;(k+s))-(1&amp;lt;&amp;lt;k);
dp[i]+=p*(dp[i-uu]+s);
}
}
}
return dp[(1&amp;lt;&amp;lt;num)-1];
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)</description>
    </item>
    
    <item>
      <title>SRM 296 DIV1 Easy - NewAlbum (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-296-div1-easy---newalbum-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 24 Jan 2014 00:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-296-div1-easy---newalbum-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6085&amp;amp;rd=9817
・与えられた曲を全てＣＤに収録したい。
・曲の長さは全て同じ秒数。
・１つのＣＤに入れられる秒数も決められている。
・ＣＤに収録する際、曲の間には必ず１秒空けなければいけない。
・ただし、１つのＣＤに収録される曲数は１３の倍数になってはいけない。
曲の長さと１つのＣＤに入れられる秒数、全曲数が与えられた時、
必要なＣＤの最小数を求める。
解き方 
数学的に解くことができるが、少しトリッキー。
ＣＤに入れられる曲数だけめいっぱい入れていき、
最後に余った曲数に対して、１３の倍数でなければ１曲のみ他のＣＤに移せばよいので、答えはＣＤに入れられる曲数で割った数になる。
１３の倍数のとき、他のＣＤがないとき、もしくは１引いたときその数が１３の倍数になるときは新たなＣＤに焼かなければいけないので＋１となる。
上記のように少し考察が必要だが、ｄｐで解けば簡単に解くことができる。
文字列のｄｐと同様１次元配列を用い、
その曲数までの最小ＣＤ数を求めてあげればよい。
コード 
class NewAlbum {
public: int leastAmountOfCDs(int nSongs, int length, int cdCapacity) {
int dp[nSongs+1];
int num=(cdCapacity+1)/(length+1);
dp[0]=0;
FORE(i,1,nSongs+1){
dp[i]=100000;
FORE(j,1,min(num,i)+1)if(j%13!=0)dp[i]=min(dp[i],1+dp[i-j]);
}
return dp[nSongs];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 304 DIV1 Easy - PolyMove (復習×)</title>
      <link>https://chaingng.github.io/post/srm-304-div1-easy---polymove-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 22 Jan 2014 23:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-304-div1-easy---polymove-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6190&amp;amp;rd=9825
・ある多角形が与えられる。
・多角形のうち複数の点を１だけ動かすことができる。
・ただし、１度動かした点と隣り合う点は動かすことができない。
・また最初の点と最後の点との接続には境界があり、この２つを接続しているとみなすことはできない。
このとき、任意の点を動かした時最大となる面積の増分を求める。
解き方 
ｄｐの問題。
dp[i] ： 点i-1までの最大面積と定義
点i-1を動かすか動かさないか、以下のいずれかの最大値を取る
・dp[i-1] (点i-1を動かさないケース)
・dp[i-2]+score(点i-1を動かしたときのスコア、点iと点i-2は動かさない)
ただし、線形にｄｐで解くためには境界についての条件を考慮しなければならない。
境界について以下の３つに分けることで単純なｄｐになる。
・点０、点n－１が動かない場合（０とn－１の間に境界）
・点０のみ動く場合（１と２の間に境界）
・点ｎ－１のみ動く場合（０と１の間に境界）
３つの最大のものが最終的な答えになる。


コード 
class PolyMove {
public:
double calc(int x1,int y1,int x2,int y2){
return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))*0.5;
}
double addedArea(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) {
double ret=0.0;
int n=x.size();
double dp[n];
memset(dp,0,sizeof(dp));
FORE(i,2,n)dp[i]=max(dp[i-1],dp[i-2]+calc(x[i-2],y[i-2],x[i],y[i]));
ret=max(ret,dp[n-1]);
memset(dp,0,sizeof(dp));
dp[1]=calc(x[1],y[1],x[n-1],y[n-1]);
dp[2]=dp[1];
FORE(i,3,n)dp[i]=max(dp[i-1],dp[i-2]+calc(x[i-2],y[i-2],x[i],y[i]));
ret=max(ret,dp[n-1]);
memset(dp,0,sizeof(dp));
dp[0]=calc(x[0],y[0],x[n-2],y[n-2]);
dp[1]=dp[0];
FORE(i,2,n-1)dp[i]=max(dp[i-1],dp[i-2]+calc(x[i-2],y[i-2],x[i],y[i]));
ret=max(ret,dp[n-2]);
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 325 DIV1 Easy - FenceRepairing （復習○）</title>
      <link>https://chaingng.github.io/post/srm-325-div1-easy---fencerepairing-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 22 Jan 2014 07:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-325-div1-easy---fencerepairing-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6827&amp;amp;rd=10005
・穴のあいたフェンスがある。
・フェンスを修理するには、sqrt(選んだ長さ)のコストが必要になる。
このとき、フェンスを修理するのに最小のコストを求める。
解き方 
必ずしも、部分的に修理するのが最適解ではないと問題文にあるように、修理方法をパターン化するのは難しい。
そこで、ｄｐを使って解く。
現在のフェンスの箇所が穴が開いていなければ前のｄｐと同じ答えになることから、
dp[n+1]にてdp[i]はi-1番目までのフェンスの修理コストの最小と定義する。
i番目からn番目まで走査し、0のときは前の値がないのでdp[0]=0として解いてあげればよい。
コード 
class FenceRepairing {
public:
double calculateCost(vector&amp;lt;string&amp;gt; boards) {
string str=&#34;&#34;;
double INF=10000.0;
FORE(i,0,boards.size())str+=boards[i];
int n=str.size();
double dp[n+1];
FORE(i,1,n+1)dp[i]=INF;
dp[0]=0.0;
FORE(i,1,n+1){
if(str[i-1]==&#39;.&#39;)dp[i]=dp[i-1];
else FORE(j,0,i)dp[i]=min(dp[i],dp[j]+sqrt(i-j));
}
return dp[n];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 327 DIV1 Easy - NiceOrUgly (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-327-div1-easy---niceorugly-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 20 Jan 2014 20:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-327-div1-easy---niceorugly-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=6871&amp;amp;rd=10007
・？を含んだ文字列が与えられる。
・母音が３つ連続する、または子音が５つ連続したらその文字列はＵＧＬYであり、そうでなければＮＩＣＥである。
・？は任意の文字に置き換えられる。
このとき、与えられた文字列がＮＩＣＥであればＮＩＣＥを返し、ＵＧＬＹであればＵＧＬＹ，どちらもあり得るのであれば４２を返す。
解き方 
文字の長さが最大５０であることから全探索はできない。
ここでｄｐを考えると、状態の数はdp[50][3][5]であるためdpで解くことができる。
コード 
int dp[100][100][100];
string str;
class NiceOrUgly {
public:
bool is_vow(char ch){
return ch==&#39;A&#39;||ch==&#39;E&#39;||ch==&#39;I&#39;||ch==&#39;O&#39;||ch==&#39;U&#39;;
}
int calc(int pos,int x,int y){
if(x&amp;gt;=3||y&amp;gt;=5)return 2;
if(pos&amp;gt;=str.size())return 1;
if(dp[pos][x][y]!=-1)return dp[pos][x][y];
int ret=0;
if(str[pos]==&#39;?&#39;){
ret|=calc(pos+1,x+1,0);
ret|=calc(pos+1,0,y+1);
}
else{
if(is_vow(str[pos]))ret|=calc(pos+1,x+1,0);
else ret|=calc(pos+1,0,y+1);
}
return dp[pos][x][y]=ret;
}
string describe(string s) {
memset(dp,-1,sizeof(dp));
str=s;
int ret=calc(0,0,0);
if(ret==3)return &#34;42&#34;;
if(ret==1)return &#34;NICE&#34;;
return &#34;UGLY&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 340 DIV1 Easy - ProblemsToSolve ××○</title>
      <link>https://chaingng.github.io/post/srm-340-div1-easy---problemstosolve-/</link>
      <pubDate>Mon, 20 Jan 2014 19:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-340-div1-easy---problemstosolve-/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7504&amp;amp;rd=10664
・各問題について、その楽しさの値が与えられる。
・最初は０番目の問題を解く。その後、次の問題かその次の問題を選んでいく。
・選んだ問題の楽しさの値の最小と最大の差が、指定された値より大きくなればそこで終了。そうでなければ、全ての問題を解かなければいけない。
このとき、解かなければならない問題の最小値を求める。
解き方 
問題数が最大５０なので、全探索で解けない。
問題の条件より、ある２つを選んだときその差が指定値より大きければ終了になる。
そのため全ての２つの組み合わせの中から、その差が指定値より大きくなるもの全てについて最小値を求めて更新していけばよい。
コード 
class ProblemsToSolve {
public: int minNumber(vector&amp;lt;int&amp;gt; p, int variety) {
int n=p.size();
int ret=n;
FORE(i,0,n)FORE(j,i+1,n){
if(abs(p[j]-p[i])&amp;gt;=variety)ret=min(ret,(i+3)/2+(j-i+1)/2);
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 352 DIV1 Easy - NumberofFiboCalls （復習○）</title>
      <link>https://chaingng.github.io/post/srm-352-div1-easy---numberoffibocalls-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 18 Jan 2014 09:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-352-div1-easy---numberoffibocalls-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=2292&amp;amp;rd=10709
フィボナッチ数の計算が再帰プログラムで書かれている。
このとき、ある整数ｎのフィボナッチ数を求めるときに再帰プログラムにて１と０が出力される回数を求める。
解き方 
ｎの最大が４０のため全探索では解くことができない。
ここで、ある数xまでに出力される０と１の回数もフィボナッチ数と同様に、
x-1とあるx-2の０と１の回数の和で求められることがわかる。
これをｄｐで実装する。
コード 
class NumberofFiboCalls {
public: vector&amp;lt;int&amp;gt; fiboCallsMade(int n) {
vector&amp;lt;int&amp;gt; ans;
int dp0[n+1],dp1[n+1];
memset(dp0,0,sizeof(dp0));
memset(dp1,0,sizeof(dp1));
dp0[0]=1,dp1[1]=1;
FORE(i,2,n+1){
dp0[i]=dp0[i-1]+dp0[i-2];
dp1[i]=dp1[i-1]+dp1[i-2];
}
ans.push_back(dp0[n]);
ans.push_back(dp1[n]);
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 422 DIV1 Easy - PrimeSoccer (復習○)</title>
      <link>https://chaingng.github.io/post/srm-422-div1-easy---primesoccer-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 18 Jan 2014 09:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-422-div1-easy---primesoccer-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10033&amp;amp;rd=13513
・チームＡとＢがサッカーゲームを行う。
・ゲームは９０分あり、５分ごと、１８回のセグメントに分けられる。
・各セグメントごと、各チームはあらかじめ与えられた確率でゴールする。
・各セグメントごとのゴール数は０か１となる。
このとき、ゲームが終わったときＡもしくはＢのスコアが素数となる確率を求める。
解き方 
２＾３６となるので全探索では解くことができない。
ここで、最大が１８なので素数の数は７個に限られる。
次に、ゴール数をｎ、Ａのゴールする確率がＰのときの確率は
P^n * (1-P)^(18-n)*18Cnとなる。
最後に、Aの素数となる確率とＢの素数となる確率で重複が発生する。
Aのゴール数が素数となる確率をPa、Ｂのゴール数が素数となる確率をPbとすると
Pa+Pb-Pa*Pbが答えになる。
コード 
class PrimeSoccer {
public:
double calc(double x){
int p[]={2,3,5,7,11,13,17};
double ret=0.0;
FORE(i,0,7){
double tmp=1.0;
for(double n=18.0;n&amp;gt;(double)(18-p[i]);n--)tmp*=n;
for(double n=1.0;n&amp;lt;=(double)p[i];n++)tmp/=n;
tmp=tmp*pow(x,p[i])*pow(1.0-x,18-p[i]);
ret+=tmp;
}
return ret;
}
double getProbability(int skillOfTeamA, int skillOfTeamB) {
double Pa=calc((double)skillOfTeamA/100.0);
double Pb=calc((double)skillOfTeamB/100.0);
return Pa+Pb-Pa*Pb;
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i !</description>
    </item>
    
    <item>
      <title>SRM 366 DIV1 Easy - ChangingSounds （復習○）</title>
      <link>https://chaingng.github.io/post/srm-366-div1-easy---changingsounds-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 17 Jan 2014 22:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-366-div1-easy---changingsounds-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7973&amp;amp;rd=10781
・ある曲数分、その曲を再生する前に調整可能なボリュームが与えられる。
・与えられたボリュームに対し、そのボリューム分音を大きくするか、小さくすることができる。ただし、０以上最大ボリューム以下にならなければいけない。
・最初のボリュームが与えられた時、最後の曲を再生し終わった後に最大のボリューム数を求める。全て再生できなければー１を返す。
解き方 
2^50=10^15のため全探索することはできない。
ただし、ボリューム数が０～１０００の間に収まり曲数が最大５０のため
dpで解くことができる。
コード 
class ChangingSounds {
public:
int maxFinal(vector&amp;lt;int&amp;gt; C, int beginLevel, int maxLevel) {
int ret=-1,n=C.size();
int dp[n+1][maxLevel+1];
memset(dp,0,sizeof(dp));
dp[0][beginLevel]=1;
FORE(i,0,n){
FORE(j,0,maxLevel+1){
if(dp[i][j]){
if(j+C[i]&amp;lt;=maxLevel)dp[i+1][j+C[i]]=1;
if(j-C[i]&amp;gt;=0)dp[i+1][j-C[i]]=1;
}
}
}
FORE(i,0,maxLevel+1)if(dp[n][i])ret=i;
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 411 DIV1 Easy - SentenceDecomposition （復習○）</title>
      <link>https://chaingng.github.io/post/srm-411-div1-easy---sentencedecomposition-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 17 Jan 2014 08:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-411-div1-easy---sentencedecomposition-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=8692&amp;amp;rd=12183
・ある文と、単語の一覧が与えられる。
・ある文を、与えられた単語を使って変換したい。
・与えられた単語の順番を変えることで、ある文の一部と一致すればその一部を変換することができる。
・変換するコストは、順番を変えた数になる。
このとき、変換するコストの最小値を求める。変換できなければー１を返す。
解き方 
ｄｐを使って解く。
dp[n=与えられた文字数]をとり、dp[i]をi番目までの最小のコストと定義する。
dp[i]はiまでの文字をまとめて変換できるか、
j&amp;lt;iとなるdp[j]が存在する場合j+1～iまでの文字が変換できるかを判定し
最小値を更新していく。
コード 
class SentenceDecomposition {
public:
int rec(string s1,string s2){
int cost=0;
FORE(i,0,s1.size())if(s1[i]!=s2[i])cost++;
sort(all(s1));
sort(all(s2));
return s1==s2 ? cost : 1e+9;
}
int decompose(string sentence, vector&amp;lt;string&amp;gt; validWords) {
int n=sentence.size();
int dp[n+1];
FORE(i,0,n+1)dp[i]=1e+9;
dp[0]=0;
for(int i=0;i&amp;lt;n;i++)if(dp[i]!=1e+9){
FORE(j,0,validWords.size()){
int len=validWords[j].size();
if(i+len-1&amp;lt;n){
int cost=rec(sentence.substr(i,len),validWords[j]);
dp[i+len]=min(dp[i+len],dp[i]+cost);
}
}
}
return dp[n]&amp;gt;=1e+9 ? -1 : dp[n];
}
};
using namespace std;</description>
    </item>
    
    <item>
      <title>SRM 594 DIV1 Easy - AstronomicalRecords (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-594-div1-easy---astronomicalrecords-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 14 Jan 2014 23:38:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-594-div1-easy---astronomicalrecords-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12804&amp;amp;rd=15706
・惑星がｎ個存在する。
・惑星の相対サイズを測るシステムＡ，Ｂが存在する。
・各システムは太陽からの距離が近い順からランダムな数を選び、そのシステムとの相対距離を計算する。
このとき、存在しうる惑星の数の最小値を求める。
解き方 
相対距離の最大値は10^9のため全ての値について全探索はできない。
そこで、要素数は最大５０であることから５０＊５０＝２５００分だけの組み合わせに対して調べればよい。
このとき、掛け算で値を考えると小数になるため計算しにくい。
そのため、最小公倍数の計算の仕方を用いて、A[i],B[j]のペアを選んだときＢの要素には全てA[i]をかけ、Aの要素には全てB[j]をかければよい。
上記の処理後は、LCM（Longest Common Sequence）問題に帰着できる。
dpはＡの要素数とＢの要素数の２次元配列を用いる。
dp[i][j]はi,jに到達するまでの最大値と定義し、状態遷移にて答えを求める。
コード 
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class AstronomicalRecords {
public:
int gcd(int x,int y){
return y ? gcd(y,x%y) : x;</description>
    </item>
    
    <item>
      <title>SRM 602 DIV1 Easy - TypoCoderDiv1 (復習××)</title>
      <link>https://chaingng.github.io/post/srm-602-div1-easy---typocoderdiv1-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Mon, 13 Jan 2014 23:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-602-div1-easy---typocoderdiv1-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12924&amp;amp;rd=15820
・現在のレートとコンテストごとの点数が与えられる。
・そのコンテストに勝利した場合はその点数が足され、負けた場合は引かれる。ただし０　未満にはならない。
・レートが２２００以上だとbrown、それ未満だとcielの称号になる。
・２つのコンテスト連続でbrownの称号にならないようにする。
このとき、brownとcielの称号が変化する最大の数を求める。
解き方 
要素数が５０なので全探索では2^50となり間に合わない。
点数の最大が10^9と全てdpすると間に合わないが、連続してbrownにはならないことを考えると点数が2200までのdp[50][2200]を考えればよい。
または、全状態数は50×2200なのでこちらでdpするとより簡単なコードになる。
コード 
map&amp;lt; pair &amp;lt; int, int &amp;gt;, int &amp;gt; p;
vector&amp;lt;int&amp;gt; R;
class TypoCoderDiv1 {
public:
int calc(int pos,int rate){
if(p.count(make_pair(pos,rate)))return p[make_pair(pos,rate)];
if(pos==R.size())return p[make_pair(pos,rate)]=0;
int ret=0;
if(rate&amp;gt;=2200){
int score=rate-min(R[pos],rate);
if(score&amp;gt;=2200)ret=-1000000;
else ret=max(ret,1+calc(pos+1,score));
}else{
int score=rate+R[pos];
if(score&amp;gt;=2200)ret=max(ret,1+calc(pos+1,score));
else ret=max(ret,calc(pos+1,score));
score=rate-min(R[pos],rate);
ret=max(ret,calc(pos+1,score));
}
return p[make_pair(pos,rate)]=ret;
}
int getmax(vector&amp;lt;int&amp;gt; D, int X) {
p.clear();
R=D;
return calc(0,X);
}</description>
    </item>
    
    <item>
      <title>俺のフレンチ</title>
      <link>https://chaingng.github.io/post/%E4%BF%BA%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%83%81/</link>
      <pubDate>Sat, 02 Nov 2013 10:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E4%BF%BA%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%83%81/</guid>
      <description>用事があって表参道に行ったところ、通りがかりに俺のフレンチがあったので行ってきました。
俺のフレンチの中でも一番大きい店舗らしく、すぐに入ることができました。並んでいる間トイレに寄って、みんな集まらないと入店できないとのことで待ちましたがそれがなければもっと早かったかも。
フレンチには珍しく立ち食い形式なんですね。でも料理ひとつひとつがびっくりするほど安く、おいしくてびっくり。
食べたメニューは以下のとおり。





TODAY’s　俺の泡富士ミネラル（360ml）バケットオマールエビのロースト　貴腐ワインソース牛フィレとフォワグラのロッシーニ　トリュフソースワタリガニのトマトクリームスパゲティ
これで一人３５００円くらいなのでいい感じでした。
 </description>
    </item>
    
    <item>
      <title>SRM 503 DIV1 Easy - ToastXToast (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-503-div1-easy---toastxtoast-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 19 Oct 2013 08:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-503-div1-easy---toastxtoast-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11204&amp;amp;rd=14432
様々な種類のトーストがあり、ある焼き時間になるとポッピングシャワーとなるが
その時間未満だと生焼け、その時間を過ぎると焼きすぎになる。
ポッピングシャワーとなる焼き時間はトーストの種類により異なる。
生焼けのトーストとその焼き時間の集合、
焼きすぎのトーストとその焼き時間の集合が与えられた時、
最低何種類のトーストが存在したかを求める。
ただし、集合のうち生焼けと焼きすぎのペアは少なくとも１つは存在する。
そのようなペアが存在しなければー１を返す。
解き方 
生焼けと焼きすぎの境界が１つしかなければ、生焼けのものを１つ、焼きすぎのものを１つにまとめることができるので１種類。
一番生焼けのものが時間が一番早く、一番焦げすぎのものが一番遅ければ、
一番生焼けのもの＆一番焦げすぎのもの以外をまとめて１種類、
一番生焼け以外のもの＆一番焦げすぎのものをまとめて１種類なので
合計２種類。
一番生焼けのものが時間が一番早く、一番焦げすぎのものが一番遅くなければ
ペアが存在しないのでー１。
コード 
class ToastXToast {
public: int bake(vector&amp;lt;int&amp;gt; under, vector&amp;lt;int&amp;gt; over) {
int n=under.size();
int m=over.size();
sort(all(under));
sort(all(over));
if(under[0]&amp;gt;over[0]||over[m-1]&amp;lt;under[n-1])return -1;
if(under[n-1]&amp;lt;over[0])return 1;
return 2;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 431 DIV1 Easy - LaserShooting (復習××)</title>
      <link>https://chaingng.github.io/post/srm-431-div1-easy---lasershooting-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 19 Oct 2013 07:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-431-div1-easy---lasershooting-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10258&amp;amp;rd=13522
（０，０）の位置からレーザーが発射される。
レーザーは（ｘ、ｙ１）（ｘ、ｙ２）の二つの値が与えられ、その間を通るように発射される。ｙ１、ｙ２の範囲は[-2/PI,2/PI]。
このような（ｘ、ｙ１）（ｘ、ｙ２）が複数与えられるとき、ある点がレーザーに当たる確率を求める。
解き方 
全ての点について確率を求めていては間に合わない。
そのため、各(x,y1)(x,y2)に対しレーザーの当たる範囲の確率を足していけばよい。
arctanの使い方を忘れていたので、こちらのサイトを拝見させていただきました。
http://78578203.at.webry.info/201101/article_2.html
コード 
class LaserShooting {
public: double numberOfHits(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y1, vector&amp;lt;int&amp;gt; y2) {
double ret=0.0;
int n=y1.size();
FORE(i,0,n){
double tmp1=atan((double)y1[i]/(double)x[i]);
double tmp2=atan((double)y2[i]/(double)x[i]);
ret+=fabs(tmp1-tmp2)/M_PI;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 482 DIV1 Easy - LockersDivOne （復習○）</title>
      <link>https://chaingng.github.io/post/srm-482-div1-easy---lockersdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Fri, 18 Oct 2013 08:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-482-div1-easy---lockersdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11110&amp;amp;rd=14235
N個のドアがある。
最初は一つおきにドアを開けていく。
次は空いているドアはないとみなして、２つおきにドアをあけていく。
次は３つおき・・・としたときに、最後に空けるドアを求める。
解き方 
Ｎ＝１０＾６。
全探索だとN+N/2+N/(2*3)+N/(2*3*4)・・・
=N(1/2+1/6+1/24...)
最大ケースを試しても240msほどなのでこれで解けます。
こちらを拝見させていただくと、法則を出しても解けるそうです。
http://be.nucl.ap.titech.ac.jp/~kawada/indigo/view/memo341.html
http://d.hatena.ne.jp/kusano_prog/20100915/1284572746
コード 
class LockersDivOne {
public:
int lastOpened(int N) {
vector&amp;lt;int&amp;gt; a;
FORE(i,0,N)a.push_back(i+1);
for(int d=2;;d++){
if(a.size()==1)return a[0];
vector&amp;lt;int&amp;gt; b;
FORE(i,0,a.size())if(i%d!=0)b.push_back(a[i]);
a.swap(b);
}
}
}; </description>
    </item>
    
    <item>
      <title>SRM 428 DIV1 Easy - TheLuckyString (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-428-div1-easy---theluckystring-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 16 Oct 2013 20:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-428-div1-easy---theluckystring-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10180&amp;amp;rd=13519
ある文字列が与えられる。
文字列を入れ替えた時、隣り合う文字が同じアルファベットにならない
場合の数を求める。
解き方 
Ｎ＝１０なので全探索できそうだが、
計算量をきちんとしないとオーバーフローしてしまう。
全ての順列で10!=3628800=3.6*10^6だが
その中で全ての順列について10回の判定で3.6*10^7がぎりぎり。
それ以上、7.2*10^7がエラー境界な感覚なので
上位の人でもエラーとなっている人が多かったです。
nextpermutation＆判定文ではなく、
再帰関数を使うことでO(10!)に近いオーダーで計算することができます。
コード 
class TheLuckyString {
public:
int N;
int total;
string str;
int have[26];
void calc(int pos,char prev){
if(pos==N){
total++;
return;
}
for(int ch=&#39;a&#39;;ch&amp;lt;=&#39;z&#39;;ch++){
if(ch!=prev &amp;amp;&amp;amp; have[ch-&#39;a&#39;]&amp;gt;0){
have[ch-&#39;a&#39;]--;
calc(pos+1,ch);
have[ch-&#39;a&#39;]++;
}
}
}
int count(string s) {
N=s.size();
total=0;
FORE(i,0,26)have[i]=0;
FORE(i,0,N)have[s[i]-&#39;a&#39;]++;
calc(0,&#39; &#39;);
return total;
}
};
using namespace std;
#define all(c) (c).begin(),(c).end()
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)</description>
    </item>
    
    <item>
      <title>SRM 517 DIV1 Easy - CompositeSmash （復習○）</title>
      <link>https://chaingng.github.io/post/srm-517-div1-easy---compositesmash-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 10:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-517-div1-easy---compositesmash-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11535&amp;amp;rd=14542
正の整数Ｎとtargetが与えられる。
Ｎはスマッシュするとx*y=N（x,yは整数）となるｘとｙに分割することができる。
このとき、どうスマッシュしてもtargetが得られるならYes,得られないならNoを返す。
解き方 
ＤＦＳで全探索。
１つの判定関数の中で全ての割り切れる数に対してtrueとなり、
かつ割り切れる数で得られるx,yのいずれかが判定関数でtrueとなるか判定する。
dp化しなければ計算量が超えそうかと思ったけど超えなかった。
こちらのソリューションでメモ化した方がよいかも。
http://community.topcoder.com/stat?c=problem_solution&amp;amp;cr=22263204&amp;amp;rd=14542&amp;amp;pm=11535
コード 
int T;
class CompositeSmash {
public:
bool f(int N){
if(N==T)return true;
bool allfound=true,flag=false;
for(int i=2;i*i&amp;lt;=N;i++){
if(N%i==0){
flag=true;
allfound&amp;amp;=f(i)|f(N/i);
}
}
return flag ? allfound : false;
}
string thePossible(int N, int target) {
T=target;
return f(N) ?&#34;Yes&#34; : &#34;No&#34; ;
}
};
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i !</description>
    </item>
    
    <item>
      <title>SRM 518 DIV1 Easy - LargestSubsequence （復習○）</title>
      <link>https://chaingng.github.io/post/srm-518-div1-easy---largestsubsequence-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 10:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-518-div1-easy---largestsubsequence-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11471&amp;amp;rd=14543
ある文字列が与えられる。
その文字からいくつかの文字を削除したものがそのサブ文字列と定義される。
このとき、辞書順で最も降順となるサブ文字列を求める。
解き方 
現在の文字列で最も降順のアルファベットがサブ文字列の左側にくる。
次に、選ばれたアルファベット以降の位置から上記の文字を探す。
この操作を繰り返すことで答えが求められる。
コード 
class LargestSubsequence {
public: string getLargest(string s) {
string ret;
int cur=0;
while(cur!=s.size()+1){
int tmp=cur;
FORE(i,cur+1,s.size())if(s[i]&amp;gt;s[tmp])tmp=i;
ret+=s[tmp];
cur=tmp+1;
}
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 519 DIV1 Easy - BinaryCards (復習××)</title>
      <link>https://chaingng.github.io/post/srm-519-div1-easy---binarycards-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 10:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-519-div1-easy---binarycards-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11552&amp;amp;rd=14544
正の整数ＡとＢが与えられる。
ＡからＢを得るには、２進数で表わされたＡから各ビットを返していく。
この操作を行ったとき、途中で現れる最大の数を求める。
解き方 
Ａ，Ｂは最大１０＾１８のため単純なシミュレーションでは解くことができない。
そのため、計算量を削減する法則がないか考える。
２進数にしてみて、最初と最後の状態までのプロセスの変化が答えに関連しないか考えてみる。
いくつか例を出してみると、
一度も触ったことがないビットは固定しなければいけないが
「ＡからＢを得るときに１度でもひっくり返したビット以降はすべて１」にできることがわかる。
コード 
class BinaryCards {
public: long long largestNumber(long long A, long long B) {
for(long long i=63;i&amp;gt;=0;i--){
long long x=1LL&amp;lt;&amp;lt;i;
if((A&amp;amp;x)!=(B&amp;amp;x))return A | ( (1LL&amp;lt;&amp;lt;(i+1))-1);
}
return A;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 520 DIV1 Easy - SRMCodingPhase （復習○）</title>
      <link>https://chaingng.github.io/post/srm-520-div1-easy---srmcodingphase-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 08:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-520-div1-easy---srmcodingphase-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11381&amp;amp;rd=14545
SRMの３問の問題を７５分以内で解く。
各問題については、最大獲得ポイントと解くのにかかる時間が与えられる。
各３問については、解いたときに以下のポイントが得られる。
問題０：最大獲得ポイント - ２＊解くのにかかる時間
問題１：最大獲得ポイント - ４＊解くのにかかる時間
問題２：最大獲得ポイント - ８＊解くのにかかる時間
またluckが与えられ、これを使うことで解くのにかかる時間を引くことができる。配分は自由に決められるが各問題１分以上残さなければならない。
各問題について最大獲得ポイント、解くのにかかる時間、luckが与えられた時
得られる最大ポイントを求める。
解き方 
問題０よりも１、１よりも２の方が最大獲得ポイント数が多い。
そのためluckの配分は難しい問題に対して配分すればよいように見えるが、
75分以内で解けない場合があるので75分以内で解けるよう配分した方がよい場合もある。
そこで、問題は３つしかないので解ける問題の組み合わせ全てに対し
難しい問題からluckを配分してあげればよい。
難しい問題からの配分で75分以内に収まらなく解けなくても、違う組み合わせでカバーできている。
コード 
class SRMCodingPhase {
public: int countScore(vector&amp;lt;int&amp;gt; points, vector&amp;lt;int&amp;gt; skills, int luck) {
int ans=0;
for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;3);i++){
int cost=0,tluck=luck,point=0;
for(int j=2;j&amp;gt;=0;j--){
if(i&amp;amp;(1&amp;lt;&amp;lt;j)){
int use=min(tluck,skills[j]-1);
point+=points[j]-(1&amp;lt;&amp;lt;(j+1))*(skills[j]-use);
tluck-=use;
cost+=skills[j];
}
}
if(cost-luck&amp;lt;=75)ans=max(ans,point);
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 521 DIV1 Easy - MissingParentheses （復習○）</title>
      <link>https://chaingng.github.io/post/srm-521-div1-easy---missingparentheses-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 08:27:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-521-div1-easy---missingparentheses-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10943&amp;amp;rd=14546
カッコの並びが与えられる。
カッコがきちんと閉じた形になるために、追加で必要なカッコの数を求める。
解き方 
左カッコが出てきたら＋１、右カッコが出てきたらー１としてカッコの閉じ具合を走査する。
０から始め、マイナスになるときは必ず左にカッコが必要なので答えを＋１して数を０に戻す。
そうでない場合はそのまま走査し、最後に残った数を答えに足せばよい。
コード 
class MissingParentheses {
public: int countCorrections(string par) {
int left=0,ans=0;
FORE(i,0,par.size()){
if(par[i]==&#39;(&#39;)left++;
else if(left&amp;gt;0)left--;
else ans++;
}
return ans+left;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 522 DIV1 Easy - RowAndCoins （復習○）</title>
      <link>https://chaingng.github.io/post/srm-522-div1-easy---rowandcoins-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 08:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-522-div1-easy---rowandcoins-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11566&amp;amp;rd=14547
AliceとBobの２人で行うゲーム。
一行のマスの並びが与えられて、各マスにはＡかＢのどちらかが書かれている。
ゲームはAliceから始まり、連続する任意のマスにコインを置くことができる。
ただし、マスは最低一つコインを置かずに残さなければいけない。
このとき、残った最後のマスがＡならAliceの勝ち、そうでなければBobの勝ちとなる。
一行のマスが与えられた時、どちらが勝つかを求める。
解き方 
単純なシミュレーションに見えるが、全ての手の全探索は難しそう。
ここで「勝ちの法則」がないかを考える。
まず、Aliceは１マスを除いて好きなだけ連続するマスに置けるので、
最初か最後のマスがＡであれば必ず勝ちになる。
次にそうでない場合（両端がＢ）、どう消してもBは残ってしまうので
どうやってもAliceは勝つことができない。
例）BAAABABのとき
①左のＢを消す　：AAABAB →次に右端以外を消されてしまう
②右のＢを消す　：上記と同様
②真ん中のＢを消す：BAAA*AB 左もしくは右のAを消されてＢは残る(B*AB or BA*B)
つまり、両端のどちらかがＡであればAlice、そうでなければBobの勝ちとなる。
コード 
class RowAndCoins {
public: string getWinner(string cells) {
return cells[0]==&#39;B&#39;&amp;amp;&amp;amp;cells[cells.size()-1]==&#39;B&#39; ? &#34;Bob&#34; : &#34;Alice&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 523 DIV1 Easy - CountingSeries (復習××)</title>
      <link>https://chaingng.github.io/post/srm-523-div1-easy---countingseries-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 07:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-523-div1-easy---countingseries-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10957&amp;amp;rd=14548
１からupperBoundまでの数が与えられる。
また、a,b,c,dの正の整数が与えられる。
このとき、a+b*x または c*d^y（x,yは任意の整数）を満たす数がいくつあるか求める。
解き方 
「a+b*x」、「c*d^y」は重複する場合があるので、
重複した場合は１度しか計算しない処理が必要。
「a+b*x」では、各整数は10^12のため全探索では不可。
upperBoundがa以上であれば、 (upperBound-a)/b +1が満たす全ての数になる。
「c*d^y」は全探索が可能。
各数に対して「a+b*x」でも表わせないか判定し重複を調べる。
（同じようにa以上かどうかを調べる）
ただしd=1のときは無限ループになるのでbreak処理が必要。
Challengeポイント
階乗が出てくる場合は1の階乗のbreak処理が入っているか？
数の判定の際は正負の判定が入っているか？
コード 
class CountingSeries {
public: long long countThem(long long a, long long b, long long c, long long d, long long upperBound) {
long long ans=upperBound&amp;gt;=a ? (upperBound-a)/b+1 :0;
for(long long x=c;x&amp;lt;=upperBound;x*=d){
if((x-a)&amp;lt;0||(x-a)%b!=0)ans++;
if(d&amp;lt;=1)break;
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 524 DIV1 Easy - MagicDiamonds (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-524-div1-easy---magicdiamonds-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 13 Oct 2013 07:42:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-524-div1-easy---magicdiamonds-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11607&amp;amp;rd=14549
ｎ個のダイヤモンドを運びたい。
１度に最大ｎ個運ぶことができるが、ｎが素数だった場合消滅してしまう。
このとき、消滅せずに全てのダイヤを運べる最小の回数を求める。
解き方 
ｎが最大１０＾１２のためＤＦＳ等では解くことができない。
そこで法則がないかシミュレーションしてみる。
すると、ｎ＝３（３回）のときを除いて、以下がわかる。
①素数でない場合は、１回で運べる
②素数の場合は、「素数ー１」個＆「１」個の２回で運べる
あとは素数判定関数を作って実装するだけでよい。
コード 
class MagicDiamonds {
public:
bool isprimary(long long x){
if(x==2)return true;
if(x==1||x%2==0)return false;
for(long long i=3;i*i&amp;lt;=x;i+=2)if(x%i==0)return false;
return true;
}
long long minimalTransfer(long long n) {
if(n==3)return 3;
return isprimary(n) ? 2 : 1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 525 DIV1 Easy - DropCoins （復習○）</title>
      <link>https://chaingng.github.io/post/srm-525-div1-easy---dropcoins-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 12 Oct 2013 14:19:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-525-div1-easy---dropcoins-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11665&amp;amp;rd=14550
四角形のセルに複数コインがある。
１回の操作で上下左右に全てのコインを移動させることができ、四角形から外れたコインは落ちる。
コインの数Ｋが与えられた時、コインを落としてＫ個にできるとき最小の操作回数を返す。できないときはー１を返す。
解き方 
全探索で上下左右に動いた時のコインのマスを保存して重複しないようにすればよいと思いつくが、少し複雑。
「最後に残るコインのマスはかならず四角形になる」ことがわかれば、
四角形からすべてのサブ四角形を求め、その四角形にあるコインの数がＫに一致したものが答えの候補になる。
そのときの移動回数は縦横それぞれに対し、角の位置＋戻るために２つのうち最小の角の位置を足してあげればよい。
コード 
class DropCoins {
public: int getMinimum(vector&amp;lt;string&amp;gt; board, int K) {
int INF=1e+8, ret=INF;
int h=board.size(),w=board[0].size();
for(int x0=0;x0&amp;lt;h;x0++){
for(int y0=0;y0&amp;lt;w;y0++){
for(int x1=x0+1;x1&amp;lt;=h;x1++){
for(int y1=y0;y1&amp;lt;=w;y1++){
int coin=0;
FORE(a,x0,x1)FORE(b,y0,y1)if(board[a][b]==&#39;o&#39;)coin++;
if(coin!=K)continue;
int a=x0,b=h-x1,c=y0,d=w-y1;
ret=min(ret,a+b+c+d+min(a,b)+min(c,d));
}
}
}
}
return ret==INF ? -1 : ret;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 526 DIV1 Easy - DucksAlignment （復習○）</title>
      <link>https://chaingng.github.io/post/srm-526-div1-easy---ducksalignment-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 12 Oct 2013 14:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-526-div1-easy---ducksalignment-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11667&amp;amp;rd=14551
四角形のマスにダチョウが複数存在する。
ダチョウを縦か横に一列に並べるとき、必要な最小移動数を求める。
解き方 
縦に並べるときと横に並べるときの２通りを試し小さい方を返す。
縦と横それぞれに対して、並べる列／行と詰めるときの移動数を求めてあげればよい。
コード 
class DucksAlignment {
public: int minimumTime(vector&amp;lt;string&amp;gt; grid) {
int h=grid.size(),w=grid[0].size();
vector&amp;lt;int&amp;gt; tate,yoko;
FORE(i,0,h){
FORE(j,0,w){
if(grid[i][j]==&#39;o&#39;){
tate.push_back(i);
yoko.push_back(j);
}
}
}
sort(tate.begin(),tate.end());
sort(yoko.begin(),yoko.end());
//move to one column
int tate1=1e+8,yoko1=1e+8;
FORE(i,0,h){
int tmp=0;
FORE(k,0,tate.size())tmp+=abs(i-tate[k]);
tate1=min(tate1,tmp);
}
FORE(i,0,w-yoko.size()+1){
int tmp=0,cur=i;
FORE(j,0,yoko.size()){
tmp+=abs(yoko[j]-cur);
cur++;
}
yoko1=min(yoko1,tmp);
}
int ans1=tate1+yoko1;
//move to one row
int tate2=1e+8,yoko2=1e+8;
FORE(i,0,w){
int tmp=0;
FORE(k,0,yoko.size())tmp+=abs(i-yoko[k]);
yoko2=min(yoko2,tmp);
}
FORE(i,0,h-tate.size()+1){
int tmp=0,cur=i;</description>
    </item>
    
    <item>
      <title>SRM 528 DIV1 Easy - Cut （復習○）</title>
      <link>https://chaingng.github.io/post/srm-528-div1-easy---cut-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 18:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-528-div1-easy---cut-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11564&amp;amp;rd=14553
様々な長さのうなぎとカットできる数が与えられる。
カットして、できるだけ多く１０の長さのうなぎをつくる。
このとき、最大となる１０の長さのうなぎの数を求める。
解き方 
１０の倍数のとき、すべてカットできればカット数が１つ少なく済むことから、１０の倍数から検査していく必要がある。
ソートして、１０の倍数のうなぎを検査し、その後それ以外のうなぎを順に検査していけばよい。
最大の計算量はＯ（N^2*N*2=50*50*50*2=2.5*10^5）。
コード 
class Cut {
public: int getMaximum(vector&amp;lt;int&amp;gt; eel, int maxCuts) {
int ans=0;
sort(eel.begin(),eel.end());
FORE(i,0,eel.size()){
if(eel[i]%10!=0)continue;
int cut=min(maxCuts,eel[i]/10-1);
if(maxCuts&amp;gt;=eel[i]/10-1)ans++;
ans+=cut;
maxCuts-=cut;
if(maxCuts==0)return ans;
}
FORE(i,0,eel.size()){
if(eel[i]%10==0)continue;
int cut=min(maxCuts,eel[i]/10);
maxCuts-=cut;
ans+=cut;
if(maxCuts==0)return ans;
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 529 DIV1 Easy - KingSort (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-529-div1-easy---kingsort-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 18:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-529-div1-easy---kingsort-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11740&amp;amp;rd=14722
王様の名前が与えられ、順番に並べる。
名前はアルファベットの連続とＩ，ＩIの数字で与えられ、アルファベットの昇順、同じ場合はＩ，ＩIの小さい順になる。
名前が与えられた時、ソート後の順列を返す。
解き方 
シミュレーション問題。
数字側の規則が多いので、ここをいかに簡略化できるか。
今回のコツは以下の３つ。
①判定が多い場合は配列にパターンを格納し判定。
②与えられた文字列を分解して判別するのではなく、全てのパターンを作りマッチするものを返す。
③ソートの要素が２つあるときは、pairを２回入れ子にし最初のpairを判定の順番に格納する。
計算量はＯ（70*50*50*2=3.5*10^5）。
コード 
class KingSort {
public:
int calc(string s){
string c1[]={&#34;&#34;,&#34;I&#34;,&#34;II&#34;,&#34;III&#34;,&#34;IV&#34;,&#34;V&#34;,&#34;VI&#34;,&#34;VII&#34;,&#34;VIII&#34;,&#34;IX&#34;};
string c10[]={&#34;&#34;,&#34;X&#34;,&#34;XX&#34;,&#34;XXX&#34;,&#34;XL&#34;,&#34;L&#34;};
int num=0;
FORE(i,0,10)FORE(j,0,6){
if(i==0&amp;amp;&amp;amp;j==0)continue;
if(c10[j]+c1[i]==s){
num=j*10+i;
break;
}
}
return num;
}
vector&amp;lt;string&amp;gt; getSortedList(vector&amp;lt;string&amp;gt; kings) {
int n=kings.size();
vector&amp;lt;pair&amp;lt;pair&amp;lt;string,int&amp;gt;,string&amp;gt; &amp;gt; vx(n);
vector&amp;lt;string &amp;gt; ans(n);
FORE(i,0,kings.size()){
string tmp1,tmp2;
stringstream out(kings[i]);
out&amp;gt;&amp;gt;tmp1;
out&amp;gt;&amp;gt;tmp2;
vx[i].first.first=tmp1;
vx[i].first.second=calc(tmp2);
vx[i].second=kings[i];
}
sort(vx.begin(),vx.end());
FORE(i,0,n)ans[i]=vx[i].second;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 530 DIV1 Easy - GogoXCake （復習○）</title>
      <link>https://chaingng.github.io/post/srm-530-div1-easy---gogoxcake-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 18:16:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-530-div1-easy---gogoxcake-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11274&amp;amp;rd=14723
ケーキをカットする問題。
カットされたあとのケーキの形と、カットするナイフが与えられる。
ナイフを当てるときは必ず、そのマスにもケーキがなければいけない。
カット後のケーキの形にすることができればＹｅｓ，ダメならＮｏを返す。
解き方 
単純にシミュレーションするだけ。
カットできるときはカットしなければ答えを導けないことがわかれば、単純に実装できる。
最初にカットするべきマスとダメなマスをマーキング。
次に順番にナイフを当てていき、全てカットすることができるときだけカットする。
最後にカットするべきマスが残っていればＮｏ，残っていなければＹｅｓ．
コード 
class GogoXCake {
public: string solve(vector&amp;lt;string&amp;gt; cake, vector&amp;lt;string&amp;gt; cutter) {
int h=cake.size(),w=cake[0].size();
int ch=cutter.size(),cw=cutter[0].size();
int g[h][w];
FORE(i,0,h)FORE(j,0,w){
if(cake[i][j]==&#39;.&#39;)g[i][j]=-1;
else g[i][j]=1;
}
FORE(i,0,h-ch+1){
FORE(j,0,w-cw+1){
int invalid=0;
FORE(a,i,ch+i)FORE(b,j,cw+j)if(cutter[a-i][b-j]==&#39;.&#39;&amp;amp;&amp;amp;g[a][b]!=-1)invalid=1;
if(invalid)continue;
FORE(a,i,ch+i)FORE(b,j,cw+j)if(cutter[a-i][b-j]==&#39;.&#39;)g[a][b]=1;
}
}
FORE(i,0,h)FORE(j,0,w)if(g[i][j]==-1)return &#34;NO&#34;;
return &#34;YES&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 531 DIV1 Easy - NoRepeatPlaylist (復習○)</title>
      <link>https://chaingng.github.io/post/srm-531-div1-easy---norepeatplaylist-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 18:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-531-div1-easy---norepeatplaylist-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11774&amp;amp;rd=14724
プレイヤーにＮ曲の曲が入っており、Ｐ曲からなるプレイリストを作りたい。
Ｎ曲はそれぞれ少なくとも１回は再生しなければならない。
また、１度再生した曲はＭ曲以上開ければまた再生できる。
このとき、作成できるプレイリストの場合の数を求める。
解き方 
Ｃの順列の問題のとき、この場合は各変数を決めてＤＦＳを使うことで解くことができる。
ＤＦＳでは各曲は区別しなくてもよい。
変数は①Ｐ曲の曲を作るので現在までで作っている曲数、②Ｎ曲をすべて再生しなければならないのでまだ再生していない曲数、③これまでに再生した曲数となる。
ＤＦＳのみの実装だとＯ（２＾１００＝１０＾１０）となるが、
ｄｐを使うことでｄｐのサイズ１００＾３＝１０＾６まで減る。
さらに向上させようとすれば、まだ再生していない曲はＮ－これまでに再生した曲だけ考えればよいので１０＾３まで減らすこともできる。
コード 
class NoRepeatPlaylist {
public:
long long f(int idx,int XS, int YS){
if(idx==P)return YS==0 ? 1 : 0;
if(dp[idx][XS][YS]!=-1)return dp[idx][XS][YS];
long long ans=0;
if(YS&amp;gt;0)ans+=YS*f(idx+1,XS+1,YS-1)%MOD;
if(XS-M&amp;gt;0)ans+=(XS-M)*f(idx+1,XS,YS)%MOD;
return dp[idx][XS][YS]=ans%MOD;
}
int numPlaylists(int N1, int M1, int P1) {
FORE(i,0,101)FORE(j,0,101)FORE(k,0,101)dp[i][j][k]=-1;
P=P1;
M=M1;
return f(0,0,N1);
}
}; </description>
    </item>
    
    <item>
      <title>SRM 532 DIV1 Easy - DengklekMakingChains (復習××)</title>
      <link>https://chaingng.github.io/post/srm-532-div1-easy---dengklekmakingchains-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 29 Sep 2013 17:48:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-532-div1-easy---dengklekmakingchains-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11754&amp;amp;rd=14725
長さ３からなる鎖がある。
鎖はビーズか数字のパーツからなる。
複数の鎖が与えられ、鎖をつなげたときに連続した数字が美しさの値になる。
このとき、最大となる美しさの値を求める。
解き方 
シミュレーションの問題なので、いかにＣｈａｌｌｅｎｇｅケースを網羅するか、間違いのないように実装するか。
１）真ん中のみに数字がある場合は、その最大値と連結した鎖と比較する必要がある
２）左と右にある鎖について、左とも右とも取れるものを考慮する。
さらに２つではなく１つだけの場合もあるため、その場合も考慮する。
文字列１つ１つでif文を書いてもよいが、for文をうまく使うことで間違いが少なく簡略化することができる。
コード 
class DengklekMakingChains {
public:
int maxBeauty(vector&amp;lt;string&amp;gt; c) {
int n=c.size();
int ans=0,single=0,a[60]={},b[60]={},added=0;
FORE(i,0,n){
if(c[i][0]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][1]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][2]!=&#39;.&#39;)FORE(j,0,3)ans+=c[i][j]-&#39;0&#39;;
else {
if(c[i][0]==&#39;.&#39;&amp;amp;&amp;amp;c[i][1]!=&#39;.&#39;&amp;amp;&amp;amp;c[i][2]==&#39;.&#39;)single=max(single,c[i][1]-&#39;0&#39;);
for(int j=0;j&amp;lt;3&amp;amp;&amp;amp;c[i][j]!=&#39;.&#39;;j++)a[i]+=c[i][j]-&#39;0&#39;;
for(int j=2;j&amp;gt;=0&amp;amp;&amp;amp;c[i][j]!=&#39;.&#39;;j--)b[i]+=c[i][j]-&#39;0&#39;;
}
}
FORE(i,0,n){
added=max(added,max(a[i],b[i]));
FORE(j,0,n)if(i!=j)added=max(added,a[i]+b[j]);
}
ans+=added;
return single&amp;gt;ans ? single : ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 533 DIV1 Easy - CasketOfStar (復習×)</title>
      <link>https://chaingng.github.io/post/srm-533-div1-easy---casketofstar-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 24 Aug 2013 07:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-533-div1-easy---casketofstar-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11781&amp;amp;rd=14726
数字の文字列が与えられる。
ひとつずつ文字を選び、その両端の値をかけたものがスコアになる。
選んだあとはその文字は消滅する。
最初と最後の値になるまでこの処理を繰り返した時、最大となるスコアを求める。
解き方 
単純に深さ優先探索を行おうとすると、最大でＯ（４８！）のため
解くことができない。
そこで、処理を逆にできないか考えてみる。
ここで、ある数字を選んで挿入することを考えると
そのときのスコアは一意に定まる。
また、そこから挿入するときの最大のスコアは最初～挿入した場所＋挿入した場所～最後
のスコアになる。
この場合は区間ごとの最大値の判定となり葉の判定が増えるのでｄｐが活用でき、
さらに判定回数も減るのでＯ（５０×５０）ほどになる。
コード 
int dp[60][60];
vector&amp;lt;int&amp;gt; w;
class CasketOfStar {
public:
int solve(int l,int r){
if(dp[l][r]!=-1)return dp[l][r];
if(l+1==r)return 0;
FORE(i,l+1,r)dp[l][r]=max(dp[l][r],solve(l,i)+solve(i,r)+w[l]*w[r]);
return dp[l][r];
}
int maxEnergy(vector&amp;lt;int&amp;gt; weight) {
w=weight;
FORE(i,0,60)FORE(j,0,60)dp[i][j]=-1;
return solve(0,weight.size()-1);
}
};
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).</description>
    </item>
    
    <item>
      <title>SRM 563 DIV1 Easy - FoxAndHandle (復習××)</title>
      <link>https://chaingng.github.io/post/srm-563-div1-easy---foxandhandle-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sat, 24 Aug 2013 07:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-563-div1-easy---foxandhandle-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12331&amp;amp;rd=15185
文字列が与えられて、その文字をシャッフルして元の文字にランダムに挿入する。
挿入後の文字列が与えられた時、元の文字列のうち辞書順に最小のものを求める。
解き方 
文字の種類については、与えられた各文字を２で割ったものになる。
次に文字の順番については、ひとつ選ぶとその前の文字は選べなくなる。
選ぶべき文字の種類を満たし、かつ辞書順になるよう小さいアルファベットから
上の判定を繰り返していく。
コード 
class FoxAndHandle {
public: string lexSmallestName(string S) {
int num[26]={0};
string ans=&#34;&#34;;
FORE(i,0,S.size())num[S[i]-&#39;a&#39;]++;
FORE(i,0,26)num[i]=num[i]/2;
while(accumulate(num,num+26,0)&amp;gt;0){
pair&amp;lt;char,int&amp;gt; best=make_pair(&#39;z&#39;+1,-1);
FORE(i,0,S.size()){
if(num[S[i]-&#39;a&#39;]==0)continue;
int count[26]={},invalid=0;
FORE(j,i,S.size())count[S[j]-&#39;a&#39;]++;
FORE(j,0,26)if(num[j]&amp;gt;count[j])invalid=1;
if(invalid)continue;
best=min(best,make_pair(S[i],i));
}
ans+=best.first;
num[best.first-&#39;a&#39;]--;
S=S.substr(best.second+1);
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 578 DIV1 Easy - GooseInZooDivOne (復習×)</title>
      <link>https://chaingng.github.io/post/srm-578-div1-easy---gooseinzoodivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 21 Aug 2013 08:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-578-div1-easy---gooseinzoodivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12539&amp;amp;rd=15498
2次元のセルが与えられ、それぞれのセルは鳥がいるかいないかで表わされる。
鳥はガチョウとアヒルの２種類存在する。
その鳥がどちらかはわからないが、あるガチョウとマンハッタン距離にある鳥はすべて
ガチョウとなる。
このとき、ガチョウの鳥の数が偶数となる場合の数を求める。
解き方 
あるガチョウとマンハッタン距離にある鳥は全てガチョウということは、
マンハッタン距離にある鳥の集合それぞれは、ガチョウかアヒルになるということがわかる。
つぎにそれぞれの集合に対して、鳥の数が偶数か奇数かに分類する。
偶数の集合Ｎについては２＾Ｎとなる。
奇数の集合については、ｎＣ０×ｎＣ２ｘ・・・ｎＣｎ－１となる。
ここで二項定理により(1+x)^n=(n,0)*x^0+(n,1)*x^1...+(n,n)*x^n
x=1,-1のとき、
2^n=(n,0)+(n,1)+...+(n,n)
0=(n,0)-(n,1)+(n,2)...-(n,n)
2^n=2(n,0)+2(n,2)...+2(n,n-1)
2^(n-1)=(n,0)+(n,2)...+(n,n-1)
よって奇数の集合は2^(n-1)となるので、2^(n-1+N)が答えになる。
コード 
int H,W,D;
int cell[55][55];
class GooseInZooDivOne {
public:
int DFS(int i,int j){
int ans=1;
queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
q.push(make_pair(i,j));
cell[i][j]=1;
while(!q.empty()){
int x=q.front().first;
int y=q.front().second;
q.pop();
FORE(i,0,H)FORE(j,0,W)if(cell[i][j]==0&amp;amp;&amp;amp;abs(x-i)+abs(y-j)&amp;lt;=D){
cell[i][j]=1;
q.push(make_pair(i,j));
ans++;
}
}
return ans;
}
int count(vector&amp;lt;string&amp;gt; field, int dist) {
long long MOD=1000000007LL,ans=1LL;
int even=0,odd=0,cnt=0;
H=field.size(),W=field[0].size(),D=dist;</description>
    </item>
    
    <item>
      <title>SRM 565 DIV1 Easy - MonstersValley (復習××)</title>
      <link>https://chaingng.github.io/post/srm-565-div1-easy---monstersvalley-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Wed, 21 Aug 2013 07:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-565-div1-easy---monstersvalley-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12350&amp;amp;rd=15187
モンスターが複数いる谷を越える。
各モンスターには恐さとコインの値を持つ。
プレイヤーは各モンスターに対し、そのコインを払って仲間にするか、
もしくは仲間の恐さの和がそのモンスター以上であればそのまま通り過ぎることが
できる。
このとき、全てのモンスターを越えたときに支払う最小のコインの数を求める。
解き方 
モンスターの数が５０のため、Ｏ（２＾５０）となり
深さ優先探索では求めることができない。
ここでコインの数は最大でモンスターの数×２となるため、
モンスターの位置にいるとき所有しているコインの数をパラメータ、
返り値を恐さの値としたｄｐで解くことができる。
コード 
class MonstersValley {
public:
int minimumPrice(vector&amp;lt;long long&amp;gt; dread, vector&amp;lt;int&amp;gt; price) {
int n=dread.size();
long long maxp[2*n+1][n+1],INF=1e+18;
FORE(p,0,2*n+1){
maxp[p][0]=0;
FORE(j,1,n+1)maxp[p][j]=-INF;
FORE(j,1,n+1){
if(p&amp;gt;=price[j-1])maxp[p][j]=maxp[p-price[j-1]][j-1]+dread[j-1];
if(maxp[p][j-1]&amp;gt;=dread[j-1])maxp[p][j]=max(maxp[p][j],maxp[p][j-1]);
}
}
FORE(i,0,2*n)if(maxp[i][n]&amp;gt;=0)return i;
return 2*n;;
}
};
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).</description>
    </item>
    
    <item>
      <title>SRM 571 DIV1 Easy - FoxAndMp3 (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-571-div1-easy---foxandmp3-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 20 Aug 2013 08:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-571-div1-easy---foxandmp3-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12436&amp;amp;rd=15491
１～Ｎまでの数字が付けられたN.mp3ファイルを昇順に並べる。
Ｎが５０を超える場合は、最初の５０個の昇順に並べられたファイル数を返す。
解き方 
Ｎが１０＾９のため全てのファイルを出力してからソートしては求めることができない。
そのため規則性を見つける必要がある。
Ｎ＝１０１８のとき、
最初は１から始め，
１０，１００，１０００と「１０をかけ、Ｎ以下ならその数」になる。
次は１００１、１００２、１００９、１０１と「１を足していき、１０で割ってＮ以下ならその数」となる。
また、１０１０、、、１０１８、１０２とＮを超えた場合は「１０で割って１を足し、Ｎ以下ならその数」になる。
最後に、１９１、、１９９、２、と１０で割りつづけられるなら割り続ける必要がある。
つまり、
①１０をかけ、Ｎ以下ならその数
②Ｎより大きい場合、１を足して１０の倍数もしくはＮと等しいなら、１０で割れなくなるまで割り続けた数に１を足した数なる。
これをmin(N,50)まで操作してあげたものが答えになる。
コード 
class FoxAndMp3 {
public: vector&amp;lt;string&amp;gt; playList(int n) {
long long cur=1,num=1;
vector&amp;lt;string&amp;gt; ans(min(n,50));
FORE(num,0,min(50,n)){
stringstream out;
out&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&#34;.mp3&#34;;
ans[num]=out.str();
if(cur*10&amp;lt;=n)cur*=10;
else{
while(cur%10==9 || cur==n)cur/=10;
cur++;
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 572 DIV1 Easy - NewArenaPassword （復習○）</title>
      <link>https://chaingng.github.io/post/srm-572-div1-easy---newarenapassword-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Tue, 20 Aug 2013 08:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-572-div1-easy---newarenapassword-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12386&amp;amp;rd=15492
古いパスワードから新しいパスワードを作りたいが、できるだけ変更したくない。
また、パスワードの最初のＫ文字と最後のＫ文字は一致していないといけない。
古いパスワードが与えられた時、最小の変更文字数を求める。
解き方 
正確にシミュレーションしてあげれば解ける問題。
i文字目について、Ｎ-K文字を足した場所とリンクしていることがわかると、
最初からN-Kずつ足していった値に対して、最小のリンク関数を求めてあげればよい。
また、最初からＫもしくはＮ－Ｋまでの操作でよいことがわかる。
コード 
class NewArenaPassword {
public: int minChange(string oldPassword, int K) {
int cost=0,n=oldPassword.size();
for(int i=0;i&amp;lt;n&amp;amp;&amp;amp;i&amp;lt;n-K;i++){
int count[26]={},num=0;
for(int j=i;j&amp;lt;n;j+=n-K){
count[oldPassword[j]-&#39;a&#39;]++;
num++;
}
cost+=num-*max_element(count,count+26);
}
return cost;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 546 DIV1 Easy - KleofasTail （復習○）</title>
      <link>https://chaingng.github.io/post/srm-546-div1-easy---kleofastail-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 20:12:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-546-div1-easy---kleofastail-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12049&amp;amp;rd=14738
整数が与えられる。
整数が偶数のときは２で割り、奇数であれば１を引くことができる。
整数の範囲とある数が与えられた時、
その整数の範囲内である数が存在する数が何通りあるか求める。
解き方 
数が１０＾１８のため、範囲中の全ての数を全探索で求めることはできない。
そのため、法則がないか数を列挙してみる。
ここで状態遷移図を用いてみる。
１）ｋが偶数のとき
Ｋ←２Ｋ←２Ｋ＋１←４Ｋ＋２←８Ｋ＋４
←４Ｋ＋３
←４Ｋ←８Ｋ←１６Ｋ
←８Ｋ＋１
←４Ｋ＋１←８Ｋ＋２
←Ｋ＋１←２Ｋ＋２←４Ｋ＋４←８Ｋ＋８
←４Ｋ＋５
←２Ｋ＋３←４Ｋ＋６→４Ｋ＋７
２）ｋが奇数のとき
Ｋ←２Ｋ←２Ｋ＋１←４Ｋ＋２←８Ｋ＋４
←４Ｋ＋３
←４Ｋ←８Ｋ←１６Ｋ
←８Ｋ＋１
←４Ｋ＋１←８Ｋ＋２
つまり、以下の法則が導ける。
ｋが偶数のときは
Ｋ～Ｋ＋１，２Ｋ～２Ｋ＋３、４Ｋ～４Ｋ＋７
ｋが奇数のときは
Ｋ、２Ｋ～２Ｋ＋１、４Ｋ～４Ｋ＋３
最小はＫの倍数、最大はＫもしくはＫ＋１から始まり２倍＋１となる。
コード 
class KleofasTail {
public:
long long calc(long long K,long long B){
long long ans=0,low=K,high=K;
if(K%2==0)high++;
while(low&amp;lt;=B){
ans+=min(high,B)-low+1;
low=2*low;
high=2*high+1;
}
return ans;
}
long long countGoodSequences(long long K, long long A, long long B) {</description>
    </item>
    
    <item>
      <title>SRM 562 DIV1 Easy - PastingPaintingDivOne （復習○）</title>
      <link>https://chaingng.github.io/post/srm-562-div1-easy---pastingpaintingdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 18:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-562-div1-easy---pastingpaintingdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12317&amp;amp;rd=15184
長方形の模様が与えられる。
模様はの各セルはＲ，Ｇ，Ｂのいずれかの色、もしくは．で表わされる透明のセルで
構成される。
最初は左上に重なるように模様がスタンプされ、次は左上の座標を右に１、下に１移動させてスタンプする。
Ｔ回スタンプしたとき、Ｒ，Ｇ，Ｂの数を求める。
解き方 
Ｔが１０＾９のため、スタンプごとに全探索しては解けない。
ここでスタンプされた時のＲＧＢの変化は、
高さ分の回数スタンプした後は常に一定になることがわかれば
それ以降の回数×Ｔ×ＲＧＢそれぞれの増加数、で解くことができる。
コード 
class PastingPaintingDivOne {
public: vector&amp;lt;long long&amp;gt; countColors(vector&amp;lt;string&amp;gt; clipboard, int T) {
char check[200][200];
vector&amp;lt;long long&amp;gt; ans(3,0);
int h=clipboard.size(),w=clipboard[0].size();
long long pr=0,pg=0,pb=0;
FORE(i,0,200)FORE(j,0,200)check[i][j]=&#39;.&#39;;
FORE(n,0,h){
T--;
FORE(i,n,h+n)FORE(j,n,w+n)if(clipboard[i-n][j-n]!=&#39;.&#39;)check[i][j]=clipboard[i-n][j-n];
ans[0]=ans[1]=ans[2]=0;
FORE(i,0,200)FORE(j,0,200){
if(check[i][j]==&#39;R&#39;)ans[0]++;
if(check[i][j]==&#39;G&#39;)ans[1]++;
if(check[i][j]==&#39;B&#39;)ans[2]++;
}
if(T==0)return ans;
}
FORE(i,h,clipboard.size()+h)FORE(j,h,clipboard[0].size()+h)if(clipboard[i-h][j-h]!=&#39;.&#39;)check[i][j]=clipboard[i-h][j-h];
FORE(i,0,200)FORE(j,0,200){
if(check[i][j]==&#39;R&#39;)pr++;
if(check[i][j]==&#39;G&#39;)pg++;
if(check[i][j]==&#39;B&#39;)pb++;
}
pr-=ans[0],pg-=ans[1],pb-=ans[2];
ans[0]+=pr*T,ans[1]+=pg*T,ans[2]+=pb*T;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 577 DIV1 -Level1</title>
      <link>https://chaingng.github.io/post/srm-577-div1--level1/</link>
      <pubDate>Sun, 18 Aug 2013 17:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-577-div1--level1/</guid>
      <description>問題 
プログラミングコンテストを実施するにあたり、プレイヤーを部屋に割り当てる。
部屋は２０人単位。プレイヤーはレートをもっている。
部屋の割り当てはレートの高い順に最初の部屋数分を、ランダムにそれぞれの部屋に割り当てる。部屋数で割り切れない場合は、部屋にいる人数は必ずしも一緒にならない。
配列の最初のプレイヤーが自分であるとき、
自分が割り当てられた部屋の平均レートを求める。
解き方 
シミュレーション問題であるが、自分のレートによって色々な場合が存在するので全て洗い出す。また、コーディングをいかに単純にするかもポイント。
コーディングを単純にするには、
まずは計算しやすい各割り当てグループごとにメンバーの平均値を求める。
そのグループに自分が入っている場合は、自分の値＝平均値となる。
最後のグループも同じように計算する。
次にとりうる全てのケースを考える。
１）メンバーが部屋の数で割り切れるとき
すべてのメンバーの平均値／部屋のメンバー数が答え。
２）メンバーが部屋の数で割り切れないとき
２－１）自分が最後の割り当てメンバーのとき
メンバー数が全メンバー／部屋数に１を足したものになるので、
全てのメンバーの平均値／上記のメンバー数が答え。
２－２）自分が最後の割り当てメンバーではないとき
自分がメンバーの多い部屋になるときとならないときの確率を求めて
その２つの和が答えとなる。
Challenge
int／intはint型の結果が代入される。
一方でdouble/int もしくはint/doubleはdoubleに変換されて計算される。
いずれにしても計算の場合は型を一致させてから行うのが基本。
コード 
class EllysRoomAssignmentsDiv1 {
public: double getAverage(vector&amp;lt;string&amp;gt; ratings) {
string tmp=&#34;&#34;;
vector&amp;lt;int&amp;gt; v;
vector&amp;lt;double&amp;gt; ave;
ave.clear(),v.clear();
FORE(i,0,ratings.size())tmp+=ratings[i];
stringstream str(tmp);
while(1){
int out=-1;
str&amp;gt;&amp;gt;out;
if(out==-1)break;
v.push_back(out);
}
int N=v.size();
int R=(N+19)/20;
int myrate=v[0],my=0;
int member=N/R;
sort(v.rbegin(),v.rend());
FORE(i,0,v.size())if(v[i]==myrate)my=i;
for(int i=0;i&amp;lt;N;i+=R){
int j=min(i+R,N);</description>
    </item>
    
    <item>
      <title>SRM 585 DIV1 Easy - TrafficCongestion (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-585-div1-easy---trafficcongestion-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 16:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-585-div1-easy---trafficcongestion-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11361&amp;amp;rd=15697
２分木の高さが与えられる。
車は一筆書きでそのセルを移動することができる。
ただし、一度車が通った道は行くことができない。
このとき、すべてのセルを移動するのに必要な車の台数を求める。
解き方 
いくつか例を並べてみると、前の高さで必要な車の数＋２つ前で必要な車の数×２が答えになるという法則が出てくる。
あとはこれをｄｐで実装すればよい。
Challenge
高さが０のときはセルが1個存在するので答えは１になる。
値が０、１のときにコードがそのままでよいのか、例外条件を書かなければいけないのかを確かめる。
特にこの問題の場合は2つ前の配列を調べることからスタートは２からになるので
特に注意する。
dpの配列の宣言がなぜかうまく通らなかったのですが、vectorで宣言するとうまくいきました。１０＾６を超えるなど大きい場合のときはvectorを用いるのがよさそうです。
コード 
class TrafficCongestion {
public: int theMinCars(int treeHeight) {
vector&amp;lt;long long&amp;gt; dp(treeHeight+1,0);
long long MOD=1000000007;
dp[0]=1,dp[1]=1;
FORE(i,2,treeHeight+1)dp[i]=(dp[i-1]+2*dp[i-2])%MOD;
return (int)dp[treeHeight];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 564 DIV1 Easy - KnightCircuit2 （復習○）</title>
      <link>https://chaingng.github.io/post/srm-564-div1-easy---knightcircuit2-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 16:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-564-div1-easy---knightcircuit2-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=10968&amp;amp;rd=15186
ボードの長さと高さが与えられる。
このとき、ナイトが動けるマスを返す。
解き方 
１辺の最大の長さは４５０００のため、Ｏ（１０＾８）となり全探索では求められない。
そこで法則を探すことにする。
１）マスの１辺が１のとき
動くことができないので、答えは１
２）マスの１辺が２のとき
もう一つの辺の長さによって答えが変わる。
１マスのときは＋１、２マスの時は＋１、３マスのときは＋２、４マスのときは＋２
これが繰り返される。
３）マスが３*３のとき
３＊３のときは真ん中だけいけないので８．
４）それ以外
全てのマスに行くことができるので全てのマスの数が答え。
コード 
class KnightCircuit2 {
public: int maxSize(int w, int h) {
if(w&amp;gt;h)swap(w,h);
if(w==1)return 1;
if(w==2)return (h+1)/2;
if(w==3 &amp;amp;&amp;amp; h==3)return 8;
return w*h;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 584 DIV1 Easy - Egalitarianism （復習○）</title>
      <link>https://chaingng.github.io/post/srm-584-div1-easy---egalitarianism-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 16:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-584-div1-easy---egalitarianism-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12613&amp;amp;rd=15696
友達のつながりの集合が与えられる。
それぞれの人はお金を所ゆすることができるが、
友達同士は、ｄ以下の差でなければいけない。
このとき、集合にある人のお金の差の最大値を求める。
差が無限大になる場合はー１を返す。
解き方 
友達以外にはお金の制限がないことから、全員が友達でない場合は
差が無限大になるのでー１．
全て友達のつながりがある場合は、最も遠い友達との距離×ｄが答えになることが
わかる。
距離を求める問題なので、ワーシャルフロイド法を用いて最大となる友達との距離を求める。
Challenge
(i,i)は自分との連結なので探索から除外する。
コード 
int INF=1e+9;
class Egalitarianism {
public: int maxDifference(vector&amp;lt;string&amp;gt; isFriend, int d) {
int n=isFriend.size();
int check[n][n];
int ans=0;
FORE(i,0,n){
FORE(j,0,n){
if(isFriend[i][j]==&#39;Y&#39;)check[i][j]=1;
else check[i][j]=INF;
}
}
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)check[i][j]=min(check[i][j],check[i][k]+check[k][j]);
FORE(i,0,n){
FORE(j,0,n){
if(i==j)continue;
if(check[i][j]==INF)return -1;
ans=max(ans,check[i][j]);
}
}
return ans*d;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 582 DIV1 Easy - SpaceWarDiv1 (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-582-div1-easy---spacewardiv1-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 16:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-582-div1-easy---spacewardiv1-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12604&amp;amp;rd=15502
魔法少女が敵を倒す。
それぞれの敵には強さとその強さの個体数、それぞれの魔法少女は強さを持つ。
魔法少女は自分よりも強さが敵を倒すことができる。
その際、その魔法少女の疲れの値が１増える。
このとき、魔法少女が敵を全て倒したときの疲れの最小値を求める。
全て倒せないときはー１を返す。
解き方 
疲れの値を２分探索させて、最小の疲れの値を求める。
敵の数が最大１０＾１４のため、
その疲れの値が有効かどうかの関数の実装に注意。
降順のソートには「sort(rbegin(),rend())&amp;nbsp;」が利用可能。
long longの値を扱うには数字の後に「1234567890LL」とLLをつける。
コード 
class SpaceWarDiv1 {
public:
bool ispossible(long long maxbattle,vector&amp;lt;int&amp;gt; &amp;amp;girls,vector&amp;lt;pair&amp;lt;int,long long&amp;gt; &amp;gt; &amp;amp;enemies){
long long girlnum=maxbattle,enemynum=enemies[0].second;
int gi=0,ei=0;
while(gi&amp;lt;girls.size() &amp;amp;&amp;amp; ei&amp;lt;enemies.size()){
if(girlnum==0){
gi++;
girlnum=maxbattle;
}
if(enemynum==0){
if(ei==enemies.size()-1)return true;
ei++;
enemynum=enemies[ei].second;
}
if(girls[gi]&amp;lt;enemies[ei].first){
gi++;
continue;
}
long long battle=min(girlnum,enemynum);
girlnum-=battle;
enemynum-=battle;
}
return false;
}
long long minimalFatigue(vector&amp;lt;int&amp;gt; girls, vector&amp;lt;int&amp;gt; enemyStrength, vector&amp;lt;long long&amp;gt; enemyCount) {</description>
    </item>
    
    <item>
      <title>SRM 574 DIV1 Easy - TheNumberGame （復習x）</title>
      <link>https://chaingng.github.io/post/srm-574-div1-easy---thenumbergame-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sun, 18 Aug 2013 16:02:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-574-div1-easy---thenumbergame-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12474&amp;amp;rd=15494
２人のプレイヤーが交互に行うゲーム。
それぞれ正の整数が与えられる。
各ターンにて、プレイヤーはその数字を１０で割るか、逆にすることができる。
このとき、最初のプレイヤーの数字を２人目のプレイヤーの数字に一致させることができるかどうかを答える。
ターン数は最大で１０００。
解き方 
２人目のプレイヤーの数字にすることができれば、
その後の操作は全て一緒にできるので答えは必ずＹＥＳになる。
仮に一緒にできなければ、２人目のプレイヤーは数字をひっくり返し続けてればよいのでＮＯとなる。
待ち伏せる場合、２人目のプレイヤーが逆になるのを待ち伏せる場合は逆にできないので例外、と考えがちだが、逆の数字にできるということは最初の数字にもできるということなので問題ない。
Challenge
2人の操作で１ターンではなく、１人のプレイヤーの操作が終われば1ターンで、
そこで判定できることを見逃してしまった。問題文の理解ミスです。
sprintfはchar型で使うのですが、stringをchar変換しようとしたらうまくいかなかったです。そのままchar型を宣言して使いました。
コード 
class TheNumberGame {
public:
string determineOutcome(int A, int B) {
bool win=false;
char tx[15],ty[15];
sprintf(tx,&#34;%d&#34;,A);
sprintf(ty,&#34;%d&#34;,B);
string x=tx,y=ty;
if(x.find(y)!=string::npos)win=true;
reverse(y.begin(),y.end());
if(x.find(y)!=string::npos)win=true;
return win ? &#34;Manao wins&#34; :&#34;Manao loses&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 573 DIV1 Easy - TeamContest （復習○）</title>
      <link>https://chaingng.github.io/post/srm-573-div1-easy---teamcontest-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 11:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-573-div1-easy---teamcontest-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12470&amp;amp;rd=15493
それぞれのプレイヤーの強さが与えられる。
３人でチームを作り、チームの強さはそのうち最小と最大の強さを足したものになる。
自分のチームは最初の３人であり、このとき一番数字が大きくなる順位を求める。
解き方 
最初の順番は答えに関係ないので、自分のチームの強さを保存した後
除いたものを昇順にソートする。
一番左と一番右のindexを用意し、最強のプレイヤーが最弱のプレイヤーとチームを組んだ場合を考える。
自分のチームより強ければチームを作り、左のインデックスを２つ動かし、右のインデックスを一つ左に動かす。
自分のチームより弱ければその最弱のプレイヤーはどれと組んでも負けるので、左のインデックスのみ３つ動かす。
Challenge
自分のプレイヤーを除いたのにカウントしてしまったミスを最初してしまったので操作には注意する。
コード 
class TeamContest {
public: int worstRank(vector&amp;lt;int&amp;gt; strength) {
int my=min(strength[0],min(strength[1],strength[2]))+max(strength[0],max(strength[1],strength[2]));
int rank=1;
vector&amp;lt;int&amp;gt; v;
FORE(i,3,strength.size())v.push_back(strength[i]);
sort(v.begin(),v.end());
int l=0,r=v.size()-1;
while(l&amp;lt;r){
if(v[l]+v[r]&amp;gt;my){
rank++;
l+=2;
r--;
}
else{
l+=3;
}
}
return rank;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 557 DIV1 Easy - MergersDivOne (復習×)</title>
      <link>https://chaingng.github.io/post/srm-557-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 10:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-557-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12195
山登りをし、スタートの高さとゴールの高さ、ステップ数が与えられる。
１ステップごとに、１段上がるか下がるかすることができる。
また、登山の部分列が与えられる。
このとき、登山にその部分列が存在するときは”ＹＥＳ”、存在しないときは”ＮＯ”を返す。
解き方 
まずはその部分列の操作をしたとき、ゴールにたどり着けるかを判定。
残りのステップ数がゴールへの距離も多い時はＮＯ。
残りのステップ数を２で割ったときの余りと、ゴールへの距離を２で割ったときの余りが一致しない場合もＮＯ．
次に、その部分列の操作をしたときに高さが０未満にならないかを判定。
まず、残りのステップ数からゴールまでのステップ数を引き、その半分は余裕がある。
また部分列の操作をしたあとに上る操作ならば最初に登っておいてもよいため、
ゴールまでのステップ数の分も余裕がある。
Challenge
登山のため、高さが０未満になることはないことに注意。
コード 
class FoxAndMountainEasy {
public: string possible(int n, int h0, int hn, string history) {
int x=h0,m=history.size();
FORE(i,0,history.size()){
if(history[i]==&#39;U&#39;)x++;
else x--;
}
int d=hn-x;
if(d&amp;lt;0)d=-d;
if(n-m&amp;lt;d)return &#34;NO&#34;;
if((n-m)%2!=d%2)return &#34;NO&#34;;
int up=(n-m-d)/2;
if(x&amp;lt;hn)up+=hn-x;
x=h0+up;
FORE(i,0,history.size()){
if(history[i]==&#39;U&#39;)x++;
else x--;
if(x&amp;lt;0)return &#34;NO&#34;;
}
return &#34;YES&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 536 DIV1 Easy - MergersDivOne （復習○）</title>
      <link>https://chaingng.github.io/post/srm-536-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 10:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-536-div1-easy---mergersdivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11799&amp;amp;rd=14728
複数の会社が与えられる。
そのうち任意の数を選択し、その価値の和／選択した数が合併した後の価値になる。
すべての会社を合併した時、最大となる価値を求める。
解き方 
最初の数の順番は回答に関係しないので昇順にソート。
このとき、すべての点をプロットすると、２つずつ左から合併を繰り返した方がよいことがわかる。
（合併後の点が順に右に移動していく。仮に３つを選択した時はその中間になり間の値があまり意味を持たないため、２つずつがよいことがわかる）
コード 
class MergersDivOne {
public: double findMaximum(vector&amp;lt;int&amp;gt; revenues) {
sort(revenues.begin(),revenues.end());
double ans=revenues[0];
FORE(i,1,revenues.size())ans=(ans+revenues[i])/2.0;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 554 DIV1 Easy - TheBrickTowerEasyDivOne （復習○）</title>
      <link>https://chaingng.github.io/post/srm-554-div1-easy---thebricktowereasydivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 10:15:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-554-div1-easy---thebricktowereasydivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12159&amp;amp;rd=15176
２つの色のレンガと、レンガの個数がそれぞれ与えられる。
レンガは違う色を交互にだけ積み重ねることができる。
このとき、とりうる高さの場合の数を求める。
解き方 
いくつか例を出してみると、積み重ねたレンガの数が偶数のときは2通り存在し、
それ以外の場合は１通りしか存在しないことがわかる。
１）積み重ねたレンガが偶数のときの場合の数　２色のうち最小の数
２）レンガが奇数のときの場合の数
＜レンガの長さが違う時＞
レンガの数が２色とも同じ
その数×２
レンガの数が２色で異なる
少ない方×２＋１
＜レンガの長さが２色とも同じ時＞
レンガの数が２色とも同じ
その数
レンガの数が２色で異なる
少ない方＋１
コード 
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class TheBrickTowerEasyDivOne {
public: int find(int redCount, int redHeight, int blueCount, int blueHeight) {</description>
    </item>
    
    <item>
      <title>SRM 547 DIV1 Easy - Pillars (復習×○)</title>
      <link>https://chaingng.github.io/post/srm-547-div1-easy---pillars-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 10:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-547-div1-easy---pillars-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12055&amp;amp;rd=14739
柱が２つ与えられる。柱の間の距離はｗ。
２つの柱の最大の長さｘ、ｙが与えられ、１～ｘ、１～ｙの間で好きに決めることができる。
最後に、柱のてっぺんをロープで結び、その長さの平均値を求める。
解き方 
ｘ、ｙが１０＾５のため、全探索で解くことはできない。
２つの柱の差の数は、２つの求め方がある。
１）ｘ、ｙから計算式を求めて一意に決定
２）ｘのみ１～ｘまで変化させ、それぞれに対しとりうる値を区間で求める。
今回は２の方法でコーディングしました。
１つエラーではまった原因としては、iをint型で計算したため数が大きい場合にエラーになってしまいました。
「計算は全て型を一致させる」、という基本を忘れないようにします。
ちなみに１の場合は、長さのとりうる値１－ｘからｙ－１までループさせ、
i&amp;lt;=０のときはmin(y,x+i)
i&amp;gt;0のときはmin(x,y-i)分だけその長さが存在することになります。
コード 
class Pillars {
public: double getExpectedLength(int w, int x, int y) {
if(x&amp;gt;y)swap(x,y);
double ret=w*x;
for(int len=1;len&amp;lt;=y-1;len++){
int cnt=max(0,min(x,y-len))+max(0,min(x-len,y));
ret+=cnt*sqrt((double)len*len+w*w);
}
return ret/x/y;
}
};
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i !</description>
    </item>
    
    <item>
      <title>SRM 569 DIV1 Easy - TheDevice （復習○）</title>
      <link>https://chaingng.github.io/post/srm-569-div1-easy---thedevice-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 09:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-569-div1-easy---thedevice-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12388&amp;amp;rd=15489
プレートの問題の応用。
各ビットごとに、ＸＯＲ，ＡＮＤ，ＯＲいずれかの動作をするデバイスがある。
またビットの和で構成されているプレートがいくつか与えられている。
このとき、各ビットのデバイスがどの動作をしているか判定するために
追加で必要なプレートの数を求める。
解き方 
各ビットに１，１，０があればよい。
足りない場合は、各ビットごとに足りない数を求め、その最大値を返してあげればよい。
コード 
class TheDevice {
public: int minimumAdditional(vector&amp;lt;string&amp;gt; plates) {
int cost=0;
FORE(j,0,plates[0].size()){
int one=0,zero=0;
FORE(i,0,plates.size()){
if(plates[i][j]==&#39;1&#39;)one++;
else zero++;
}
int tmp=3-min(2,one)-min(1,zero);
cost=max(cost,tmp);
}
return cost;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 570 DIV1 Easy - RobotHerb (復習××)</title>
      <link>https://chaingng.github.io/post/srm-570-div1-easy---robotherb-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 09:35:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-570-div1-easy---robotherb-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12427&amp;amp;rd=15490
ロボットが与えられた数の配列の通りに動作する。
最初は任意の方向を向いており、配列の最初の数だけまっすぐ移動する。
その後、移動した分だけ左を向く。
次の配列に移り、同じ動作をする。最後の配列まで終わったら一度の操作が終了。
この動作をＴ回実施する。
最後に、最初の位置とのマンハッタン距離を返す。
解き方 
最小・最大を求めるわけではないシミュレーション問題。
今回はＴが10^9と大きいので単純なシミュレーションでは解けない。
一度の動作後に動いた座標と向きは常に一緒なので、
そのＴ回の繰り返しで解ける。
４回動くと向きは戻るので、４の倍数のときは×Ｔ、
余りが出た場合は４の倍数から１回、２回、３回いずれかの値を足す。
コード 
class RobotHerb {
public: long long getdist(int T, vector&amp;lt;int&amp;gt; a) {
int x[]={0,1,0,-1},y[]={1,0,-1,0};
int d=0,curx=0,cury=0;
long long ans=0,move[4]={};
FORE(n,1,5){
FORE(i,0,a.size()){
curx+=a[i]*x[d];
cury+=a[i]*y[d];
d=(d+a[i])%4;
}
move[n%4]=abs(curx)+abs(cury);
}
ans=move[0]*(T/4);
if(T%4)ans+=move[T%4];
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 575 DIV1 Easy - TheNumberGameDivOne (復習○)</title>
      <link>https://chaingng.github.io/post/srm-575-div1-easy---thenumbergamedivone-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 08:58:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-575-div1-easy---thenumbergamedivone-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12496&amp;amp;rd=15495
２人でのゲーム。
ある数が与えられ、プレイヤーは１とその数自身以外の約数をそこから引くことができる。
約数を引いたら、次のプレイヤーに交替して進めていく。
このとき、ある数が与えられたときに最初のプレイヤーが勝つなら”Ｊｏｈｎ”、
負けるなら”Ｂｒｕｓ”を返す。
解き方 
与えられる数の最大は１０＾１８のため、ｄｐでは解くことができない。
そのため、法則がないか見つける。
とりあえず「適当な数までサンプル出力し、法則をながめる」ことが１つの手法。
法則は以下の通り。
１）２＾ｎ以外の偶数が与えられたら勝ち
この場合、ｘ＝２ｙ＊２ｚ＝２（ｙ＋ｚ）、
（ただしｙ＋ｚは２＾ｎではない、つまり奇数の約数を含む）
で表わすことができる。
このとき、偶数と奇数の約数が必ず存在するので勝ちとなる。
２）奇数が与えられたら負け
奇数は「素数」もしくは「奇数で割る」ことができる。
奇数で割れるときは、奇数ー奇数のため必ず偶数になる。
このとき、２＾ｎを含んでいるとすると奇数はｘ＝２＾ｎ＋ｙと表わせるが
２＾ｎの倍数で割れないため、２＾ｎの偶数ではない。
つまり、奇数を引いたときは２＾ｎ以外の偶数が現れる。
２＾ｎ以外の偶数は必ず約数が存在して、
一方奇数で割ることができなければ負けとなるためこの場合は負けとなる。
３）２＾ｎの偶数のとき
たとえば２＾３＝８のときは、２，４で割ることができる。
２＾１を引くと６となり２＾ｎ以外の偶数が出るので負けとなる。
そのため、２＾ｎが与えられた時は２＾（ｎ－１）を引くしかないが
その結果が２、つまりｎが偶数のときは勝ちとなるが
奇数のときは負けとなる。
コード 
class TheNumberGameDivOne {
public: string find(long long n) {
int num=0;
if(n%2)return &#34;Brus&#34;;
while(n%2==0){
n/=2;
num=(num+1)%2;
}
if(n!=1)return &#34;John&#34;;
if(num)return &#34;Brus&#34;;
return &#34;John&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 583 DIV1 Easy - TravelOnMars （復習x）</title>
      <link>https://chaingng.github.io/post/srm-583-div1-easy---travelonmars-%E5%BE%A9%E7%BF%92x/</link>
      <pubDate>Sun, 18 Aug 2013 08:34:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-583-div1-easy---travelonmars-%E5%BE%A9%E7%BF%92x/</guid>
      <description>問題 
都市が円状につながっている。
各都市には、そこから１ターンでいける都市数が保存されている。
始点と終点が与えられた時、移動するための最小ターン数を求める。
解き方 
グラフの最短距離を求める問題なので、ワーシャルフロイド法が使えないか考える。
グラフを作成し、隣り合う都市は１、そこから１ターンで行ける都市は１とし、
最後にワーシャルフロイドを走らせる。
Challenge
一方向だけではなく、順と逆を組み合わせてもよいことに注意。
コード 
class TravelOnMars {
public: int minTimes(vector&amp;lt;int&amp;gt; range, int startCity, int endCity) {
int n=range.size(),INF=100000000;
int dp[n][n];
FORE(i,0,n)FORE(j,0,n)dp[i][j]=INF;
FORE(i,0,n){
FORE(j,0,n){
int l=(i-j+n)%n;
int r=(j-i+n)%n;
if(min(l,r)&amp;lt;=range[i])dp[i][j]=1;
}
}
FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
return dp[startCity][endCity];
}
}; </description>
    </item>
    
    <item>
      <title>SRM 586 DIV1 Easy - PiecewiseLinearFunction （復習○）</title>
      <link>https://chaingng.github.io/post/srm-586-div1-easy---piecewiselinearfunction-%E5%BE%A9%E7%BF%92/</link>
      <pubDate>Sun, 18 Aug 2013 08:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-586-div1-easy---piecewiselinearfunction-%E5%BE%A9%E7%BF%92/</guid>
      <description>問題 
http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12691&amp;amp;rd=15698
座標上の点が複数与えられて、それぞれ線で結ぶ。
このとき、一番多く存在する線上のｙの値について、最大値を求める。
解き方 すべてのｙに対して値を求めると計算量が間に合わない。
そこで、「ｙが増えるのは与えられたｙ座標の近辺のみ」ということがわかれば、
調べる点は少なくてもよいことがわかる。
ここで与えられたｙ座標のみと最初に考えてしまうが、
「折れ線のときはその前後の値の方がより多く存在」する。
つまり、与えられたｙ座標の前後を全て調べて、最大の値を返せばよい。
Challenge
例外条件：隣り合う点が平行→全ての点が平行
「＜」と「＜＝」がかぶらないようにして、同じ点について複数数えないようにする
コード 
using namespace std;
#define FORE(i,d,e) for(int i=d;i&amp;lt;e;i++)
#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ISEQ(c) (c).begin(), (c).end()
class PiecewiseLinearFunction {
public: int maximumSolutions(vector&amp;lt;int&amp;gt; Y) {
int ret=0;
int n=Y.size();
FORE(i,0,n-1)if(Y[i]==Y[i+1])return -1;
vector&amp;lt;double&amp;gt; vx;
FORE(i,0,n){
vx.push_back(Y[i]-0.5);
vx.push_back(Y[i]);
vx.push_back(Y[i]+0.5);</description>
    </item>
    
    <item>
      <title>SRM 556 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm-556-div2--level2/</link>
      <pubDate>Tue, 16 Jul 2013 21:41:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-556-div2--level2/</guid>
      <description>問題 
①複数の地点が与えられて、それぞれの地点に値を持つ。
②また地点によっては道路で結ばれていて、
道路として結ばれている２次元配列が与えられる。
③ユーザは地点０から始まり、地点０のスコアを持つ。
④地点０から結ばれている地点に何度も行くことができ、
移動したときのスコアは、今まで持つスコアと移動した地点のスコアのＸＯＲとなる。
⑤このとき、最大となるスコアを求める。
解き方 
ぱっとみたときに何度も同じ地点を行き来することができるので、
全探索も浮かびにくい。
手掛かりとなる制約条件がないか例を出してシミュレーションしてみると、
ある地点に移動したとき、持っているスコアは１度しか現れないことがわかる。
つまり幅優先探索を行い、
地点とスコアの2次元配列を作成し
通ったことがあるかないかを判定すれば収束させることができる。
計算量はＯ（５０＊５０＊１０２４＝２．５＊１０＾６）なのでＯＫ．
コード 
class XorTravelingSalesman {
public: int maxProfit(vector&amp;lt;int&amp;gt; cityValues, vector&amp;lt;string&amp;gt; roads) {
int ans=cityValues[0];
bool visited[50][1023];
queue&amp;lt; pair&amp;lt;int,int&amp;gt; &amp;gt; q;
FORE(i,0,50)FORE(j,0,1023)visited[i][j]=false;
q.push(make_pair(0,cityValues[0]));
visited[0][cityValues[0]]=true;
while(!q.empty()){
int cur=q.front().first;
int value=q.front().second;
q.pop();
FORE(i,0,cityValues.size()){
if(i==cur)continue;
int tmpvalue=value^cityValues[i];
if( (roads[cur][i]==&#39;Y&#39; || roads[i][cur]==&#39;Y&#39;) &amp;amp;&amp;amp; !visited[i][tmpvalue]){
ans=max(ans,tmpvalue);
visited[i][tmpvalue]=true;
q.push(make_pair(i,tmpvalue));
}
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 554 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm-554-div2--level2/</link>
      <pubDate>Mon, 15 Jul 2013 09:24:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-554-div2--level2/</guid>
      <description>問題 
①高さを示す配列が与えられる。
②隣り合う高さについては、倒れた時もぶつからないよう２つのうち最大の高さ分の距離をとらなければならない。
③このとき、最小の距離となるよう高さを並べ替えるとき、
並べ替え後の要素の番号の配列を求める。
解き方 
高さの要素数が７なので、全探索すればよいです。
最初は高さに応じてnext_permutationと考えてしまったが、
このとき同じ距離の配列が存在するときに要素の昇順によってはエラーとなってしまいます。
ここでもう一つ考えられるかなのですが、
それでは「高さ」でソートするのではなく、「要素番号」でソートすれば
昇順で判定するため、上記の問題を解決することができます。
コード 
class TheBrickTowerMediumDivTwo {
public: vector&amp;lt;int&amp;gt; find(vector&amp;lt;int&amp;gt; heights) {
int ans=500;
int n=heights.size();
vector&amp;lt;int&amp;gt; tmp(n,0),tmp2(n,0);
FORE(i,0,n)tmp[i]=i;
sort(tmp.begin(),tmp.end());
do{
int cost=0;
FORE(i,0,n-1)cost+=max(heights[tmp[i]],heights[tmp[i+1]]);
if(cost&amp;lt;ans){
FORE(i,0,n)tmp2[i]=tmp[i];
ans=cost;
}
}while(next_permutation(tmp.begin(),tmp.end()));
return tmp2;
}
}; </description>
    </item>
    
    <item>
      <title>SRM580 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm580-div2--level2/</link>
      <pubDate>Sun, 14 Jul 2013 10:44:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm580-div2--level2/</guid>
      <description>問題 ①複数のうなぎが川を流れている。
②各うなぎは毎秒１の速さで進む。
③各うなぎに対し、最初に到達する時間ｔと、うなぎの長さｌが与えられる。
④うさぎは２回のｔ時刻だけ、うなぎを捕まえることができる。
選んだｔに対し、そのときに流れているうなぎを全て捕まえることができる。
⑤このとき、捕まえることのできるうなぎの最大数を求める。
解き方 
最初に全探索で考える。
各時刻に対しとらえることのできるうなぎの数を洗い出し、
全ての時刻から２つ時刻を選ぶ方法を全通り試して、最大のうなぎの数を返す。
しかし今回はうなぎの長さが１０＾９となるため、
全ての時刻の全探索で解くことができない。
では、選ぶ時刻の数を少なくすることはできないか？と考える。
もう少し考えると、うなぎの数が変化するのは頭と尾のときのみということがわかれば、
高々５０＊２＝１００通りの時刻を調べればよいことがわかる。
全体の計算量はＯ（１００＊５０＝５０００）なのでこの考え方で解くことができる。
コード 
class EelAndRabbit {
public: int getmax(vector&amp;lt;int&amp;gt; l, vector&amp;lt;int&amp;gt; t) {
int ans=0;
vector&amp;lt;int&amp;gt; v;
v.clear();
FORE(i,0,t.size()){
v.push_back(t[i]);
v.push_back(t[i]+l[i]);
}
FORE(i,0,v.size()){
FORE(j,i+1,v.size()){
int cur=0;
FORE(k,0,t.size()){
if( (t[k]&amp;lt;=t[i] &amp;amp;&amp;amp; t[i]&amp;lt;=t[k]+l[k]) || (t[k]&amp;lt;=t[j] &amp;amp;&amp;amp; t[j]&amp;lt;=t[k]+l[k]))cur++;
}
ans=max(ans,cur);
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM576 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm576-div2--level2/</link>
      <pubDate>Sun, 14 Jul 2013 09:09:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm576-div2--level2/</guid>
      <description>問題 
①２次元の配列が与えられる。
②配列には”Ｘ”で表わされる床が存在する。一番下は全て床になっている。
③また、コインのある座標が与えられる。
④ユーザは一番下の床からスタートし、任意の長さの梯子を使って床へ移動し、コインを獲得する。
⑤このとき、必要となる最小の梯子の長さを求める。
解き方 
問題の性質から、２分探索が思い浮かぶ。
ただ高さの上限が少ないので、単純に小さい数からループさせてもよい。
Ｃｈａｌｌｅｎｇｅのポイント
また、移動の判定とキューへのスタックがかなりの計算量になるので、
一度行ったことのある例外判定をきちんと行う必要がある。
たとえばコード中の以下など。
if(check[i][j]==1)continue;
コード 
class ArcadeManao {
public: int shortestLadder(vector&amp;lt;string&amp;gt; level, int coinRow, int coinColumn) {
int h=level.size(),w=level[0].size();
int check[h][w];
int low=0,high=h;
for(int L=0;L&amp;lt;100;L++){
queue &amp;lt;pair &amp;lt;int, int&amp;gt; &amp;gt; q;
q.push(make_pair(coinRow-1,coinColumn-1));
int flag=0;
FORE(i,0,h)FORE(j,0,w)check[i][j]=0;
while(!q.empty()){
int i=q.front().first;
int j=q.front().second;
q.pop();
if(check[i][j]==1)continue;
if(i==h-1){
flag=1;
break;
}
while(j-1&amp;gt;=0 &amp;amp;&amp;amp; level[i][j-1]==&#39;X&#39;)j--;
for(int cur=j;level[i][cur]==&#39;X&#39;;cur++){
check[i][cur]=1;
for(int up=i;up&amp;gt;=max(0,i-L);up--)
if(check[up][cur]==0 &amp;amp;&amp;amp; level[up][cur]==&#39;X&#39;)q.push(make_pair(up,cur));</description>
    </item>
    
    <item>
      <title>SRM574 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm574-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 21:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm574-div2--level2/</guid>
      <description>問題 
①数字が二つ与えられる。
②プレイヤーは一つ目の数字を１０で割る、もしくは逆にすることができる。
③上記の操作によって、２つ目の数字にするとき、最小の操作回数を求める。
２つ目の数字にできないときはー１を返す。
解き方 
どのような法則があるか例を出して導く。
289が求めたい数字のとき、
元の数字：１２８９　→３回
２８９１　→１回
１２８９１　→４回
つまり、
・最初から含まれる　→文字数の差
・途中から含まれる　→文字列の差＋２
ひっくり返した場合もシミュレーションすると、
ひっくり返した文字が含まれる　→文字数の差＋１回
ただ求めたい数字の場合は両方一致するため、
返す数が少ない方から判定していく。
コード 
class TheNumberGameDiv2 {
public:
string f(int n){
string str;
stringstream out;
out&amp;lt;&amp;lt;n;
out&amp;gt;&amp;gt;str;
return str;
}
int minimumMoves(int A, int B) {
string As=f(A);
string Bs=f(B);
int dis=As.size()-Bs.size();
int flag=0;
if(As.find(Bs)!=string::npos)flag=1;
if(As.find(Bs)==0)return dis;
reverse(Bs.begin(),Bs.end());
if(As.find(Bs)!=string::npos)return dis+1;
if(flag==1)return dis+2;
return -1;
}
}; </description>
    </item>
    
    <item>
      <title>SRM541 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm541-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 13:50:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm541-div2--level2/</guid>
      <description>問題 
①複数の座標が与えられる。
それぞれの座標にたいして、ＮＷＳＥの方向が与えられる。
②それぞれの座標には蟻がいて指定された方向に進む。
③蟻は他の蟻とぶつかったときにフィールドから消える。
フィールドの大きさに制限はない。
④このとき、最後に残る蟻の数を返す。
解き方 
単純にシミュレーションすることで解くことができる。
Ｃｈａｌｌｅｎｇｅ
このとき、１マスずつシミュレーションすると、
蟻の距離の差が１マスで方向が互い違いの時すれちがってしまいシステムエラーとなる。
１マスごとの処理で良いか、「選んだ単位の処理でミスがないか」チェックが必要。
コード 
class AntsMeet {
public: int countAnts(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y, string direction) {
int n=x.size(),ans=0;
vector&amp;lt;int&amp;gt; check(n,0);
double cx[n],cy[n];
FORE(i,0,n){
cx[i]=x[i];
cy[i]=y[i];
}
FORE(i,0,5000){
FORE(j,0,n){
if(check[j]==1)continue;
if(direction[j]==&#39;N&#39;)cy[j]+=0.5;
if(direction[j]==&#39;W&#39;)cx[j]-=0.5;
if(direction[j]==&#39;E&#39;)cx[j]+=0.5;
if(direction[j]==&#39;S&#39;)cy[j]-=0.5;
}
FORE(j,0,n){
int used=0;
if(check[j]==1)continue;
FORE(k,j+1,n){
if(check[k]==1)continue;
if(cx[j]==cx[k] &amp;amp;&amp;amp; cy[j]==cy[k]){
check[k]=1;
used=1;
}
}
if(used==1)check[j]=1;
}
}
FORE(i,0,n)if(check[i]==0)ans++;
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM550 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm550-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 10:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm550-div2--level2/</guid>
      <description>問題 
①大きさがわからない、２次元のセルを飛行機が移動する。
②また、移動セル数を示す数字の配列が与えられる。
③最初は右を向いており、最初の移動セル数分だけ右に移動する。
壁にぶつかるかすでに移動したセルにぶつかると、９０度左を向く。
そして次の移動セル分だけ移動する。
④このとき、セルの大きさを求める。
ただし、②の移動に従わない動きであればー１を返す。
解き方 
シミュレーションの問題。
いかに間違いが少なくなるようにかけるか、できるだけ単純にコーディングする。
今回は、セルの大きさを求めるシミュレーションと、例外を求めるシミュレーションを分けて実装する。
まず、セルの大きさは最初の移動をシミュレーションして
ｘ座標とｙ座標それぞれ最小と最大を求めれば簡単に算出できる。
次に、求めたｘ座標とｙ座標の最小値と最大値を利用して
例外ケースではないか判定のシミュレーションを行う。
コード 
int cell[110][110];
class RotatingBot {
public: int minArea(vector&amp;lt;int&amp;gt; moves) {
int maxX=55,minX=55,maxY=55,minY=55;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
int x=55,y=55,dir=0;
FORE(i,0,moves.size()){
x+=moves[i]*dx[dir%4];
y+=moves[i]*dy[dir%4];
minX=min(minX,x);
minY=min(minY,y);
maxX=max(maxX,x);
maxY=max(maxY,y);
dir++;
}
FORE(i,0,110)FORE(j,0,110)cell[i][j]=0;
x=55,y=55,dir=0,cell[y][x]=1;
FORE(i,0,moves.size()){
int num=0;
while(1){
int tmpx=x+dx[dir%4];
int tmpy=y+dy[dir%4];
num++;
if(num&amp;gt;moves[i]){
if(i==moves.size()-1)break;
if(cell[tmpy][tmpx]==1 || tmpx&amp;gt;maxX || tmpx&amp;lt;minX || tmpy&amp;lt;minY || tmpy&amp;gt;maxY){
dir++;</description>
    </item>
    
    <item>
      <title>SRM547 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm547-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 09:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm547-div2--level2/</guid>
      <description>問題 
①それぞれの棒について、最大の高さを表わす配列が与えられる。
②それぞれの棒について、１～最大の高さまで任意に設定することができる。
③また、それぞれの棒の距離を示すｗが与えられる。
④このとき、すべての棒の頂点を結ぶ紐を考えた時、最大となる紐の長さを求める。
解き方 
棒Ｎ個の時の最大の長さは、
Ｎ－１個の棒が１～最大の長さに対するそれまでの最大の紐の長さがわかれば
すぐに求めることができる。
また、Ｎ個のときの棒の長さはＮ－１個までの最大の紐の長さに影響を与えないため、
動的計画法で解くことができる。
Eclipseで利用した時、&amp;lt;math&amp;gt;でインポートしようとしたのがうまくいかなくて
&amp;lt;math.h&amp;gt;でなんとかうまくいったのですがかなりひっかかりました。。
コード 
class PillarsDivTwo {
public: double maximalLength(vector&amp;lt;int&amp;gt; height, int w) {
int n=height.size();
double dp[n][101],ans=0.0;
FORE(i,0,n)FORE(j,0,101)dp[i][j]=0.0;
FORE(i,0,n-1){
FORE(j,0,height[i+1]){
FORE(k,0,height[i]){
double length=sqrt(w*w+(j-k)*(j-k));
dp[i+1][j]=max(dp[i+1][j],dp[i][k]+length);
}
}
}
FORE(i,0,101)ans=max(ans,dp[n-1][i]);
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM551 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm551-div2--level2/</link>
      <pubDate>Sat, 13 Jul 2013 09:00:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm551-div2--level2/</guid>
      <description>問題 
①大文字のアルファベットの配列が与えられる。
②任意の要素をスワップことができるが、スワップ回数の上限も与えられる。
③このとき、同じアルファベットが隣り合う最大の数を求める。
解き方 
最初に全探索をイメージすると、各アルファベットごとに最大の数を求めることがイメージできます。
次に、スワップについての全探索のイメージを浮かべるのが難しかったです。
スワップの操作について全探索を考えるのではなく、
スワップ後の「最終形をイメージ」すると、
隣り合うアルファベットのサブセット最大数は
一番左の要素番号ごとに一意に求められることがわかります。
さらに、並べるのに使うアルファベットも「連続している」ということがわかれば、
最初に使うアルファベットの数も最も左のものから一つずつインクリメントしていくことで、全探索することができます。
コード 
class ColorfulChocolates {
public: int maximumSpread(string chocolates, int maxSwaps) {
int ans=0,n=chocolates.size();
for(char C=&#39;A&#39;;C&amp;lt;=&#39;Z&#39;;C++){
FORE(i,0,n){
FORE(j,0,n){
int left=i,cur=j;
int swaps=0;
while(left&amp;lt;n &amp;amp;&amp;amp; cur&amp;lt;n){
while(cur&amp;lt;n &amp;amp;&amp;amp; chocolates[cur]!=C)cur++;
if(cur&amp;gt;=n)break;
int tmp=abs(cur-left);
if(swaps+tmp&amp;gt;maxSwaps)break;
swaps+=tmp;
left++;
cur++;
}
ans=max(ans,left-i);
}
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM 543 DIV1 Easy - EllysXors</title>
      <link>https://chaingng.github.io/post/srm-543-div1-easy---ellysxors/</link>
      <pubDate>Fri, 12 Jul 2013 08:36:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm-543-div1-easy---ellysxors/</guid>
      <description>問題 
①整数ＬとＲが与えられる。
②このとき、ＬからＲまでの間全ての数をＸＯＲした後の値を求める。
解き方 
Ｌ，Ｒは４＊１０＾９のため単純なシミュレーションでは解くことができない。
そのため、数学的解法、法則を見つける。
法則を見つけるために１からずっとＸＯＲをしたときの値を並べてみると、
整数ｎを４で割ったときの余りによって以下になることがわかる。
余り０　→　ｎ
余り１　→　１
余り２　→　ｎ　ＸＯＲ　１
余り３　→　０
最後に１からスタートしているわけではなくてＬからスタートしなければならない。
これは１からＲまで求めた答えから、１からＬ－１まで求めた答えを引く、つまりＸＯＲしてあげればよい。
コード 
class EllysXors {
public:
long long f(long long n){
long long check=n%4;
if(check==0)return n;
if(check==1)return 1;
if(check==2)return n^1;
return 0;
}
long long getXor(long long L, long long R) {
return f(R)^f(L-1);
}
}; </description>
    </item>
    
    <item>
      <title>SRM534 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm534-div2--level2/</link>
      <pubDate>Wed, 10 Jul 2013 09:52:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm534-div2--level2/</guid>
      <description>問題 
①１次元の列が与えられ、ランダムな数の石がおかれている。
②この石は右に１マスもしくは３マス動かすことができる。
３マス動かす時はその間の石を飛び越すことができる。
しかし、動かした先に石がある場合は動かすことができない。
最後のマスに達したときはその石は動かすことはできなく、消えてしまう。
③２人のプレイヤーが順にこの操作を行う。
石を動かせなくなった方が負けとなる。
④このとき、最初のプレイヤーが勝つならＹＥＳ,負けるならＮＯを返す。
解き方 
デッドロックが発生する場合を想定すると複雑になりそうに見える。
しかし、そのように見える場合でも一番右の石は動かすことができるので、
それぞれの石は独立に考えることができる。
これがわかれば、動かすことのできるマスが奇数の場合は最初のプレイヤーが勝ち、
偶数の場合は負けることがわかる。
コード 
class EllysCheckers {
public: string getWinner(string board) {
int parity=0;
FORE(i,0,board.size()-1)if(board[i]==&#39;o&#39;)parity+=(board.size()-1-i);
return parity%2!=0 ? &#34;YES&#34; : &#34;NO&#34; ;
}
}; </description>
    </item>
    
    <item>
      <title>SRM533 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm533-div2--level2/</link>
      <pubDate>Wed, 10 Jul 2013 09:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm533-div2--level2/</guid>
      <description>問題
①数字の配列が与えられ、それぞれの配列は重さを表わす。
②最初と最後以外の要素を任意で選ぶことができ、選んだ要素の前と後の重さの積がスコアにプラスされる。
選ばれた要素は消去される。
③このとき、最大となるスコアを求める。
解き方
配列の数は最大で１０のため
全ての場合の数を求めてもＯ（８！＝４０３２０）となるので全探索可能。
コード
class CasketOfStarEasy {
public:
int f(vector&amp;lt;int&amp;gt; &amp;amp;w){
if(w.size()==2)return 0;
int score=0;
FORE(i,1,w.size()-1){
vector&amp;lt;int&amp;gt; tmp;
FORE(j,0,w.size())if(j!=i)tmp.push_back(w[j]);
score=max(score,w[i-1]*w[i+1]+f(tmp));
}
return score;
}
int maxEnergy(vector&amp;lt;int&amp;gt; weight) {
return f(weight);
}
};

 </description>
    </item>
    
    <item>
      <title>SRM539 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm539-div2--level2/</link>
      <pubDate>Tue, 09 Jul 2013 08:28:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm539-div2--level2/</guid>
      <description>問題
①数字の配列が２つ与えられる。
それぞれの番号は、岩が入るＢＯＸの最小の数と最大の数を表わす。
②あなたは岩を無数に持っており、選んだＢＯＸに最小の数以上、
最大の数まで岩を入れることができる。
③このとき、岩を９００１個以上入れた時に表わすことのできる
岩の個数の場合の数を返す。
解き方
問題文を最初ミスリーディングしてしまったのですが、
「９００１個以上入れることのできる場合の数」ではなく、
「表わすことのできる岩の個数の場合の数」になります。
最初にこのまま全探索しても手掛かりがないため、
全てのＢＯＸの選び方はＯ（２＾１５＝１０＾３＊３２）で選ぶことができるため
選んだＢＯＸについて考える。
そうすることで最小の岩の数と最大の岩の数がわかるため、
９００１以上の表わせる岩の個数がわかる。
ただし表わせる岩の個数を配列に保存しようとすると
次に、岩の数は１０＾６とかなり大きいため、
Ｏ（１０＾６＊１０＾３＊３２）で計算できない。
そこで、全て配列に保存するのではなく
範囲を保存することを考える。
始点の岩の数の配列を＋１とし、終点の次の配列をー１とすることで、
＋のときはその間の数は存在することとなる。
この処理を全て行っていくと、
配列の数を最初から足していったとき＋１以上のときはその数は存在することとなる。
Ｃｈａｌｌｅｎｇｅポイント
配列（ループ）の数を１０＾７＊２だとエラーになってしまいました。
１０＾６＊１．６だと通ったので、
１０＾７＊２以上にならないことがＣｈａｌｌｅｎｇｅのポイントになりそうです。
またケアレスミスをしてしまいましたが
ビット列計算をするときは＆＆ではなく＆になります。
コード
class Over9000Rocks {
public: int countPossibilities(vector&amp;lt;int&amp;gt; lowerBound, vector&amp;lt;int&amp;gt; upperBound) {
int n=lowerBound.size(),ans=0;
vector&amp;lt;int&amp;gt; check(16000000,0);
for(int select=1;select&amp;lt;(1&amp;lt;&amp;lt;n);select++){
int upper=0,lower=0;
for(int j=0;j&amp;lt;n;j++){
if(select&amp;amp;1&amp;lt;&amp;lt;j){
lower+=lowerBound[j];
upper+=upperBound[j];
}
}
check[lower]++;
check[upper+1]--;
}
int parity=0;
FORE(i,0,(int)check.size()){
parity+=check[i];
if(i&amp;gt;9000 &amp;amp;&amp;amp; parity&amp;gt;0)ans++;
}
return ans;</description>
    </item>
    
    <item>
      <title>SRM537 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm537-div2--level2/</link>
      <pubDate>Tue, 09 Jul 2013 08:14:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm537-div2--level2/</guid>
      <description>問題
①数字のペアＡ，Ｂが与えられる。
このとき、０以上のｐ、ｑに対し、Ａ＊ｐ＋Ｂ＊ｑで数が生成できる。
②また、新たな数字Ｘが与えられる。
このとき、Ａ，Ｂで表わせる全てのペアが、Ｘ，Ｙでも表わせるような
Ｙの場合の数を求める。ただしＹが無限になる場合はー１を返す。
解き方
Ｘ，ＹにてＡ，Ｂが表わすことができれば、
Ａ，Ｂで現すことのできる全ての数はＸ，Ｙで現すことができる。
Ｙのとりうる数は１～max(A,B) (Xを除く)なので、
全てのＹに対してＸ，ＹがＡ，Ｂで表わせるかを判定する。
Ａ＝Ｘ＊ｐ＋Ｙ＊ｑ
ｑ＝１として、
pが０からＸ＊ｐがＡになるまで増やしていき、
Ｙで割ることができるか判定する。
ｑ＝０の場合も調べるため、ＡがＸで割り切れるかも判定する。
全て数学的解法に頼らず、全探索との組み合わせで落とし所を探る。
コード
class KingXNewCurrency {
public:
bool f(int num,int x,int y){
if(num%x==0)return true;
for(int i=0;x*i&amp;lt;=num;i++)if((num-x*i)%y==0)return true;
return false;
}
int howMany(int A, int B, int X) {
if(A%X==0 &amp;amp;&amp;amp; B%X==0)return -1;
int ans=0;
for(int n=1;n&amp;lt;=max(A,B);n++)if(X!=n &amp;amp;&amp;amp; f(A,X,n) &amp;amp;&amp;amp; f(B,X,n))ans++;
return ans;
}
};

 </description>
    </item>
    
    <item>
      <title>SRM546 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm546-div2--level2/</link>
      <pubDate>Thu, 04 Jul 2013 22:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm546-div2--level2/</guid>
      <description>問題  ①座標上にある２つの長方形の左下と右上の座標が与えられる。
②２つの長方形の重なりが四角形の時はrectangle、線で接している場合はsegment、
点で接している場合はpoint、接していないときはnoneを返す。
解き方  単純に場合分けで解いてもよいが複雑になり間違えやすくなる＆コードが書きにくくなるので、数学的に簡単にできないか検討する。
まず２次元の問題ということで、それぞれ1次元の問題に分割できないか検討する。
今回の場合はｘ軸とｙ軸はそれぞれ影響を与えないので独立に考えられる。
次に、ｘ軸が線・点を作れるか、ｙ軸も同じように線・点を作れるか
という考え方ができれば、ｘ軸とｙ軸の組み合わせによってどの重なりになるか
求めることができる。
最後に各軸が線・点を作れる場合を考える。
１つ目の長方形の最左辺と最右辺がa、ｂとすると、
長方形の中にあるｘ軸の値はa&amp;lt;=x&amp;lt;=bとなる。
同様に2つ目の最左辺と最右辺をｃ、ｄとすると、
c&amp;lt;=x&amp;lt;=dとなる。
ここで２つの条件を合わせると、
max(a,c)&amp;lt;x&amp;lt;min(b,d)がｘの範囲となる。
つまりxのとりうる範囲　min(b,d)-max(a,c)が
複数であれば線、
１点のみであれば点、
存在しなければ、どちらも作れないということがわかる。
これをｙ軸も同じように判定すれば簡単に求められる。
コード  class TwoRectangles {
public:
int f(int x){
if(x&amp;gt;0)return 1;
if(x==0)return 0;
return -1;
}
string describeIntersection(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
int checkx=f(min(A[2],B[2])-max(A[0],B[0]));
int checky=f(min(A[3],B[3])-max(A[1],B[1]));
if(checkx==1 &amp;amp;&amp;amp; checky==1)return &amp;ldquo;rectangle&amp;rdquo;;
if(checkx==1 &amp;amp;&amp;amp; checky==0 || checkx==0 &amp;amp;&amp;amp; checky==1)return &amp;ldquo;segment&amp;rdquo;;
if(checkx==0 &amp;amp;&amp;amp; checky==0)return &amp;ldquo;point&amp;rdquo;;
return &amp;ldquo;none&amp;rdquo;;</description>
    </item>
    
    <item>
      <title>SRM563 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm563-div2--level2/</link>
      <pubDate>Wed, 03 Jul 2013 23:29:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm563-div2--level2/</guid>
      <description>＜問題＞
①２次元のフィールドが与えられる。
②フィールドにはランダムな数の障害物と、２つのコインが置かれている。
③プレイヤーは上下左右の操作をすることができ、１度の操作で選んだ方向に１マスだけ２つのコインを動かせる。動く先に障害物がある場合は動かない。
④コインが動いた時、フィールドから外れた場合はコインが落ちる。
⑤このとき、コインを１つだけ落としたいときの最小の操作回数を返す。
ただし、操作回数が１０回を超えた時はー１を返す。
＜解き方＞
動的計画法で最小の操作回数を求める。
単純なシミュレーションですが、いかに簡単に書いて間違いを少なくするかが
ポイントだと思います。
-1となる例外の処理を再帰関数で書いた時には処理がうまくいかなかったので、
例外の処理はメイン関数で行う方がよさそう。
また、vectorを渡す時には &amp;amp;bのようにしてあげないと
処理がおかしくなるので注意。
＜コード＞
class CoinsGameEasy {
public:
int f(int turn,int x1,int y1,int x2,int y2,vector&amp;lt;string&amp;gt;&amp;amp; b){
if(turn&amp;gt;10)return turn;
int ret=11,w=b[0].size(),h=b.size();
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
FORE(i,0,4){
int flag=0;
int tx1=x1+dx[i],ty1=y1+dy[i],tx2=x2+dx[i],ty2=y2+dy[i];
if(tx1&amp;lt;0 || tx1&amp;gt;=w || ty1&amp;lt;0 || ty1&amp;gt;=h)flag++;
if(tx2&amp;lt;0 || tx2&amp;gt;=w || ty2&amp;lt;0 || ty2&amp;gt;=h)flag++;
if(flag==1)return turn+1;
if(flag==2)continue;
if(b[ty1][tx1]==&#39;#&#39;)tx1=x1,ty1=y1;
if(b[ty2][tx2]==&#39;#&#39;)tx2=x2,ty2=y2;
ret=min(ret,f(turn+1,tx1,ty1,tx2,ty2,b));
}
return ret;
}
int minimalSteps(vector&amp;lt;string&amp;gt; board) {</description>
    </item>
    
    <item>
      <title>SRM535 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm535-div2--level2/</link>
      <pubDate>Wed, 03 Jul 2013 23:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm535-div2--level2/</guid>
      <description>＜問題＞
①整数ＧとＬが与えられる。
②最大公約数がＧ，かつ最小公倍数がＬである２つの数字の場合の数を返す。
存在しない場合はー１を返す。
＜解き方＞
２つの数字がＸ、Ｙとすると、Ｘ＊Ｙ＝Ｇ＊Ｌとなる。
このままではＧとＬともに１０＾１２と膨大な数のため計算式を工夫する。
次に、Ｘ＝a*Gとなるa, Y=b*Gとなるbが必ず存在する。
ここで、
(a*G)*(b*G)=G*L
つまりa*b=L/Gとなるaとbが必ず存在する。
また、最大公約数がＧであることから、aとbは互いに素でないといけない。
これによりＯ（１０＾６）で計算可能となる。
まとめると、
a*b=L/G かつ aとbは互いに素=最大公約数が1　となる全てのaとbを求めればよい。
そして裏を返すと、LがGで割り切れない場合は-1を返す。
＜コード＞
class FoxAndGCDLCM {
public:
long long gcd(long long a,long long b){
while(b!=0){
long long c=b;
b=a%b;
a=c;
}
return a;
}
long long get(long long G, long long L) {
long long ab=L/G,ret=-1;
if(L%G!=0)return -1;
for(long long a=1;a&amp;lt;=ab/a;a++){
if(ab%a==0 &amp;amp;&amp;amp; gcd(a,ab/a)==1){
if(ret==-1)ret=G*(a+ab/a);
else ret=min(ret,G*(a+ab/a));
}
}
return ret;
}</description>
    </item>
    
    <item>
      <title>SRM536 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm536-div2--level2/</link>
      <pubDate>Wed, 03 Jul 2013 22:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm536-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①１～９個の面を持つサイコロがあり、決められた数だけ存在する。
②どのサイコロを与えられたかはわからない。同じ面を持つサイコロは複数存在しうる。
③そのサイコロの集合を複数回投げて、出た表の面の集合が与えられる。
④このとき、可能性のあるサイコロの集合のうち最も面の数が少なくなるような和を返す。
＜解き方＞
全ての面の出方についてそれぞれソートする。
ソートした後、それぞれの１番目の要素の中で最大のものが
１番目の要素の最小の答えとなる。
２番目以降も同様。
最後に求めた全ての要素の和を返す。
＜コード＞
class RollingDiceDivTwo {
public: int minimumFaces(vector&amp;lt;string&amp;gt; rolls) {
int n=rolls.size(),ret=0;
vector &amp;lt;int&amp;gt; ans(rolls[0].size(),0);
FORE(i,0,n)sort(rolls[i].begin(),rolls[i].end());
FORE(i,0,n){
FORE(j,0,rolls[0].size()){
if(ans[j]&amp;lt;rolls[i][j]-&#39;0&#39;)ans[j]=rolls[i][j]-&#39;0&#39;;
}
}
FORE(i,0,rolls[0].size())ret+=ans[i];
return ret;
}
}; </description>
    </item>
    
    <item>
      <title>怒らないこと</title>
      <link>https://chaingng.github.io/post/%E6%80%92%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8/</link>
      <pubDate>Mon, 01 Jul 2013 20:13:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%80%92%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8/</guid>
      <description>日々暮らしていると時々えっ！となるようなことがありますが、
そういうときでも怒らないことって大事だと思います。
怒ることで自分の感情はすっきりするかもしれませんが、その後その人と接するのがストレスになったり、結果として自分としてもよくないことがかえってくるなと感じます。
じゃあどうすればよいかですが、自分の言いたいことは伝えても、どうしても強く言わなければならないときは、怒るのではなく叱るということがよいと思っています。
その人を責めるのではなく、物事や怒ったことに対して話をする。感情で話をしないようにする。
こうすることで、自分にとってもプラスになると考えています。実践できないことも多いですが・・・日々の心がけですね。
 </description>
    </item>
    
    <item>
      <title>SRM565 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm565-div2--level2/</link>
      <pubDate>Sun, 30 Jun 2013 00:05:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm565-div2--level2/</guid>
      <description>＜問題＞
①モンスターの集合が与えられ、各モンスターは怖さの値とコインの値を持つ。
②プレイヤーは最初から順番にモンスターに遭遇する。
③このとき、プレイヤーはモンスターにそのコインの値を支払って仲間にすることができる。
④もしくは、仲間にしたモンスターの怖さの和がそのモンスターの怖さの値以上であれば、何もせずに通り過ぎることができる。それ未満であれば、仲間にしないといけない。
⑤このとき、すべてのモンスターに遭遇した後に最小のコイン消費枚数を返す。
＜解き方＞
まさに動的計画法。
参照用のvectorをグローバルで宣言してpush_backでコピーしようとしたんですが、
エラーが出たので引数で渡すことに。
suztomoさんのページを拝見させていただいたのですが、
１０＾７以上のループに加え、あまり大きな数を扱ってもダメなのかもしれないです。
http://topcoder.g.hatena.ne.jp/suztomo/20081208/1228768981
＜コード＞
class MonstersValley2 {
public:
int f(int cur, double cdread, vector&amp;lt;int&amp;gt; d, vector&amp;lt;int&amp;gt; p){
int coin=0;
if(cur==n)return 0;
if(cdread&amp;lt;d[cur])coin=p[cur]+f(cur+1,cdread+d[cur],d,p);
else coin=min(f(cur+1,cdread,d,p),f(cur+1,cdread+d[cur],d,p)+p[cur]);
return coin;
}
int minimumPrice(vector&amp;lt;int&amp;gt; dread, vector&amp;lt;int&amp;gt; price) {
n=dread.size();
return f(1,dread[0],dread,price)+price[0];
}
};

 </description>
    </item>
    
    <item>
      <title>SRM564 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm564-div2--level2/</link>
      <pubDate>Sat, 29 Jun 2013 23:17:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm564-div2--level2/</guid>
      <description>＜問題＞
①赤のボールの数、緑のボールの数、青のボールの数と１つの整数が与えられる。
②システムは赤のボールがあれば1個壊し、次に緑のボールがあれば１個壊し、次に青のボールがあれば１個壊す。この操作を繰り返す。
③このとき、与えられた整数のターンの時に壊すボールの色を返す。
＜解き方＞
整数が３つのボールのうち１番小さい数×３以下であれば３で割った余りで色を判別できる。
それ以上であればいったん一番小さい数を除いたあと、２つの色で判定。
そのあとは残りの１色となる。
if文の分岐で記載することもできるが、
ループ処理で書くことによって処理が間違えにくくなる。
色の数を３から減らしていくことと、
１つの色の処理ごとに、配列を詰めていくやり方でコードを書く。
＜コード＞
class AlternateColors {
public: string getColor(long long r, long long g, long long b, long long k) {
long long c[]={r,g,b};
string name[]={&#34;RED&#34;,&#34;GREEN&#34;,&#34;BLUE&#34;};
int t=3;
while(t&amp;gt;1){
long long m=c[0];
FORE(i,1,t)m=min(m,c[i]);
if(k&amp;lt;=m*t)return name[(k-1)%t];
k-=(m*t);
int tmp=t;
t=0;
FORE(i,0,tmp){
if(c[i]-m&amp;gt;0){
c[t]=c[i]-m;
name[t]=name[i];
t++;
}
}
}
return name[0];
}
}; </description>
    </item>
    
    <item>
      <title>SRM566 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm566-div2--level2/</link>
      <pubDate>Sat, 29 Jun 2013 12:26:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm566-div2--level2/</guid>
      <description>＜問題＞
①青が好きなペンギンと、赤が好きなペンギンが輪になって並ぶ。
②同じ色が好きなペンギン同士は線を結んでペアを作る。
③ただし、線は交差してはいけない。
④それぞれ好きな色を持つペンギンの集合が与えられた時、
ペアの最大数を返す。
＜解き方＞
隣同士のペンギンで線を結んでも交差に影響することはないので、
まずは隣同士で同じ色のペアを作って集合から削除していく。
このとき、輪になっていることから最初と最後の判定を先に行い、
その後「赤・赤」「青・青」のペアとなっているところを判定していく。
そのあとは赤と青が交互になった順列ができるので、
残りのペア数は残った集合の半分－１となる。
＜関数＞
stringに対しての処理なので、うまくsubstrとeraseを使ってあげることで
集合から削除すれば処理が簡単になる。
＜コード＞
class PenguinPals {
public:
int findMaximumMatching(string colors) {
int ans=0,flag=1;
while(flag){
flag=0;
if(colors.size()&amp;lt;2)break;
if(colors[0]==colors[colors.size()-1]){
ans++;
colors=colors.substr(1,colors.size()-2);
flag=1;
}
else if(colors.find(&#34;RR&#34;)!=-1){
ans++;
colors.erase(colors.find(&#34;RR&#34;),2);
flag=1;
}
else if(colors.find(&#34;BB&#34;)!=-1){
ans++;
colors.erase(colors.find(&#34;BB&#34;),2);
flag=1;
}
}
if(colors.size()&amp;gt;2)ans+=(colors.size()/2-1);
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM567 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm567-div2--level2/</link>
      <pubDate>Sat, 29 Jun 2013 10:46:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm567-div2--level2/</guid>
      <description>＜問題＞
①２つの整数ＮとＭが与えられる。
②１＜＝Ａ＜＝Ｎ、１＜＝Ｂ＜＝Ｍである、(sqrt(A)+sqrt(B))^2が整数であるＸが存在するとき、ＡとＢの組み合わせの数を返す。
＜解き方＞
Ａが１のとき、Ｂ＝１，４，９，１６・・・
Ａが２のとき、Ｂ＝２＊１、２＊９、２＊１６・・・であることがわかります。
そのため、Ａを１からＮまでループさせ、
ＢをＡ＊１＾２、Ａ＊２＾２・・・と繰り返して数を足してあげて
最後にその和をかえしてあげればよいです。
Ｏ（８００００＊９００＝７２００００００＝７＊１０＾７）なので微妙。
もう少し計算量を削減するには、
Ａが２で選ばれるＢの数と、
Ａが２＊２＾２、２＊３＾２・・・で選ばれるＢの数は一緒であることが分かります。
そこでＡもまとめて計算することで計算量が削減できます。
おおまかですがＯ（９００＊９００＝８１００００＝８＊１０＾５）ぐらい。
＜コード＞
class TheSquareRootDilemma {
public: int countPairs(int N, int M) {
vector&amp;lt;int&amp;gt; check(77778,0);
int ans=0;
FORE(i,1,M+1){
if(check[i]==1)continue;
int x=0;
for(int j=1;j*j*i&amp;lt;=M;j++){
if(check[i*j*j]==1)continue;
check[i*j*j]=1;
x++;
}
int y=0;
for(int j=1;j*j*i&amp;lt;=N;j++)y++;
ans+=(x*y);
}
return ans;
}
};
 </description>
    </item>
    
    <item>
      <title>パリの危なさ</title>
      <link>https://chaingng.github.io/post/%E3%83%91%E3%83%AA%E3%81%AE%E5%8D%B1%E3%81%AA%E3%81%95/</link>
      <pubDate>Thu, 27 Jun 2013 21:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%83%91%E3%83%AA%E3%81%AE%E5%8D%B1%E3%81%AA%E3%81%95/</guid>
      <description>いままで海外はアジア地域でタイ、カンボジア、インド、
ヨーロッパ地域では安全と言われるフィンランド、スイスからドイツ、治安が悪いと言われるスペインまで行ったことがありますが、
そこのどこよりもパリは危険な場所と感じました。
というのも、１つはガイドブックでしか見ていなかったスリに本当にあいそうになったんです。
それは観光名所で有名なセーヌ川下りにポンヌフ橋まで向かうとき、橋から階段を下りて船着き場にいくところでのことです。
階段を下りているとき、一緒にいた妻が気づいて声をかけたのですが、後ろを振り向いてみるとピッタリ後ろに着いて降りてくる若い女性二人組が。
そこで妻は先に行っていいよ、といって追い払ったのですが、のちのち聞いてみると自分のバッグのチャックをつかんでいたとのこと。
まったく自分では気付かなかったので、そこの場所を専門にしているプロなんだなと、びっくりしました。
そこからはバッグは前に持つようにしましたが。。
一緒にいった他の人も、子供が集団で集まってきてポケットに入れたスマホを奪われそうになったり、そして他の人が奪われた光景を見たとのこと。
スマホをポケットに入れても危ないそうです。
つい最近はルーブル美術館が犯罪者が増えたことからストを起こして、警備員を増強してもらったというニュースも見ました。
聞いた話ではなく、身近な人の話だけでこれだけのことがあったので
皆さんもパリに行く際は気をつけてください。 </description>
    </item>
    
    <item>
      <title>くどいほどの自問自答</title>
      <link>https://chaingng.github.io/post/%E3%81%8F%E3%81%A9%E3%81%84%E3%81%BB%E3%81%A9%E3%81%AE%E8%87%AA%E5%95%8F%E8%87%AA%E7%AD%94/</link>
      <pubDate>Wed, 26 Jun 2013 19:40:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E3%81%8F%E3%81%A9%E3%81%84%E3%81%BB%E3%81%A9%E3%81%AE%E8%87%AA%E5%95%8F%E8%87%AA%E7%AD%94/</guid>
      <description>前の記事でミスや想定外の事態に備えるためには
最悪の事態を想定する、と書きましたが、
ブルガリア戦に負けた際に本田圭佑選手が開いた記者会見にヒントがあったので書きます。
まず試合に負けたのは「気持ちの面」ということ。
実力不足ではなく、気持ちの持ちようでカバーできることは意外と多いと思います。
そしてその気持ちのもちようというのを具体化すると、「くどいほど自問自答すること」。
「大丈夫か？」「準備はこれで足りているか」と自分がもうくどい！と思えるぐらいやることで、ようやく油断はなくなるものだと。
確かに、そのくらい大事で緊張する出来事のときは不安になって、ものすごく準備して、そして結果としてうまくいくことが多かったので、
準備すべきことに対して「不安を感じ」、「くどいぐらい自問自答する」ことがポイントなのだと気付きました。
やっぱり超一流選手は違いますね。
 </description>
    </item>
    
    <item>
      <title>海外出張２日目</title>
      <link>https://chaingng.github.io/post/%E6%B5%B7%E5%A4%96%E5%87%BA%E5%BC%B5%EF%BC%92%E6%97%A5%E7%9B%AE/</link>
      <pubDate>Thu, 20 Jun 2013 14:45:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%B5%B7%E5%A4%96%E5%87%BA%E5%BC%B5%EF%BC%92%E6%97%A5%E7%9B%AE/</guid>
      <description>今日から打ち合わせが始まりました。
今日の話はこうしておけばという反省から学ぶことをまとめます。
１つ学んだのは、念には念を入れておく、ということです。
１つは用意をお願いした設備がなかったということがあったので、その場合を想定してビデオ撮影しておけばよかったなと。
１つはレビュー時にここを直すか議論になりそのままでいったのが結果として通じなかったということがあったので、とりあえず相手の意見を聞いて反映しておけば責められずに済んだかなと。
そして正装はいらないという話でしたがもし使うかも、という不安を感じてしまったので念のため用意をしておくということ。
プラス思考で考えるのも大事なのですが、出来事については最悪のケースを想定して行動すべきだなと思いました。
そしてそれでも起こってしまうことはあるので、そのときに一呼吸して、臨機応変に行動できることも必要と思いました。
このように考えて備えを用意できるようにしておきたいです。 </description>
    </item>
    
    <item>
      <title>海外出張１日目</title>
      <link>https://chaingng.github.io/post/%E6%B5%B7%E5%A4%96%E5%87%BA%E5%BC%B5%EF%BC%91%E6%97%A5%E7%9B%AE/</link>
      <pubDate>Thu, 20 Jun 2013 14:31:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%B5%B7%E5%A4%96%E5%87%BA%E5%BC%B5%EF%BC%91%E6%97%A5%E7%9B%AE/</guid>
      <description>研修では昨年一度海外へ行ったことはあるのですが、
純粋な業務では初めての海外出張です。
この時期のパリは夜が遅くても明るいので
びっくりです。
１日が長く感じますね。
きちんと成果を出して、
よい出張になるように頑張りたいです。
 </description>
    </item>
    
    <item>
      <title>SRM568 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm568-div2--level2/</link>
      <pubDate>Mon, 17 Jun 2013 09:06:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm568-div2--level2/</guid>
      <description>＜問題＞
①Ｎ個の箱が与えられる。
②それぞれの箱には、赤と緑と青のボールが複数個入っている。
③このとき、それぞれの箱に１色のボールしか入らないようにしたいとき、最小のボールの移動回数を求めよ。
＜解き方＞
ひとつの箱に着目した時、一番多く入っている色をそのまま残して、
他の色を移動したらよいことがわかる。
ただしこのとき、ひとつの色がどの箱にも少ない個数であるときに
その色に移動させる箱が存在しなくなるため、例外のケースも存在する。
このままではＮＧ．
では全探索で考えるとすると、最大で箱が５０個のためＯ（３＾５０）でＮＧ．
では上の考え方を少し応用させると、それぞれの色は少なくとも１回は選ばれることとなる。
これがわかると、各色が１回ずつ選ばれる場合の数は最大でも５０＾３でＯＫ．
つまり答えは、それぞれの色が１回選ばれる場合でループを回して、それ以外の箱は貪欲方で最大の個数の色を残してあげればよい。
（例外処理）
最後に例外として、今回は個数が最小で１個なのでこのままでＯＫ．
最小で0個だと、選ばれない場合の数は削除しないといけないので注意。
最大の数も今回は５０×１０＾６＝５×１０＾７なのでint型でＯＫ．
＜コード＞
class BallsSeparating {
public: int minOperations(vector&amp;lt;int&amp;gt; red, vector&amp;lt;int&amp;gt; green, vector&amp;lt;int&amp;gt; blue) {
int ans=1000000000;
int n=red.size();
FORE(i,0,n){
FORE(j,0,n){
if(i==j)continue;
FORE(k,0,n){
if(j==k || k==i)continue;
int cost=0;
FORE(x,0,n){
if(x==i)cost+=(green[x]+blue[x]);
else if(x==j)cost+=(red[x]+blue[x]);
else if(x==k)cost+=(red[x]+green[x]);
else cost+=(red[x]+green[x]+blue[x]-max(red[x],max(green[x],blue[x])));
}
ans=min(ans,cost);
}
}
}
return ans==1000000000? -1:ans ;
}
};
 </description>
    </item>
    
    <item>
      <title>１つの要素に着目した２つの配列のソート</title>
      <link>https://chaingng.github.io/post/%EF%BC%91%E3%81%A4%E3%81%AE%E8%A6%81%E7%B4%A0%E3%81%AB%E7%9D%80%E7%9B%AE%E3%81%97%E3%81%9F%EF%BC%92%E3%81%A4%E3%81%AE%E9%85%8D%E5%88%97%E3%81%AE%E3%82%BD%E3%83%BC%E3%83%88/</link>
      <pubDate>Sun, 16 Jun 2013 23:08:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%EF%BC%91%E3%81%A4%E3%81%AE%E8%A6%81%E7%B4%A0%E3%81%AB%E7%9D%80%E7%9B%AE%E3%81%97%E3%81%9F%EF%BC%92%E3%81%A4%E3%81%AE%E9%85%8D%E5%88%97%E3%81%AE%E3%82%BD%E3%83%BC%E3%83%88/</guid>
      <description>c++での方法ですが、
２つの配列の各要素が関係しているとき、
ひとつの配列の要素順に両方をソートする方法です。
まずはペア型のコンテナを宣言。
vector &amp;lt;pair &amp;lt;int, int&amp;gt; &amp;gt; enemy;
次に２つの配列の要素を格納。
このとき、ソートしたい要素の配列を最初に格納する。
FORE(i,0,eS.size())enemy.push_back(make_pair(eS[i],eC[i]));
あとは普通にソートしてあげるだけで、1つ目の要素順にソートされます。
sort(enemy.begin(),enemy.end());
このように、使いたい要素は以下のように使えます。
if(mS[curg]&amp;gt;=enemy[cure].first)
FORE(i,0,enemy.size())n+=enemy[i].second;
ときどき役に立つのでメモしておきました。 </description>
    </item>
    
    <item>
      <title>SRM582 DIV2 -Level1,2</title>
      <link>https://chaingng.github.io/post/srm582-div2--level12/</link>
      <pubDate>Sat, 15 Jun 2013 11:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm582-div2--level12/</guid>
      <description>やっと緑コーダーになれました。
SYSTEMテストで２回連続で落ちていて、３度目の正直。
Challengeを今までまったくしておらず、ちゃんとコード書けることが大事だからいらないかなと思っていました。
ただ、撃墜できること＝自分のコードの抜け漏れがチェックできる、ということにもつながるのでこれからはちょっと力を入れていきたいです。
Ｌｅｖｅｌ１
＜問題＞
①２以上のある整数Ｎが与えられる。
②a&amp;gt;=1,b&amp;gt;1,a&amp;lt;b, a*b*b=Nとなる数字が存在する場合はYes、
そうでない場合はNoを返す。
＜解き方＞
単純に実装するだけです。
全探索でもよいのですが、Yesならb*bは必ず存在するので
bを1からb*b&amp;lt;=Nまでまわして判定しました。
＜コード＞
class SemiPerfectSquare {
public: string check(int N) {
for(int i=1;i*i&amp;lt;=N;i++){
if(N%(i*i)==0 &amp;amp;&amp;amp; N/(i*i)&amp;lt;i)return &#34;Yes&#34;;
}
return &#34;No&#34;;
}
};
Ｌｅｖｅｌ２
＜問題＞
①魔法少女の強さの順列、敵の強さの順列と各敵の数が与えられる。
②魔法少女は１匹敵を倒すたびに疲れが１増える。最初は０。
③このとき、全ての敵を倒した時に魔法少女の中で最も大きい疲れが最小となるものを返す。全ての敵を倒せない場合はー１を返す。
＜解き方＞
全ての魔法少女が全ての敵を倒すことができる理想の状態を考えると、
各魔法少女は「Ｎ＝全ての敵の数／全ての魔法少女の数」の敵を倒せばよい。
ただそうでないケースも存在するので、その場合をシミュレーションで実装する。
まずは魔法少女と敵を強さの昇順にソートして例外処理を行う。
一番強い魔法少女の強さより、最も強い敵の強さが高ければ
全ての敵を倒せないのでー１を返す。
次に、魔法少女が倒すことができない敵が出た時は次の魔法少女に移り、
「Ｎ＝残りの敵の数／残りの魔法少女の数」を再計算してあげる。
すべてシミュレーションが終了した時、最も高い疲れの値を返してあげればよい。
＜関数＞
２つの配列について、一つの配列の値に対してソートできれば簡単になる。
＜コード＞
class SpaceWarDiv2 {
public: int minimalFatigue(vector&amp;lt;int&amp;gt; mS, vector&amp;lt;int&amp;gt; eS, vector&amp;lt;int&amp;gt; eC) {
vector &amp;lt;pair &amp;lt;int, int&amp;gt; &amp;gt; enemy;</description>
    </item>
    
    <item>
      <title>SRM569 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm569-div2--level2/</link>
      <pubDate>Fri, 14 Jun 2013 09:11:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm569-div2--level2/</guid>
      <description>＜問題＞
①０と１で構成される2次元配列が与えられる。
②各ビット列の任意の２つに対し、それぞれＯＲかＸＯＲかＡＮＤ演算をするデバイスがビット列分存在する。
③各ビット列に対しどの操作をするか決まっているが、それがどれかはわかっていない。
④このとき、各デバイスがどの操作をするか確かめることができれば”ＹＥＳ”、できなければ”ＮＯ”を返す。
＜解き方＞
各ビット列に対し、特定の数字が含まれていればデバイスの操作を確かめることができる。
ＯＲとＡＮＤの場合
０，１→ＯＲだと１、ＡＮＤだと０
ＯＲとＸＯＲの場合
１，１→ＯＲだと１、ＸＯＲだと０
ＡＮＤとＸＯＲの場合
０，１→ＡＮＤだと０、ＸＯＲだと１
１，１→ＡＮＤだと１、ＸＯＲだと０
この３つを判定するには、１が２つ、０が１つ最低あればよいことになる。
各ビット列に対し１が２つ、０が１つ以上あるか判定し、
なければＮＯ，あればＹＥＳを返す。
＜コード＞
class TheDeviceDiv2 {
public: string identify(vector&amp;lt;string&amp;gt; plates) {
FORE(j,0,(int)plates[0].size()){
int one=0,zero=0;
FORE(i,0,(int)plates.size()){
if(plates[i][j]==&#39;1&#39;)one++;
else zero++;
}
if(!(one&amp;gt;=2 &amp;amp;&amp;amp; zero&amp;gt;=1))return &#34;NO&#34;;
}
return &#34;YES&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM570 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm570-div2--level2/</link>
      <pubDate>Wed, 12 Jun 2013 23:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm570-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①数字の順列が与えられる。
②各数字に対して、ロボットはその数字の分前に進む。進んだ後は右に９０度回転する。
③最後の数字まで進む処理をＴ回繰り返す。
④このとき、最初と最後の位置のマンハッタン距離を返す。
＜解き方＞
数字の数は最大５０個、Ｔは最大１００回なので最大の場合でもＯ（５０００）。
計算量が余裕で間に合うので純粋にシミュレーションを実装する。
＜コード＞
class RobotHerbDiv2 {
public: int getdist(int T, vector&amp;lt;int&amp;gt; a) {
int x=0,y=0,dir=0;
FORE(h,0,T){
FORE(i,0,a.size()){
if(dir%4==0)y+=a[i];
if(dir%4==1)x+=a[i];
if(dir%4==2)y-=a[i];
if(dir%4==3)x-=a[i];
dir+=(a[i]%4);
}
}
return abs(x)+abs(y);
}
}; </description>
    </item>
    
    <item>
      <title>SRM544 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm544-div2--level2/</link>
      <pubDate>Wed, 12 Jun 2013 21:04:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm544-div2--level2/</guid>
      <description>＜問題＞
①求めたい長さ(desiredL)と、求めたい長さ(desiredN)の本数と、実際の長さ(actualL)が与えられる。
②実際の長さは好きなだけ本数が与えられる。
③実際の長さを切ることで、求めたい長さを、求めたい本数だけ求める。
④このとき、切る数の最小値を求める。
＜解き方＞
実際の長さは何本でも与えられて本数は答えに影響しないため、
求めたい長さから実際の長さで割った余りを求める。
そうすることで、余りの長さに対してだけ考えればよくなる。
このとき、余りが０であれば切らなくても答えが求められるので０を返す。
次に、単純に実際の長さから余りの長さ分切って求めると、求めたい長さの本数が求めたい長さになる。
こう考えると数学的解放で解けそうですが、以下の例外があるため
シミュレーションに切り替えます。
①余りの長さ分切ったときに割り切れることができる場合
最後に求めたい長さのものがもう１本できる。
②余りが発生かつ、その余りが何度か出た時に足すことで余りの長さに達するとき
もう１本分作ることができる。
Ｃｈａｌｌｅｎｇｅポイント
上記だと、「余りの長さがぴったりではない場合」に判定がスルーされてしまいます。
例えば１０の長さが欲しいが余りが４のとき、
４＋４＋４＋４＋４＝２０でずっと判定されないのですが
実は（４＋４＋２）＋（４＋４＋２）で１回割ると２本できてしまいます。
これを避けるためには、１０を超えた時は１０に分割することで
この部分も判定に含めることができます。
かなり見落としがちです。
＜コード＞
class BoardSplitting {
public: int minimumCuts(int desiredL, int desiredC, int actualL) {
int L=desiredL%actualL;
int tmpL=actualL,remain=0,cut=0;
if(L==0)return 0;
while(desiredC&amp;gt;0){
tmpL-=L;
cut++;
desiredC--;
if(tmpL&amp;gt;L)continue;
if(desiredC==0)break;
remain+=tmpL;
tmpL=actualL;
if(remain&amp;gt;=L){
if(remain!=L)cut++;
desiredC--;
remain-=L;
}
}
return cut;
}
}; </description>
    </item>
    
    <item>
      <title>SRM571 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm571-div2--level2/</link>
      <pubDate>Tue, 11 Jun 2013 22:47:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm571-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①数字Ｎが与えられる。
②１からＮまでの数字が付けられたｍｐ３ファイル、&#34;1.mp3&#34;,&#34;2.mp3&#34;...&#34;n.mp3&#34;が作られる。
③このとき、ファイル名を辞書順に並べたときの配列を返す。
ただし、Ｎが５０を超える場合は最初の５０個を返す。
＜解き方＞
辞書順、ということに気づいて文字列のソートができればＯＫ．
要素が５０個を超える場合は、最初の５０個のみ表示するということに注意。
&amp;lt;コード&amp;gt;
class FoxAndMp3Easy {
public: vector&amp;lt;string&amp;gt; playList(int n) {
vector &amp;lt;string&amp;gt; vx,ans;
for(int i=1;i&amp;lt;=n;i++){
stringstream ss;
ss &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#34;.mp3&#34;;
string tmp;
ss &amp;gt;&amp;gt;tmp;
vx.push_back(tmp);
}
sort(vx.begin(),vx.end());
for(int i=0;i&amp;lt;min(50,n);i++)ans.push_back(vx[i]);
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>SRM572 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm572-div2--level2/</link>
      <pubDate>Tue, 11 Jun 2013 22:23:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm572-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①２つの文字列が与えられる。
②それぞれの文字は、1回につきprevCostで前の文字に変えることができる。(aを除く)
③それぞれの文字は、1回につきnextCostで次の文字に変えることができる。(zを除く)
④このとき、最初の文字列から２つ目の文字列に変換するのにかかる最小のコストを返す。ただし、いつでも文字列中に同じ文字が存在してはならない。変えることができない場合はー１を返す。
＜解き方＞
シミュレーションを全探索で考えるのは難しいので効率のよい探索を考える。
まず、同じ文字が存在するかしないかは、２つの文字を相対的に見ればよい。
次に、どのケースのとき同じ文字列が存在するかを考える。
①２つが同じ順番のとき
（小さい文字から大きい文字に変換）
startが比較対象のstartより大きいかつ、goalが比較対象のgoalより小さいとＮＧ
（大きい文字から小さい文字に変換）
startが比較対象のstartより小さいかつ、goalが比較対象のgoalより大きいとＮＧ
②逆の順番のとき
startが比較対象の文字より小さいかつ、goalが比較対象のgoalより大きいとＮＧ
もしくは
startが比較対象の文字より大きいかつ、goalが比較対象のgoalより小さいとＮＧ
（より、と書きましたが＝も含みます）
上記でもＯＫですが、
２つの文字の比較は上下が変わっても相対的に見れば同じことがわかれば
まとめることができます。
つまり、(start[i]-start[j])*(goal[i]-goal[j])&amp;lt;=0のときは-1を返してやればいいです。
あとはコストは常に移動の最小となるので、同じ文字が存在するときはー１、そうでなければ移動の最小コストを返してあげればＯＫです。
＜コード＞
class NextOrPrev {
public: int getMinimum(int nextCost, int prevCost, string start, string goal) {
int ans=0;
int n=start.size();
FORE(i,0,n){
if(start[i]==goal[i])continue;
if(start[i]&amp;lt;goal[i])ans+=(abs(start[i]-goal[i])*nextCost);
else ans+=(abs(start[i]-goal[i])*prevCost);
}
FORE(i,0,n)FORE(j,i+1,n)if((start[i]-start[j])*(goal[i]-goal[j])&amp;lt;=0)return -1;
return ans;
}
};
 </description>
    </item>
    
    <item>
      <title>SRM573 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm573-div2--level2/</link>
      <pubDate>Mon, 10 Jun 2013 21:59:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm573-div2--level2/</guid>
      <description>&amp;lt;問題&amp;gt;
①数字の列が与えられる。数字の数はそれぞれの人のプログラミング能力の強さを表す。
②そのうち３人一組でチームを作り、チームの強さは３人のうち強い方から２人の強さの和となる。
③自分のチームは数字の列の最初から３人で構成される。
④このとき、様々なチームの組み合わせのうち、最も自分のチームの順位が低くなるときの順位を返す。
＜解き方＞
自分のチームは最初の３人なので、それを省いて考えると最大でＮ＝４5。
全探索で考えると、Ｏ（４５Ｃ３×４２Ｃ3）．．．となり難しそう。
次に貪欲法で考える。
まずは数字列をソートすることで、小さい順に並べることで大きい数だけを扱えばよいことは思いつく。
このとき、「チームの強さは３人のうち強い方から２人の強さの和」から
「一番弱い一人は考えなくてよい」ので、
最初のN/3より小さい数は考えなくてよいことがわかる。
そのため、Ｎ／３～Ｎ－１番までの２人の組み合わせについて考えればよい。
ここまででＯ（３０Ｃ２×２８Ｃ２・・・）。まだ足りない。
次に、Ｎ／３番から始まる昇順で数字をindex1、Ｎ－１から降順で始まる数字をindex2とすると、
仮にindex1=Ｎ／３のとき
①index2=N-1の数字の和が自分のチームより大きければ
→index1は自分よりも強いチームに所属（答えを＋）
②小さい場合
→index1は自分よりも弱いチームに所属（次のindex1に移動）
することになる。
最後に貪欲法で抜けがないか確認。
index2=N-1がＯＫのとき、N-1未満の値でもチームが作れたとしても、
それ以上のindex1の場合は常にindex=N-1の値はそれ以上に強いチームの値になるので
必ず使われることになる。
そのため単純に strength[index1]+strength[index2]の和を試し、
自分のチーム以上であればindex1++,index2--,答えを+し、
それ以下であればindex++のみでよいことがわかる。
Challengeのポイント
最初、判定後に要素を取り除いていなかったので
きちんと要素を取り除いているかを確認する。
＜コード＞
class TeamContestEasy {
public: int worstRank(vector&amp;lt;int&amp;gt; st) {
int my=st[0]+st[1]+st[2]-min(st[0],min(st[1],st[2]));
int rank=1;
sort(st.begin()+3,st.end());
int low=3+(st.size()-3)/3,high=st.size()-1;
while(low&amp;lt;high){
if(st[low]+st[high]&amp;gt;my){
low++;
high--;
rank++;
}
else low++;
}
return rank;
}
};
 </description>
    </item>
    
    <item>
      <title>SRM545 DIV2 -Level2</title>
      <link>https://chaingng.github.io/post/srm545-div2--level2/</link>
      <pubDate>Sun, 09 Jun 2013 10:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm545-div2--level2/</guid>
      <description>＜問題＞
①文字数ｎが与えられる。
②最小文字列minStrが与えられる。
③文字列s中の順番i&amp;lt;jでs[i]&amp;gt;s[j]となるとき、inversionが１となるとき、
最小のinversion minInvが与えられる。
④このとき、文字数nでminStrより大きく、かつminInv以上の中で
最も辞書順で小さい文字列を求める。
そのような文字列が存在しなければ””を返す。
また、文字列には同じ文字が入らないとする。
＜解き方＞
まずは全探索で考えると、文字数nの全てに対してminInv,minStrの判定を行い
その中で最も辞書順で小さい文字列を探索することになる。
単純に検索するとO(26Pn=26!/(26-n)!)のため計算量を超えてしまう。
次に貪欲法でできないか考える。
文字の後ろから計算するとオーバーしてしまうので、最初の文字から決定していく。
このとき、求めるのは辞書順最小であるためaから順に調べていく。
aの後に続く文字は、そのケースのstr,invの最大を考えることでaなのか
b以上なのか判定できる。
（例）n=5のとき、afdcbを考え、minInv以下、もしくはminStr以下であれば
最初の文字はa以上となる。
この場合だとO(26*n)のため計算量に収まる。
あと、条件に一致しなければ&#34;&#34;を返すため、答えの初期値を&#34;&#34;とする。
その文字を使ったか使っていないかの判定はused[]配列を用いてもよいが、
ビット計算でもよい。
redcoderの人の回答を参考に書いたままです。
&amp;lt;コード&amp;gt;
class StrIIRec {
public: string recovstr(int n, int minInv, string minStr) {
string ans=&#34;&#34;;
int used=0;
FORE(i,0,n){
FORE(j,0,n){
if(used&amp;amp;(1&amp;lt;&amp;lt;j))continue;
string s=ans;
s+=(j+&#39;a&#39;);
for(int k=n-1;k&amp;gt;=0;k--)if(!(used&amp;amp;(1&amp;lt;&amp;lt;k)) &amp;amp;&amp;amp; k!=j)s+=(k+&#39;a&#39;);
if(s&amp;lt;minStr)continue;
int inv=0;
FORE(k,0,n)FORE(l,k+1,n)if(s[k]&amp;gt;s[l])inv++;
if(inv&amp;lt;minInv)continue;
ans+=(j+&#39;a&#39;);
used|=(1&amp;lt;&amp;lt;j);
break;
}
}
return ans;
}
}; </description>
    </item>
    
    <item>
      <title>二分探索</title>
      <link>https://chaingng.github.io/post/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/</link>
      <pubDate>Fri, 07 Jun 2013 09:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/</guid>
      <description>二分探索について考えたいと思います。
■適用できそうな問題
・最長・最短というキーワードがあること。
・Ｃ（ｘ)を満たすという条件があること。
・全てのｘ’がＣ（ｘ’）を満たすこと。
■計算量
O(log N)
log Nというのが今までイメージしにくかったのですが、
N=8であれば8/2→4/2→2/2→1となるので例を出すと納得。
■終了条件
整数を返すのであればhigh-low&amp;gt;1で可能だが、
double型のときは注意が必要。
特に1e-9以下の誤差で求めるというときは
high-low&amp;gt;1e-9(10^-9)とすると丸め誤差で収束しないというエラーが起きる。
対処方法は以下の２つ。
&amp;nbsp; &amp;nbsp;①high-low&amp;gt;1e-9 || (high-low)/high &amp;gt;1e-9と
絶対誤差と相対誤差の２つで判定する。
ただ、highで割るときは０にならないような注意が必要。 ②for(int i=0;i&amp;lt;100;i++)のように100回程度ループを回すことで
2^-100→(2^10)^-10→10^-30倍となり
1e-9以下とすることができる。
■ＳＴＬ
lower_bound(num.begin(),num.end(),7)
指定した値「以上」の要素が最初に現れる位置を返す
 </description>
    </item>
    
    <item>
      <title>SRM548 DIV2 -500points</title>
      <link>https://chaingng.github.io/post/srm548-div2--500points/</link>
      <pubDate>Thu, 06 Jun 2013 00:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm548-div2--500points/</guid>
      <description>&amp;lt;問題&amp;gt;
①数字の順列が与えられる。
②魔法の数字Ｌを使うことで、それぞれの数字からＬを引く、または足すことができる。
③このとき、与えられた数字の順列を昇順にするために必要な最小のＬを返す。
&amp;lt;解き方&amp;gt;
二分探索で解けることがわかれば、の問題でした。
終了条件の設定を間違えると無限ループが続いてしまったり、
答えがlowかhighのどちらかの判定を加えなければいけなくなります。
そこで答えを満たす時はmidを範囲に加えて、
満たさないときはlow=mid+1とmidを範囲に加えないことで
low&amp;lt;highの条件で収束することができます。
&amp;lt;コード&amp;gt;
class KingdomAndTrees {
bool f(vector&amp;lt;int&amp;gt; h, int x){
int prev=0;
FORE(i,0,(int)h.size()){
if(h[i]+x&amp;lt;=prev)return false;
prev=max(prev+1,h[i]-x);
}
return true;
}
public:
int minLevel(vector&amp;lt;int&amp;gt; heights) {
int low=0,high=1000000000;
while(high-low&amp;gt;0){
int mid=(low+high)/2;
if(f(heights,mid))high=mid;
else low=mid+1;
}
return high;
}
}; </description>
    </item>
    
    <item>
      <title>SRM581 DIV2 -500points</title>
      <link>https://chaingng.github.io/post/srm581-div2--500points/</link>
      <pubDate>Tue, 04 Jun 2013 23:32:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm581-div2--500points/</guid>
      <description>＜問題＞
①コンテナが入っているか（ｘ）、入っていないか（ー）を現す部屋の順列が与えられる。
（例）ーーｘｘｘ－－－
②各監視カメラが監視しているコンテナの数が与えられる。
（例）｛0、１，２，１｝
③監視カメラが監視できる部屋の数が与えられる。監視できる部屋は連続したＬになる。
また、各監視カメラは全く同じ範囲を監視することはできない。
（例）　Ｌ＝３
④このとき、各部屋が監視されていれば＋、監視されていなければー、どちらかわからなければ？で現される順列を返す。
＜解き方＞
・各監視カメラが監視しているコンテナの順列をsortし、同じコンテナの数を数える。
（仮に、１が２つあればreportnum＝２とする）
・同じ数のコンテナを監視している中で、各部屋を監視しているパターンの和と順列を求める。
（仮に、１個のコンテナを監視できるパターンが１０通りあればtotalnum=10とする）
（１１２２３２１１のように、その１０通りのパターンで監視できる部屋の数の和を求める）
そのとき、その順列中の数がtotalnum-reportnumより大きければ＋、それ以下でかつ０以上であれば？となる。
当日は問題のexampleを２つぐらいしか見ずに解いてしまったので、上のパターンを見逃してしまいました。
コーディングにとりかかる前に、exampleは全て確認するか自分で網羅性のある例を出してイメージを膨らませることが大事だと思いました。
あと、なぜかstringの初期化コード
string ans;
FOR(i,0,n)ans+=&#39;-&#39;;
を最初書いたらエラーになるexampleがあったのに、
同じ内容を書き直してみると通ったのは不思議でした。
＜ソース＞
string getContainerInfo(string containers, vector&amp;lt;int&amp;gt; reports, int L) {
int n=containers.size(),reportnum=1;
string ans;
FOR(i,0,n)ans+=&#39;-&#39;;
sort(reports.begin(),reports.end());
FORE(i,0,(int)reports.size()){
if(i!=(int)reports.size()-1 &amp;amp;&amp;amp; reports[i]==reports[i+1]){
reportnum++;
continue;
}
vector&amp;lt;int&amp;gt; tmp(n,0);
int totalnum=0;
FORE(j,0,n-L+1){
int count=0;
FORE(k,j,j+L)if(containers[k]==&#39;X&#39;)count++;
if(count!=reports[i])continue;
FORE(k,j,j+L)tmp[k]++;
totalnum++;
}
FORE(j,0,n){
if(tmp[j]&amp;gt;totalnum-reportnum)ans[j]=&#39;+&#39;;
else if(tmp[j]&amp;gt;0 &amp;amp;&amp;amp; ans[j]!=&#39;+&#39;)ans[j]=&#39;?&#39;;
}
reportnum=1;
}
return ans;</description>
    </item>
    
    <item>
      <title>自分に原因があると考える</title>
      <link>https://chaingng.github.io/post/%E8%87%AA%E5%88%86%E3%81%AB%E5%8E%9F%E5%9B%A0%E3%81%8C%E3%81%82%E3%82%8B%E3%81%A8%E8%80%83%E3%81%88%E3%82%8B/</link>
      <pubDate>Mon, 03 Jun 2013 21:20:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E8%87%AA%E5%88%86%E3%81%AB%E5%8E%9F%E5%9B%A0%E3%81%8C%E3%81%82%E3%82%8B%E3%81%A8%E8%80%83%E3%81%88%E3%82%8B/</guid>
      <description>以前本でも読んだことがあった気がするのですが、
ある程度歳を重ねると、年齢の下の人が相対的に多くなることと、
合わせて色々な経験も重ねていることからか周りのミスに対して怒りがちになる傾向があるそうです。
でもよくよく考えてみると、相手が原因に見えるミスが起こったとしても自分にまったく原因がないか？自分がどうやっても起こったミスか？と考えると、そうではないことのほうが多いと思います。
そう考えて、なにか失敗が起こったときも相手を責めるのではなく、自分を省みて次からこうしようと思えば自分の成長にもなるし、相手ともいい関係を築けると思います。
常にその心がけを持ち続けたいです。
 </description>
    </item>
    
    <item>
      <title>SRM575 DIV2 -500points</title>
      <link>https://chaingng.github.io/post/srm575-div2--500points/</link>
      <pubDate>Sun, 19 May 2013 23:43:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm575-div2--500points/</guid>
      <description>＜問題＞
①ある正の整数が与えられる。
例）１５
②整数は１かその数自身を除いた約数で除算ができる。
例）１５－３＝１２
③ＪｏｈｎとＢｒｕｓの２人でゲームをし、除算ができなくなった方が負け。
最初のターンはＪｏｈｎ。
④このとき、与えられた整数に対して勝つ方のプレイヤー名を返す。
＜関数＞
memset(f,0,sizeof(f));
数字を０で初期化する関数。
これも使えますが、単純に宣言での初期化をしました。
return f[n] ? &#34;John&#34; : &#34;Brus&#34;;
f[n]が正の時は&#34;John&#34;、偽の時は&#34;Brus&#34;を返す。
これでもＯＫですが、if文でも。
Challengeポイント
最初はjをj&amp;lt;i/2としましたが、i/2は含めないといけなかったので
システムテストでfail。
安全にj&amp;lt;iまで最後までまわした方がよいですね。
＜考え方＞
特定の整数が与えられた際、勝ちか負けかが一意に決まる。
これを利用し１から初めて、
与えられた整数まで全ての数に対して勝ち負けの状態遷移を保存する。
1,2,3～6ぐらいまでシミュレーションしてみると、
ある整数に対し、それ未満の割り切れる整数に対し
check[i-j]が0になれば勝ちなので1とする。それ以外は0のまま。
＜コード＞
class TheNumberGameDivTwo {
public: string find(int n) {
vector&amp;lt;int&amp;gt; check(n+1,0);
FORE(i,1,n+1){
FORE(j,2,i)if(i%j==0 &amp;amp;&amp;amp; check[i-j]==0)check[i]=1;
}
if(check[n]==1)return &#34;John&#34;;
return &#34;Brus&#34;;
}
}; </description>
    </item>
    
    <item>
      <title>SRM579 DIV2 -550points</title>
      <link>https://chaingng.github.io/post/srm579-div2--550points/</link>
      <pubDate>Sun, 19 May 2013 23:25:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm579-div2--550points/</guid>
      <description>＜問題＞
①複数の単語が与えられる。
②ディスプレイ・入力画面、ＵＮＤＯ領域の３つが与えられる。
③キー入力は入力画面に現れ、ＥＮＴＥＲボタンを１回クリックでディスプレイに表示。
④一度入力した文字は２回の操作でＵＮＤOから呼び出せる。
⑤与えられた単語を順にディスプレイに表示するとき、最小の操作回数を返す。
＜関数＞
line[i].substr(0,line[i-1])
単語の一致判定に部分文字列を利用
for(k=0;k&amp;lt;min((int)lines[i].size(), (int)lines[j].size());k++)
単語の判定でループを回す際は、終了条件に単語の長さを考慮
＜考え方＞
①単語ごとにＥＮＴＥＲボタン１回は必ず必要。
②次の単語を入力する際の方法は３通り。
１．ＵＮＤＯで””を呼び出してから、新しい単語を１から入力
２．ＵＮＤＯで”ｔｐ”など次の単語の一部を呼び出してから残りの文字を入力
３．前の単語から文字を足すだけで次の単語になる場合は、そのまま続けて入力
この操作をそのままプログラムにします。
int minPresses(vector&amp;lt;string&amp;gt; lines) {
int n=lines.size();
int ans=lines[0].size()+1;
FORE(i,1,n){
int cost=lines[i].size()+1+2;
FORE(j,0,i){
int k;
for(k=0;k&amp;lt;min((int)lines[i].size(), (int)lines[j].size());k++)
if(lines[i][k]!=lines[j][k])break;
cost=min(cost, (int)lines[i].size()-k+1+2);
}
if(lines[i].substr(0,lines[i-1].size())==lines[i-1])
cost=min(cost,(int)lines[i].size()-(int)lines[i-1].size()+1);
ans+=cost;
}
return ans;
 </description>
    </item>
    
    <item>
      <title>SRM576 DIV2 -250points</title>
      <link>https://chaingng.github.io/post/srm576-div2--250points/</link>
      <pubDate>Wed, 15 May 2013 23:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm576-div2--250points/</guid>
      <description>＜問題＞
①蛇口の数と、蛇口ごとにそこから出る水滴の数が与えられる。
例）３，４，１，１，５，６
②スポンジの長さＬが与えられる。
例）Ｌ＝３
③それぞれのスポンジについて、上から降順に配列が与えられる。
配列の値は、スポンジの左側の位置。
例）３，１，０
④蛇口の水滴は、一番最初に当たった水滴に吸収される。
⑤このとき、各スポンジが吸収した水滴の値を配列で返す。
＜ポイント＞
・上にあるスポンジ、すなわちスポンジの配列の右側から
その位置に相当する水滴の数を足してあげて、
スポンジごとの合計を配列に格納する。
「いったん吸収された水滴は０にクリアにする」ことで重複がなくなるのがポイント。
vector&amp;lt;int&amp;gt; determineHumidity(vector&amp;lt;int&amp;gt; intensity, int L, vector&amp;lt;int&amp;gt; leftEnd) {
vector &amp;lt;int&amp;gt; ans;
FORE(i,0,leftEnd.size()){
int tmp=0;
FOR(j,0,L){
tmp+=intensity[leftEnd[i]+j];
intensity[leftEnd[i]+j]=0;
}
ans.push_back(tmp);
}
return ans;
 </description>
    </item>
    
    <item>
      <title>Topcoder 解いた問題のまとめ</title>
      <link>https://chaingng.github.io/post/topcoder-%E8%A7%A3%E3%81%84%E3%81%9F%E5%95%8F%E9%A1%8C%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81/</link>
      <pubDate>Wed, 15 May 2013 19:57:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/topcoder-%E8%A7%A3%E3%81%84%E3%81%9F%E5%95%8F%E9%A1%8C%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81/</guid>
      <description>Div2
SRM574 250points&amp;nbsp;500points
SRM575 250points&amp;nbsp;500points
SRM576 250points&amp;nbsp;500points
SRM577 250points 500points
SRM578 250points&amp;nbsp;500points
SRM579 250points&amp;nbsp;550points
 </description>
    </item>
    
    <item>
      <title>SRM577 DIV2 -500points</title>
      <link>https://chaingng.github.io/post/srm577-div2--500points/</link>
      <pubDate>Wed, 15 May 2013 19:53:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm577-div2--500points/</guid>
      <description>＜問題＞
①Ｎ個の数字が与えられる。
例）42 911 666 17 13 1 1155 1094 815 5 1000 540
②一番最初の数字が自分の値。
③大きい数字の順から２０個取り出され、Ｒ個の部屋にそれぞれランダムに割り当てられる。
④１個の部屋には２０人まで収容できる。
⑤部屋の数はＮ／２０、またＮが２０の倍数ならＮ／２０＋１。
⑤このとき、一番最大の数字と自分の数字が同じ部屋に割り当てられる確率を返す。
＜関数＞
数字がintではなくstringにて、空白区切りで与えられ、しかも複数のstringで与えられるのでvector&amp;lt;int&amp;gt;に戻す処理が必要。
FORE(i,0,ratings.size())strg+=ratings[i];
にて複数のstring配列を一つにし、
stringstream out(strg);
にて読み込み、
while(out &amp;gt;&amp;gt; tmp)vx.push_back(tmp);
にてvector&amp;lt;int&amp;gt;に挿入してます。
＜考え方＞
以下の場合に分けられる。
①数字が２０個以内であれば、必ず同じ部屋になる。　→１
②自分の数字の順位が降順で部屋の数以内であれば、同じ部屋にならない。→０
③それ以外の場合、１／Ｒ。
また、Ｎの数字によってＲの場合分けをする。
Ｎ＝１９　→　（１９＋１９）／２０＝１
Ｎ＝２０　→　（２０＋１９）／２０＝１
Ｎ＝２１　→　（２１＋１９）／２０＝２
となるので、Ｒ＝（Ｎ＋１９）／２０となり、
確率は１／（（Ｎ＋１９）／２０）。
double getProbability(vector&amp;lt;string&amp;gt; ratings) {
int n,tmp,rank=1,r;
vector &amp;lt;int&amp;gt; vx;
string strg=&#34;&#34;;
FORE(i,0,ratings.size())strg+=ratings[i];
stringstream out(strg);
while(out &amp;gt;&amp;gt; tmp)vx.push_back(tmp);
n=vx.size();
r=(n+19)/20;
FORE(i,0,n)if(vx[i]&amp;gt;vx[0])rank++;
if(n&amp;lt;=20)return 1;</description>
    </item>
    
    <item>
      <title>SRM578 DIV2 -500points</title>
      <link>https://chaingng.github.io/post/srm578-div2--500points/</link>
      <pubDate>Mon, 13 May 2013 22:55:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm578-div2--500points/</guid>
      <description>＜問題＞
①四角形のフィールドとマンハッタン距離が与えられる。
各セルに鳥が入れば「v」、いなければ「.」で表わされる。
②鳥はガチョウかアヒルだがフィールドだけ見てもわからない。
③ガチョウは少なくとも１匹存在する。
④ガチョウとマンハッタン距離以内にある鳥は必ずガチョウになる。
⑤このとき、ガチョウとアヒルの位置について場合の数を返す。
＜関数＞
座標を保管するテンプレート。
queue &amp;lt;pair &amp;lt;int,int &amp;gt; &amp;gt; q;
q.push(make_pair(x,y)); で(x,y)の座標を保管できます。
i=q.front().first; でxを取り出し、
j=q.front().second;　でyを取り出せます。
＜考え方＞
あるガチョウとマンハッタン距離以内にある鳥は全てガチョウということは
逆を返すと、あるアヒルとマンハッタン距離以内にある鳥は全てアヒルになる。
つまり、マンハッタン距離にある鳥同士は全てガチョウ、もしくは全てアヒルになるということがわかる。
これがわかれば、
「マンハッタン距離にある鳥の集合の数＊２」が場合の数にあることが導ける。
ただし、それだとガチョウがいない場合が存在するので、最後に１を引く必要がある。
int count(vector&amp;lt;string&amp;gt; field, int dist) {
int h=field.size(),w=field[0].size();
int ans=1,MOD=1000000007;
queue &amp;lt;pair &amp;lt;int, int&amp;gt; &amp;gt; q;
for(int i=0;i&amp;lt;h;i++){
for(int j=0;j&amp;lt;w;j++){
if(field[i][j]!=&#39;v&#39;)continue;
q.push(make_pair(i,j));
field[i][j]=&#39;.&#39;;
while(!q.empty()){
int x=q.front().first;
int y=q.front().second;
q.pop();
for(int k=0;k&amp;lt;h;k++)
for(int l=0;l&amp;lt;w;l++)
if(field[k][l]==&#39;v&#39; &amp;amp;&amp;amp; (abs(k-x)+abs(l-y))&amp;lt;=dist){
q.push(make_pair(k,l));
field[k][l]=&#39;.&#39;;
}
}
ans*=2;
ans%=MOD;</description>
    </item>
    
    <item>
      <title>SRM578 DIV2 -250points</title>
      <link>https://chaingng.github.io/post/srm578-div2--250points/</link>
      <pubDate>Mon, 13 May 2013 22:10:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/srm578-div2--250points/</guid>
      <description>問題
①鹿の数と、落ちている角の数が与えられる。
例）　鹿３匹、角２本
②鹿は角が０～２本である。
③このとき、角が２本ある鹿の数の最小値と最大値を求める。
関数
vector&amp;lt;int &amp;gt;が返り値なのでこれが使えれば。
vector &amp;lt;int&amp;gt; a;
a.push_back(b);でbを挿入できます。
考え方
最小値
鹿１匹につき角が１本落ちている場合なので
「鹿の数ー角の数」。
最大値
鹿１匹につき角が２本落ちている場合。
「鹿の数ー角の数／２」だが、
整数の計算なので奇数の場合と偶数の場合で結果が異なってしまうので整理。
鹿３匹、角１本　～　３－（１＋１）／２＝２匹
鹿３匹、角２本　～　３－（２＋１）／２＝２匹
鹿３匹、角３本　～　３－（３＋１）／２＝１匹
となるので、
「鹿の数ー（角の数＋１）／２」が最大値。
vector&amp;lt;int&amp;gt; getminmax(int N, int K) {
vector&amp;lt;int&amp;gt; ans(2);
ans.push_back(N-K);
ans.push_back(N-(K+1)/2);
return ans;
}
 </description>
    </item>
    
    <item>
      <title>一瞬一瞬を楽しむ</title>
      <link>https://chaingng.github.io/post/%E4%B8%80%E7%9E%AC%E4%B8%80%E7%9E%AC%E3%82%92%E6%A5%BD%E3%81%97%E3%82%80/</link>
      <pubDate>Sat, 27 Apr 2013 23:54:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E4%B8%80%E7%9E%AC%E4%B8%80%E7%9E%AC%E3%82%92%E6%A5%BD%E3%81%97%E3%82%80/</guid>
      <description>今日は家さがしでいろいろな不動産屋をまわって
内見したりしてきました。
相手と要望が違うので簡単に決まらなかったり
いろいろ考えるのも頭を使って疲れたりするのですが、
こういううまくいかないことも全て含めて楽しみたいなと、
逆に楽しまないと損だなと思います。
とは言っても、その瞬間瞬間はいろいろな波があるので
その時はそうは思えなかったりするものなのですが。
波音立たずすべてうまく行くのが理想とも思いつつ、
反対に波がありつつも、その状況を楽しむ、その考えを心の片隅に置いておきたいです。 </description>
    </item>
    
    <item>
      <title>電子書籍の活用</title>
      <link>https://chaingng.github.io/post/%E9%9B%BB%E5%AD%90%E6%9B%B8%E7%B1%8D%E3%81%AE%E6%B4%BB%E7%94%A8/</link>
      <pubDate>Thu, 25 Apr 2013 23:30:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E9%9B%BB%E5%AD%90%E6%9B%B8%E7%B1%8D%E3%81%AE%E6%B4%BB%E7%94%A8/</guid>
      <description>WEB+DBとSoftware Designの総集編がPDFでまとまっていると聞いて、
欲しくなってしまいました。
WEB+DB PRESS 総集編 [Vol.1～60]
posted with amazlet at 13.04.25森田 創 cho45 ミック 増井 俊之 山本 陽平 角谷 信太郎 中島 拓 縣 俊貴 大塚 知洋 伊藤 直也 小飼 弾 技術評論社 売り上げランキング: 1,194Amazon.co.jpで詳細を見る
Software Design 総集編 【2001~2012】
posted with amazlet at 13.04.25SoftwareDesign 編集部 技術評論社 売り上げランキング: 129Amazon.co.jpで詳細を見る

これを購入して、タブレットに入れて持ち歩いて、
仕事で必要なテーマが出てきたらその号を読んだりしたいなぁと思いました。
そう考え出すとタブレットはいままでそんなに欲しくなかったんですが
急に欲しくなってきました。
なにかタブレットを探さねば・・・。 </description>
    </item>
    
    <item>
      <title>違うことを細切れに</title>
      <link>https://chaingng.github.io/post/%E9%81%95%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E7%B4%B0%E5%88%87%E3%82%8C%E3%81%AB/</link>
      <pubDate>Wed, 24 Apr 2013 23:22:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E9%81%95%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E7%B4%B0%E5%88%87%E3%82%8C%E3%81%AB/</guid>
      <description>仕事でずっと同じことを続けてやっていたのですが、
途中で集中力が途切れるのを感じました。
こういうときは、違う仕事を細切れにやった方がいいと聞いたことがあります。
学校の授業がまさにそうで、時間割で授業が区切れているから集中力が続くもので、
ずっと同じ授業、たとえば英語が１日中続くと集中力はそれほど続かないので
学校教育とはよく考えられているなと思います。
違う仕事を適度にはさんでリフレッシュする、というのが
逆説的ですが集中力を持続させるために大事ですね。 </description>
    </item>
    
    <item>
      <title>情報収集のコツ</title>
      <link>https://chaingng.github.io/post/%E6%83%85%E5%A0%B1%E5%8F%8E%E9%9B%86%E3%81%AE%E3%82%B3%E3%83%84/</link>
      <pubDate>Tue, 23 Apr 2013 21:39:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E6%83%85%E5%A0%B1%E5%8F%8E%E9%9B%86%E3%81%AE%E3%82%B3%E3%83%84/</guid>
      <description>仕事上いろいろなセミナーの講演資料や、仕様書を読む機会が多いのですが
いつも漫然と流し読みしてしまいがちです。
そこで情報収集をうまく自分のものにするコツとして、
「Outputを意識したInputを心がける」ということにいつからか気付きました。
つまり資料に目を通しながらある「質問」を思い浮かべ、
その質問に答えるにはと考えると、関連した情報に目がいくようになり
目に入った情報も、後々説明できるように体系的に整理することができます。
情報収集の際は、この意識をいつも心掛けたいです。
 </description>
    </item>
    
    <item>
      <title>「challenge」には「change」が含まれる</title>
      <link>https://chaingng.github.io/post/challenge%E3%81%AB%E3%81%AFchange%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%82%8B/</link>
      <pubDate>Mon, 22 Apr 2013 22:33:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/challenge%E3%81%AB%E3%81%AFchange%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%82%8B/</guid>
      <description>今日は仕事の中で
いままでリーダーがやっていた仕事をやってみる？という機会がありました。
できあがったものはもちろん完璧なものではなく、修正が必要になったのだけれど
これこそチャレンジなのかなと思います。
修正が必要になったのも、ここをこうすればよいという学びにもなりましたし。
challengeの最初と最後の言葉をとると
「Cha」lle「nge」= Changeとなり、
まさにチャレンジには変化が含まれるものだと実感しました。
周りの仕事をすべて奪う姿勢で、ワンランク上の立場を目指して頑張っていきたいです。 </description>
    </item>
    
    <item>
      <title>hulu</title>
      <link>https://chaingng.github.io/post/hulu/</link>
      <pubDate>Sun, 21 Apr 2013 20:21:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/hulu/</guid>
      <description>映画での英語の勉強ですが、
ＴＳＵＴＡＹＡに毎回借りに行くのも手間がかかるので、
huluというＶＯＤサイトを試してみることに。
日本語版はラインナップが充実していますが、
英語字幕に対応しているものと対応していないものがあるみたいですね。
現状では英語字幕の映画がどれか検索することができないので、
学習に使うには難しそうという印象です。
一方で海外版のhuluでは、英語字幕の映画を検索できる模様。
日本では閲覧することはできないのですが、
海外版のサービスに合わせて日本版も検索サービスが充実してくれることを
期待します。 </description>
    </item>
    
    <item>
      <title>英語の学習方法</title>
      <link>https://chaingng.github.io/post/%E8%8B%B1%E8%AA%9E%E3%81%AE%E5%AD%A6%E7%BF%92%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 20 Apr 2013 21:01:00 +0000</pubDate>
      
      <guid>https://chaingng.github.io/post/%E8%8B%B1%E8%AA%9E%E3%81%AE%E5%AD%A6%E7%BF%92%E6%96%B9%E6%B3%95/</guid>
      <description>英語の学習方法について自分の経験からまとめてみます。
最初はＴＯＥＩＣで９９０点を目指して頑張りました。
始めた当初はは５００点ほどでしたが、２年ほどやって９９０点まではいかないまでも９５５点まで到達。
ここで自分を見返してみると、実際９５５点をとっても英語がペラペラになるのはほど遠く、足りないことが多すぎると実感。
ここから９９０点を目指すか、それとも目標を変えるか・・という岐路に立ちました。
そんな中で、会社の研修で海外での語学研修の機会をいただきました。
今回はビジネスでの英語の運用能力を身につけるというコンセプトなので、
レアジョブのようなオンライン英会話で１か月ほど準備しました。
そして研修で１カ月ほど海外へ。
メンバーは自分を入れて１０人未満で、ＴＯＥＩＣのスコアは６３０～とバラバラ。
自分はスコアも高い方でしたが、使うというレベルになると
もっと話慣れている人もいて「ＴＯＥＩＣのスコア＝英語の運用能力ではない」と実感。
ここで学んだことは２つです。
１つは、英語を話す度胸がついたこと。
１か月という期間ではペラペラになるまでにはとうてい到達しませんでしたが、
英語をとにかく話す、という研修カリキュラムで英語を話すことへの抵抗がまったくなくなりました。
これは大きな収穫でした。
２つめは、英語を使う上で何が一番重要かということです。
英語の能力はスピーキング、リスニング、ライティング、リーディングの４つに
分けられると思いますが、もっとも大事なのは「リスニング」と実感しました。
たとえばライティング、リーディングについては
いまは翻訳ソフトもあるし、リアルタイム性を求められないシチュエーションであれば
なんとかなるかなと。
ではスピーキングとリスニングどちらが重要かとなりますが、
ペラペラにしゃべれても、相手の言っていることが理解できなければ意思疎通は難しい場合も出てくるなと。
逆に相手の言っていることが聞きとれて、理解さえできれば
こちらの話はぎこちなくても、コミュニケーションの面ではなんとかなると思いました。
そこで日本に帰ってからは「リスニング」を、「楽しんで」やる方法を探すことに。
結局落ち着いたのは、イングリッシュパートナーを見つけて月１～２の頻度で
カフェでフリートークすることと、洋画を英語音声、英語字幕で見ることになりました。
「楽しんで」と書いたのは、英語は生涯学習だなと感じており、
勉強では続かないと思ったので楽しむにつきると考えたからです。
いまはちょこちょこ海外に行く機会や外国人と英語で話す機会が出てきていますが、
以前に比べてコミュニケーションがとりやすくなってきているなと実感しています。
 </description>
    </item>
    
  </channel>
</rss>